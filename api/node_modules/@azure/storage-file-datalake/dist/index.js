'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var tslib = require('tslib');
require('@azure/core-paging');
var storageBlob = require('@azure/storage-blob');
var coreHttp = require('@azure/core-http');
var coreTracing = require('@azure/core-tracing');
var logger$1 = require('@azure/logger');
var abortController = require('@azure/abort-controller');
var os = require('os');
var crypto = require('crypto');

// Copyright (c) Microsoft Corporation. All rights reserved.
/**
 * Credential policy used to sign HTTP(S) requests before sending. This is an
 * abstract class.
 *
 * @export
 * @abstract
 * @class CredentialPolicy
 * @extends {BaseRequestPolicy}
 */
var CredentialPolicy = /** @class */ (function (_super) {
    tslib.__extends(CredentialPolicy, _super);
    function CredentialPolicy() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Sends out request.
     *
     * @param {WebResource} request
     * @returns {Promise<HttpOperationResponse>}
     * @memberof CredentialPolicy
     */
    CredentialPolicy.prototype.sendRequest = function (request) {
        return this._nextPolicy.sendRequest(this.signRequest(request));
    };
    /**
     * Child classes must implement this method with request signing. This method
     * will be executed in {@link sendRequest}.
     *
     * @protected
     * @abstract
     * @param {WebResource} request
     * @returns {WebResource}
     * @memberof CredentialPolicy
     */
    CredentialPolicy.prototype.signRequest = function (request) {
        // Child classes must override this method with request signing. This method
        // will be executed in sendRequest().
        return request;
    };
    return CredentialPolicy;
}(coreHttp.BaseRequestPolicy));

// Copyright (c) Microsoft Corporation. All rights reserved.
/**
 * AnonymousCredentialPolicy is used with HTTP(S) requests that read public resources
 * or for use with Shared Access Signatures (SAS).
 *
 * @export
 * @class AnonymousCredentialPolicy
 * @extends {CredentialPolicy}
 */
var AnonymousCredentialPolicy = /** @class */ (function (_super) {
    tslib.__extends(AnonymousCredentialPolicy, _super);
    /**
     * Creates an instance of AnonymousCredentialPolicy.
     * @param {RequestPolicy} nextPolicy
     * @param {RequestPolicyOptions} options
     * @memberof AnonymousCredentialPolicy
     */
    function AnonymousCredentialPolicy(nextPolicy, options) {
        return _super.call(this, nextPolicy, options) || this;
    }
    return AnonymousCredentialPolicy;
}(CredentialPolicy));

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
/**
 * Credential is an abstract class for Azure Storage HTTP requests signing. This
 * class will host an credentialPolicyCreator factory which generates CredentialPolicy.
 *
 * @export
 * @abstract
 * @class Credential
 */
var Credential = /** @class */ (function () {
    function Credential() {
    }
    /**
     * Creates a RequestPolicy object.
     *
     * @param {RequestPolicy} _nextPolicy
     * @param {RequestPolicyOptions} _options
     * @returns {RequestPolicy}
     * @memberof Credential
     */
    Credential.prototype.create = function (
    // tslint:disable-next-line:variable-name
    _nextPolicy, 
    // tslint:disable-next-line:variable-name
    _options) {
        throw new Error("Method should be implemented in children classes.");
    };
    return Credential;
}());

// Copyright (c) Microsoft Corporation. All rights reserved.
/**
 * AnonymousCredential provides a credentialPolicyCreator member used to create
 * AnonymousCredentialPolicy objects. AnonymousCredentialPolicy is used with
 * HTTP(S) requests that read public resources or for use with Shared Access
 * Signatures (SAS).
 *
 * @export
 * @class AnonymousCredential
 * @extends {Credential}
 */
var AnonymousCredential = /** @class */ (function (_super) {
    tslib.__extends(AnonymousCredential, _super);
    function AnonymousCredential() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Creates an {@link AnonymousCredentialPolicy} object.
     *
     * @param {RequestPolicy} nextPolicy
     * @param {RequestPolicyOptions} options
     * @returns {AnonymousCredentialPolicy}
     * @memberof AnonymousCredential
     */
    AnonymousCredential.prototype.create = function (nextPolicy, options) {
        return new AnonymousCredentialPolicy(nextPolicy, options);
    };
    return AnonymousCredential;
}(Credential));

function unwrapExports (x) {
	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
}

function createCommonjsModule(fn, module) {
	return module = { exports: {} }, fn(module, module.exports), module.exports;
}

var EntryValue = createCommonjsModule(function (module, exports) {
/*!
 * Copyright 2019, OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * EntryTtl is an integer that represents number of hops an entry can propagate.
 *
 * For now, ONLY special values (0 and -1) are supported.
 */
var EntryTtl;
(function (EntryTtl) {
    /**
     * NO_PROPAGATION is considered to have local scope and is used within the
     * process it created.
     */
    EntryTtl[EntryTtl["NO_PROPAGATION"] = 0] = "NO_PROPAGATION";
    /** UNLIMITED_PROPAGATION can propagate unlimited hops. */
    EntryTtl[EntryTtl["UNLIMITED_PROPAGATION"] = -1] = "UNLIMITED_PROPAGATION";
})(EntryTtl = exports.EntryTtl || (exports.EntryTtl = {}));

});

unwrapExports(EntryValue);
var EntryValue_1 = EntryValue.EntryTtl;

var Metric = createCommonjsModule(function (module, exports) {
/*!
 * Copyright 2019, OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
/** The Type of value. It describes how the data is reported. */
var ValueType;
(function (ValueType) {
    ValueType[ValueType["INT"] = 0] = "INT";
    ValueType[ValueType["DOUBLE"] = 1] = "DOUBLE";
})(ValueType = exports.ValueType || (exports.ValueType = {}));

});

unwrapExports(Metric);
var Metric_1 = Metric.ValueType;

var span_kind = createCommonjsModule(function (module, exports) {
/*!
 * Copyright 2019, OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Type of span. Can be used to specify additional relationships between spans
 * in addition to a parent/child relationship.
 */
var SpanKind;
(function (SpanKind) {
    /** Default value. Indicates that the span is used internally. */
    SpanKind[SpanKind["INTERNAL"] = 0] = "INTERNAL";
    /**
     * Indicates that the span covers server-side handling of an RPC or other
     * remote request.
     */
    SpanKind[SpanKind["SERVER"] = 1] = "SERVER";
    /**
     * Indicates that the span covers the client-side wrapper around an RPC or
     * other remote request.
     */
    SpanKind[SpanKind["CLIENT"] = 2] = "CLIENT";
    /**
     * Indicates that the span describes producer sending a message to a
     * broker. Unlike client and server, there is no direct critical path latency
     * relationship between producer and consumer spans.
     */
    SpanKind[SpanKind["PRODUCER"] = 3] = "PRODUCER";
    /**
     * Indicates that the span describes consumer receiving a message from a
     * broker. Unlike client and server, there is no direct critical path latency
     * relationship between producer and consumer spans.
     */
    SpanKind[SpanKind["CONSUMER"] = 4] = "CONSUMER";
})(SpanKind = exports.SpanKind || (exports.SpanKind = {}));

});

unwrapExports(span_kind);
var span_kind_1 = span_kind.SpanKind;

var status = createCommonjsModule(function (module, exports) {
/*!
 * Copyright 2019, OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * An enumeration of canonical status codes.
 */
var CanonicalCode;
(function (CanonicalCode) {
    /**
     * Not an error; returned on success
     */
    CanonicalCode[CanonicalCode["OK"] = 0] = "OK";
    /**
     * The operation was cancelled (typically by the caller).
     */
    CanonicalCode[CanonicalCode["CANCELLED"] = 1] = "CANCELLED";
    /**
     * Unknown error.  An example of where this error may be returned is
     * if a status value received from another address space belongs to
     * an error-space that is not known in this address space.  Also
     * errors raised by APIs that do not return enough error information
     * may be converted to this error.
     */
    CanonicalCode[CanonicalCode["UNKNOWN"] = 2] = "UNKNOWN";
    /**
     * Client specified an invalid argument.  Note that this differs
     * from FAILED_PRECONDITION.  INVALID_ARGUMENT indicates arguments
     * that are problematic regardless of the state of the system
     * (e.g., a malformed file name).
     */
    CanonicalCode[CanonicalCode["INVALID_ARGUMENT"] = 3] = "INVALID_ARGUMENT";
    /**
     * Deadline expired before operation could complete.  For operations
     * that change the state of the system, this error may be returned
     * even if the operation has completed successfully.  For example, a
     * successful response from a server could have been delayed long
     * enough for the deadline to expire.
     */
    CanonicalCode[CanonicalCode["DEADLINE_EXCEEDED"] = 4] = "DEADLINE_EXCEEDED";
    /**
     * Some requested entity (e.g., file or directory) was not found.
     */
    CanonicalCode[CanonicalCode["NOT_FOUND"] = 5] = "NOT_FOUND";
    /**
     * Some entity that we attempted to create (e.g., file or directory)
     * already exists.
     */
    CanonicalCode[CanonicalCode["ALREADY_EXISTS"] = 6] = "ALREADY_EXISTS";
    /**
     * The caller does not have permission to execute the specified
     * operation.  PERMISSION_DENIED must not be used for rejections
     * caused by exhausting some resource (use RESOURCE_EXHAUSTED
     * instead for those errors).  PERMISSION_DENIED must not be
     * used if the caller can not be identified (use UNAUTHENTICATED
     * instead for those errors).
     */
    CanonicalCode[CanonicalCode["PERMISSION_DENIED"] = 7] = "PERMISSION_DENIED";
    /**
     * Some resource has been exhausted, perhaps a per-user quota, or
     * perhaps the entire file system is out of space.
     */
    CanonicalCode[CanonicalCode["RESOURCE_EXHAUSTED"] = 8] = "RESOURCE_EXHAUSTED";
    /**
     * Operation was rejected because the system is not in a state
     * required for the operation's execution.  For example, directory
     * to be deleted may be non-empty, an rmdir operation is applied to
     * a non-directory, etc.
     *
     * A litmus test that may help a service implementor in deciding
     * between FAILED_PRECONDITION, ABORTED, and UNAVAILABLE:
     *
     *  - Use UNAVAILABLE if the client can retry just the failing call.
     *  - Use ABORTED if the client should retry at a higher-level
     *    (e.g., restarting a read-modify-write sequence).
     *  - Use FAILED_PRECONDITION if the client should not retry until
     *    the system state has been explicitly fixed.  E.g., if an "rmdir"
     *    fails because the directory is non-empty, FAILED_PRECONDITION
     *    should be returned since the client should not retry unless
     *    they have first fixed up the directory by deleting files from it.
     *  - Use FAILED_PRECONDITION if the client performs conditional
     *    REST Get/Update/Delete on a resource and the resource on the
     *    server does not match the condition. E.g., conflicting
     *    read-modify-write on the same resource.
     */
    CanonicalCode[CanonicalCode["FAILED_PRECONDITION"] = 9] = "FAILED_PRECONDITION";
    /**
     * The operation was aborted, typically due to a concurrency issue
     * like sequencer check failures, transaction aborts, etc.
     *
     * See litmus test above for deciding between FAILED_PRECONDITION,
     * ABORTED, and UNAVAILABLE.
     */
    CanonicalCode[CanonicalCode["ABORTED"] = 10] = "ABORTED";
    /**
     * Operation was attempted past the valid range.  E.g., seeking or
     * reading past end of file.
     *
     * Unlike INVALID_ARGUMENT, this error indicates a problem that may
     * be fixed if the system state changes. For example, a 32-bit file
     * system will generate INVALID_ARGUMENT if asked to read at an
     * offset that is not in the range [0,2^32-1], but it will generate
     * OUT_OF_RANGE if asked to read from an offset past the current
     * file size.
     *
     * There is a fair bit of overlap between FAILED_PRECONDITION and
     * OUT_OF_RANGE.  We recommend using OUT_OF_RANGE (the more specific
     * error) when it applies so that callers who are iterating through
     * a space can easily look for an OUT_OF_RANGE error to detect when
     * they are done.
     */
    CanonicalCode[CanonicalCode["OUT_OF_RANGE"] = 11] = "OUT_OF_RANGE";
    /**
     * Operation is not implemented or not supported/enabled in this service.
     */
    CanonicalCode[CanonicalCode["UNIMPLEMENTED"] = 12] = "UNIMPLEMENTED";
    /**
     * Internal errors.  Means some invariants expected by underlying
     * system has been broken.  If you see one of these errors,
     * something is very broken.
     */
    CanonicalCode[CanonicalCode["INTERNAL"] = 13] = "INTERNAL";
    /**
     * The service is currently unavailable.  This is a most likely a
     * transient condition and may be corrected by retrying with
     * a backoff.
     *
     * See litmus test above for deciding between FAILED_PRECONDITION,
     * ABORTED, and UNAVAILABLE.
     */
    CanonicalCode[CanonicalCode["UNAVAILABLE"] = 14] = "UNAVAILABLE";
    /**
     * Unrecoverable data loss or corruption.
     */
    CanonicalCode[CanonicalCode["DATA_LOSS"] = 15] = "DATA_LOSS";
    /**
     * The request does not have valid authentication credentials for the
     * operation.
     */
    CanonicalCode[CanonicalCode["UNAUTHENTICATED"] = 16] = "UNAUTHENTICATED";
})(CanonicalCode = exports.CanonicalCode || (exports.CanonicalCode = {}));

});

unwrapExports(status);
var status_1 = status.CanonicalCode;

var trace_flags = createCommonjsModule(function (module, exports) {
/*!
 * Copyright 2019, OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * An enumeration that represents global trace flags. These flags are
 * propagated to all child {@link Span}. These determine features such as
 * whether a Span should be traced. It is implemented as a bitmask.
 */
var TraceFlags;
(function (TraceFlags) {
    /** Bit to represent whether trace is unsampled in trace flags. */
    TraceFlags[TraceFlags["UNSAMPLED"] = 0] = "UNSAMPLED";
    /** Bit to represent whether trace is sampled in trace flags. */
    TraceFlags[TraceFlags["SAMPLED"] = 1] = "SAMPLED";
})(TraceFlags = exports.TraceFlags || (exports.TraceFlags = {}));

});

unwrapExports(trace_flags);
var trace_flags_1 = trace_flags.TraceFlags;

var src = createCommonjsModule(function (module, exports) {
/*!
 * Copyright 2019, OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(EntryValue);
__export(Metric);
__export(span_kind);
__export(status);
__export(trace_flags);

});

unwrapExports(src);
var src_1 = src.CanonicalCode;
var src_2 = src.SpanKind;
var src_3 = src.TraceFlags;

/**
 * Creates a span using the global tracer.
 * @param name The name of the operation being performed.
 * @param tracingOptions The options for the underlying http request.
 */
function createSpan(operationName, tracingOptions) {
    if (tracingOptions === void 0) { tracingOptions = {}; }
    var tracer = coreTracing.getTracer();
    var spanOptions = tslib.__assign(tslib.__assign({}, tracingOptions.spanOptions), { kind: src_2.INTERNAL });
    var span = tracer.startSpan("Azure.Storage.DataLake." + operationName, spanOptions);
    span.setAttribute("az.namespace", "Microsoft.Storage");
    var newOptions = tracingOptions.spanOptions || {};
    if (span.isRecording()) {
        newOptions = tslib.__assign(tslib.__assign({}, tracingOptions.spanOptions), { parent: span, attributes: tslib.__assign(tslib.__assign({}, spanOptions.attributes), { "az.namespace": "Microsoft.Storage" }) });
    }
    return {
        span: span,
        spanOptions: newOptions
    };
}

var DataLakeLeaseClient = /** @class */ (function () {
    function DataLakeLeaseClient(client) {
        this.client = client;
    }
    Object.defineProperty(DataLakeLeaseClient.prototype, "leaseId", {
        get: function () {
            return this.client.leaseId;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DataLakeLeaseClient.prototype, "url", {
        get: function () {
            return this.client.url;
        },
        enumerable: true,
        configurable: true
    });
    DataLakeLeaseClient.prototype.acquireLease = function (duration, options) {
        if (options === void 0) { options = {}; }
        return tslib.__awaiter(this, void 0, void 0, function () {
            var _a, span, spanOptions, e_1;
            return tslib.__generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        options.conditions = options.conditions || {};
                        _a = createSpan("DataLakeLeaseClient-acquireLease", options.tracingOptions), span = _a.span, spanOptions = _a.spanOptions;
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 3, 4, 5]);
                        return [4 /*yield*/, this.client.acquireLease(duration, tslib.__assign(tslib.__assign({}, options), { tracingOptions: tslib.__assign(tslib.__assign({}, options.tracingOptions), { spanOptions: spanOptions }) }))];
                    case 2: return [2 /*return*/, _b.sent()];
                    case 3:
                        e_1 = _b.sent();
                        span.setStatus({
                            code: src_1.UNKNOWN,
                            message: e_1.message
                        });
                        throw e_1;
                    case 4:
                        span.end();
                        return [7 /*endfinally*/];
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    DataLakeLeaseClient.prototype.changeLease = function (proposedLeaseId, options) {
        if (options === void 0) { options = {}; }
        return tslib.__awaiter(this, void 0, void 0, function () {
            var _a, span, spanOptions, e_2;
            return tslib.__generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        options.conditions = options.conditions || {};
                        _a = createSpan("DataLakeLeaseClient-changeLease", options.tracingOptions), span = _a.span, spanOptions = _a.spanOptions;
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 3, 4, 5]);
                        return [4 /*yield*/, this.client.changeLease(proposedLeaseId, tslib.__assign(tslib.__assign({}, options), { tracingOptions: tslib.__assign(tslib.__assign({}, options.tracingOptions), { spanOptions: spanOptions }) }))];
                    case 2: return [2 /*return*/, _b.sent()];
                    case 3:
                        e_2 = _b.sent();
                        span.setStatus({
                            code: src_1.UNKNOWN,
                            message: e_2.message
                        });
                        throw e_2;
                    case 4:
                        span.end();
                        return [7 /*endfinally*/];
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    DataLakeLeaseClient.prototype.releaseLease = function (options) {
        if (options === void 0) { options = {}; }
        return tslib.__awaiter(this, void 0, void 0, function () {
            var _a, span, spanOptions, e_3;
            return tslib.__generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        options.conditions = options.conditions || {};
                        _a = createSpan("DataLakeLeaseClient-releaseLease", options.tracingOptions), span = _a.span, spanOptions = _a.spanOptions;
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 3, 4, 5]);
                        return [4 /*yield*/, this.client.releaseLease(tslib.__assign(tslib.__assign({}, options), { tracingOptions: tslib.__assign(tslib.__assign({}, options.tracingOptions), { spanOptions: spanOptions }) }))];
                    case 2: return [2 /*return*/, _b.sent()];
                    case 3:
                        e_3 = _b.sent();
                        span.setStatus({
                            code: src_1.UNKNOWN,
                            message: e_3.message
                        });
                        throw e_3;
                    case 4:
                        span.end();
                        return [7 /*endfinally*/];
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    DataLakeLeaseClient.prototype.renewLease = function (options) {
        if (options === void 0) { options = {}; }
        return tslib.__awaiter(this, void 0, void 0, function () {
            var _a, span, spanOptions, e_4;
            return tslib.__generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        options.conditions = options.conditions || {};
                        _a = createSpan("DataLakeLeaseClient-renewLease", options.tracingOptions), span = _a.span, spanOptions = _a.spanOptions;
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 3, 4, 5]);
                        return [4 /*yield*/, this.client.renewLease(tslib.__assign(tslib.__assign({}, options), { tracingOptions: tslib.__assign(tslib.__assign({}, options.tracingOptions), { spanOptions: spanOptions }) }))];
                    case 2: return [2 /*return*/, _b.sent()];
                    case 3:
                        e_4 = _b.sent();
                        span.setStatus({
                            code: src_1.UNKNOWN,
                            message: e_4.message
                        });
                        throw e_4;
                    case 4:
                        span.end();
                        return [7 /*endfinally*/];
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    DataLakeLeaseClient.prototype.breakLease = function (breakPeriod, options) {
        if (options === void 0) { options = {}; }
        return tslib.__awaiter(this, void 0, void 0, function () {
            var _a, span, spanOptions, e_5;
            return tslib.__generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        options.conditions = options.conditions || {};
                        _a = createSpan("DataLakeLeaseClient-renewLease", options.tracingOptions), span = _a.span, spanOptions = _a.spanOptions;
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 3, 4, 5]);
                        return [4 /*yield*/, this.client.breakLease(breakPeriod, tslib.__assign(tslib.__assign({}, options), { tracingOptions: tslib.__assign(tslib.__assign({}, options.tracingOptions), { spanOptions: spanOptions }) }))];
                    case 2: return [2 /*return*/, _b.sent()];
                    case 3:
                        e_5 = _b.sent();
                        span.setStatus({
                            code: src_1.UNKNOWN,
                            message: e_5.message
                        });
                        throw e_5;
                    case 4:
                        span.end();
                        return [7 /*endfinally*/];
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    return DataLakeLeaseClient;
}());

/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
var Path = {
    serializedName: "Path",
    type: {
        name: "Composite",
        className: "Path",
        modelProperties: {
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            isDirectory: {
                serializedName: "isDirectory",
                defaultValue: false,
                type: {
                    name: "Boolean"
                }
            },
            lastModified: {
                serializedName: "lastModified",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            eTag: {
                serializedName: "eTag",
                type: {
                    name: "String"
                }
            },
            contentLength: {
                serializedName: "contentLength",
                type: {
                    name: "Number"
                }
            },
            owner: {
                serializedName: "owner",
                type: {
                    name: "String"
                }
            },
            group: {
                serializedName: "group",
                type: {
                    name: "String"
                }
            },
            permissions: {
                serializedName: "permissions",
                type: {
                    name: "String"
                }
            }
        }
    }
};
var PathList = {
    serializedName: "PathList",
    type: {
        name: "Composite",
        className: "PathList",
        modelProperties: {
            paths: {
                serializedName: "paths",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Path"
                        }
                    }
                }
            }
        }
    }
};
var StorageErrorError = {
    serializedName: "StorageError_error",
    type: {
        name: "Composite",
        className: "StorageErrorError",
        modelProperties: {
            code: {
                serializedName: "Code",
                type: {
                    name: "String"
                }
            },
            message: {
                serializedName: "Message",
                type: {
                    name: "String"
                }
            }
        }
    }
};
var StorageError = {
    serializedName: "StorageError",
    type: {
        name: "Composite",
        className: "StorageError",
        modelProperties: {
            error: {
                serializedName: "error",
                type: {
                    name: "Composite",
                    className: "StorageErrorError"
                }
            }
        }
    }
};
var FileSystemCreateHeaders = {
    serializedName: "filesystem-create-headers",
    type: {
        name: "Composite",
        className: "FileSystemCreateHeaders",
        modelProperties: {
            date: {
                serializedName: "date",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            eTag: {
                serializedName: "etag",
                type: {
                    name: "String"
                }
            },
            lastModified: {
                serializedName: "last-modified",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            clientRequestId: {
                serializedName: "x-ms-request-id",
                type: {
                    name: "String"
                }
            },
            version: {
                serializedName: "x-ms-version",
                type: {
                    name: "String"
                }
            },
            namespaceEnabled: {
                serializedName: "x-ms-namespace-enabled",
                type: {
                    name: "String"
                }
            },
            errorCode: {
                serializedName: "x-ms-error-code",
                type: {
                    name: "String"
                }
            }
        }
    }
};
var FileSystemSetPropertiesHeaders = {
    serializedName: "filesystem-setproperties-headers",
    type: {
        name: "Composite",
        className: "FileSystemSetPropertiesHeaders",
        modelProperties: {
            date: {
                serializedName: "date",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            eTag: {
                serializedName: "etag",
                type: {
                    name: "String"
                }
            },
            lastModified: {
                serializedName: "last-modified",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            requestId: {
                serializedName: "x-ms-request-id",
                type: {
                    name: "String"
                }
            },
            version: {
                serializedName: "x-ms-version",
                type: {
                    name: "String"
                }
            },
            errorCode: {
                serializedName: "x-ms-error-code",
                type: {
                    name: "String"
                }
            }
        }
    }
};
var FileSystemGetPropertiesHeaders = {
    serializedName: "filesystem-getproperties-headers",
    type: {
        name: "Composite",
        className: "FileSystemGetPropertiesHeaders",
        modelProperties: {
            date: {
                serializedName: "date",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            eTag: {
                serializedName: "etag",
                type: {
                    name: "String"
                }
            },
            lastModified: {
                serializedName: "last-modified",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            requestId: {
                serializedName: "x-ms-request-id",
                type: {
                    name: "String"
                }
            },
            version: {
                serializedName: "x-ms-version",
                type: {
                    name: "String"
                }
            },
            properties: {
                serializedName: "x-ms-properties",
                type: {
                    name: "String"
                }
            },
            namespaceEnabled: {
                serializedName: "x-ms-namespace-enabled",
                type: {
                    name: "String"
                }
            },
            errorCode: {
                serializedName: "x-ms-error-code",
                type: {
                    name: "String"
                }
            }
        }
    }
};
var FileSystemDeleteHeaders = {
    serializedName: "filesystem-delete-headers",
    type: {
        name: "Composite",
        className: "FileSystemDeleteHeaders",
        modelProperties: {
            requestId: {
                serializedName: "x-ms-request-id",
                type: {
                    name: "String"
                }
            },
            version: {
                serializedName: "x-ms-version",
                type: {
                    name: "String"
                }
            },
            date: {
                serializedName: "date",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            errorCode: {
                serializedName: "x-ms-error-code",
                type: {
                    name: "String"
                }
            }
        }
    }
};
var FileSystemListPathsHeaders = {
    serializedName: "filesystem-listpaths-headers",
    type: {
        name: "Composite",
        className: "FileSystemListPathsHeaders",
        modelProperties: {
            date: {
                serializedName: "date",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            eTag: {
                serializedName: "etag",
                type: {
                    name: "String"
                }
            },
            lastModified: {
                serializedName: "last-modified",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            requestId: {
                serializedName: "x-ms-request-id",
                type: {
                    name: "String"
                }
            },
            version: {
                serializedName: "x-ms-version",
                type: {
                    name: "String"
                }
            },
            continuation: {
                serializedName: "x-ms-continuation",
                type: {
                    name: "String"
                }
            },
            errorCode: {
                serializedName: "x-ms-error-code",
                type: {
                    name: "String"
                }
            }
        }
    }
};
var PathCreateHeaders = {
    serializedName: "path-create-headers",
    type: {
        name: "Composite",
        className: "PathCreateHeaders",
        modelProperties: {
            date: {
                serializedName: "date",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            eTag: {
                serializedName: "etag",
                type: {
                    name: "String"
                }
            },
            lastModified: {
                serializedName: "last-modified",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            requestId: {
                serializedName: "x-ms-request-id",
                type: {
                    name: "String"
                }
            },
            version: {
                serializedName: "x-ms-version",
                type: {
                    name: "String"
                }
            },
            continuation: {
                serializedName: "x-ms-continuation",
                type: {
                    name: "String"
                }
            },
            contentLength: {
                serializedName: "content-length",
                type: {
                    name: "Number"
                }
            },
            errorCode: {
                serializedName: "x-ms-error-code",
                type: {
                    name: "String"
                }
            }
        }
    }
};
var PathUpdateHeaders = {
    serializedName: "path-update-headers",
    type: {
        name: "Composite",
        className: "PathUpdateHeaders",
        modelProperties: {
            date: {
                serializedName: "date",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            eTag: {
                serializedName: "etag",
                type: {
                    name: "String"
                }
            },
            lastModified: {
                serializedName: "last-modified",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            acceptRanges: {
                serializedName: "accept-ranges",
                type: {
                    name: "String"
                }
            },
            cacheControl: {
                serializedName: "cache-control",
                type: {
                    name: "String"
                }
            },
            contentDisposition: {
                serializedName: "content-disposition",
                type: {
                    name: "String"
                }
            },
            contentEncoding: {
                serializedName: "content-encoding",
                type: {
                    name: "String"
                }
            },
            contentLanguage: {
                serializedName: "content-language",
                type: {
                    name: "String"
                }
            },
            contentLength: {
                serializedName: "content-length",
                type: {
                    name: "Number"
                }
            },
            contentRange: {
                serializedName: "content-range",
                type: {
                    name: "String"
                }
            },
            contentType: {
                serializedName: "content-type",
                type: {
                    name: "String"
                }
            },
            contentMD5: {
                serializedName: "content-md5",
                type: {
                    name: "String"
                }
            },
            properties: {
                serializedName: "x-ms-properties",
                type: {
                    name: "String"
                }
            },
            requestId: {
                serializedName: "x-ms-request-id",
                type: {
                    name: "String"
                }
            },
            version: {
                serializedName: "x-ms-version",
                type: {
                    name: "String"
                }
            },
            errorCode: {
                serializedName: "x-ms-error-code",
                type: {
                    name: "String"
                }
            }
        }
    }
};
var PathLeaseHeaders = {
    serializedName: "path-lease-headers",
    type: {
        name: "Composite",
        className: "PathLeaseHeaders",
        modelProperties: {
            date: {
                serializedName: "date",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            eTag: {
                serializedName: "etag",
                type: {
                    name: "String"
                }
            },
            lastModified: {
                serializedName: "last-modified",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            requestId: {
                serializedName: "x-ms-request-id",
                type: {
                    name: "String"
                }
            },
            version: {
                serializedName: "x-ms-version",
                type: {
                    name: "String"
                }
            },
            leaseId: {
                serializedName: "x-ms-lease-id",
                type: {
                    name: "String"
                }
            },
            leaseTime: {
                serializedName: "x-ms-lease-time",
                type: {
                    name: "String"
                }
            },
            errorCode: {
                serializedName: "x-ms-error-code",
                type: {
                    name: "String"
                }
            }
        }
    }
};
var PathReadHeaders = {
    serializedName: "path-read-headers",
    type: {
        name: "Composite",
        className: "PathReadHeaders",
        modelProperties: {
            acceptRanges: {
                serializedName: "accept-ranges",
                type: {
                    name: "String"
                }
            },
            cacheControl: {
                serializedName: "cache-control",
                type: {
                    name: "String"
                }
            },
            contentDisposition: {
                serializedName: "content-disposition",
                type: {
                    name: "String"
                }
            },
            contentEncoding: {
                serializedName: "content-encoding",
                type: {
                    name: "String"
                }
            },
            contentLanguage: {
                serializedName: "content-language",
                type: {
                    name: "String"
                }
            },
            contentLength: {
                serializedName: "content-length",
                type: {
                    name: "Number"
                }
            },
            contentRange: {
                serializedName: "content-range",
                type: {
                    name: "String"
                }
            },
            contentType: {
                serializedName: "content-type",
                type: {
                    name: "String"
                }
            },
            contentMD5: {
                serializedName: "content-md5",
                type: {
                    name: "String"
                }
            },
            date: {
                serializedName: "date",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            eTag: {
                serializedName: "etag",
                type: {
                    name: "String"
                }
            },
            lastModified: {
                serializedName: "last-modified",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            requestId: {
                serializedName: "x-ms-request-id",
                type: {
                    name: "String"
                }
            },
            version: {
                serializedName: "x-ms-version",
                type: {
                    name: "String"
                }
            },
            resourceType: {
                serializedName: "x-ms-resource-type",
                type: {
                    name: "String"
                }
            },
            properties: {
                serializedName: "x-ms-properties",
                type: {
                    name: "String"
                }
            },
            leaseDuration: {
                serializedName: "x-ms-lease-duration",
                type: {
                    name: "String"
                }
            },
            leaseState: {
                serializedName: "x-ms-lease-state",
                type: {
                    name: "String"
                }
            },
            leaseStatus: {
                serializedName: "x-ms-lease-status",
                type: {
                    name: "String"
                }
            },
            xMsContentMd5: {
                serializedName: "x-ms-content-md5",
                type: {
                    name: "String"
                }
            },
            errorCode: {
                serializedName: "x-ms-error-code",
                type: {
                    name: "String"
                }
            }
        }
    }
};
var PathGetPropertiesHeaders = {
    serializedName: "path-getproperties-headers",
    type: {
        name: "Composite",
        className: "PathGetPropertiesHeaders",
        modelProperties: {
            acceptRanges: {
                serializedName: "accept-ranges",
                type: {
                    name: "String"
                }
            },
            cacheControl: {
                serializedName: "cache-control",
                type: {
                    name: "String"
                }
            },
            contentDisposition: {
                serializedName: "content-disposition",
                type: {
                    name: "String"
                }
            },
            contentEncoding: {
                serializedName: "content-encoding",
                type: {
                    name: "String"
                }
            },
            contentLanguage: {
                serializedName: "content-language",
                type: {
                    name: "String"
                }
            },
            contentLength: {
                serializedName: "content-length",
                type: {
                    name: "Number"
                }
            },
            contentRange: {
                serializedName: "content-range",
                type: {
                    name: "String"
                }
            },
            contentType: {
                serializedName: "content-type",
                type: {
                    name: "String"
                }
            },
            contentMD5: {
                serializedName: "content-md5",
                type: {
                    name: "String"
                }
            },
            date: {
                serializedName: "date",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            eTag: {
                serializedName: "etag",
                type: {
                    name: "String"
                }
            },
            lastModified: {
                serializedName: "last-modified",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            requestId: {
                serializedName: "x-ms-request-id",
                type: {
                    name: "String"
                }
            },
            version: {
                serializedName: "x-ms-version",
                type: {
                    name: "String"
                }
            },
            resourceType: {
                serializedName: "x-ms-resource-type",
                type: {
                    name: "String"
                }
            },
            properties: {
                serializedName: "x-ms-properties",
                type: {
                    name: "String"
                }
            },
            owner: {
                serializedName: "x-ms-owner",
                type: {
                    name: "String"
                }
            },
            group: {
                serializedName: "x-ms-group",
                type: {
                    name: "String"
                }
            },
            permissions: {
                serializedName: "x-ms-permissions",
                type: {
                    name: "String"
                }
            },
            acl: {
                serializedName: "x-ms-acl",
                type: {
                    name: "String"
                }
            },
            leaseDuration: {
                serializedName: "x-ms-lease-duration",
                type: {
                    name: "String"
                }
            },
            leaseState: {
                serializedName: "x-ms-lease-state",
                type: {
                    name: "String"
                }
            },
            leaseStatus: {
                serializedName: "x-ms-lease-status",
                type: {
                    name: "String"
                }
            },
            errorCode: {
                serializedName: "x-ms-error-code",
                type: {
                    name: "String"
                }
            }
        }
    }
};
var PathDeleteHeaders = {
    serializedName: "path-delete-headers",
    type: {
        name: "Composite",
        className: "PathDeleteHeaders",
        modelProperties: {
            date: {
                serializedName: "date",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            requestId: {
                serializedName: "x-ms-request-id",
                type: {
                    name: "String"
                }
            },
            version: {
                serializedName: "x-ms-version",
                type: {
                    name: "String"
                }
            },
            continuation: {
                serializedName: "x-ms-continuation",
                type: {
                    name: "String"
                }
            },
            errorCode: {
                serializedName: "x-ms-error-code",
                type: {
                    name: "String"
                }
            }
        }
    }
};
var PathSetAccessControlHeaders = {
    serializedName: "path-setaccesscontrol-headers",
    type: {
        name: "Composite",
        className: "PathSetAccessControlHeaders",
        modelProperties: {
            date: {
                serializedName: "date",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            eTag: {
                serializedName: "etag",
                type: {
                    name: "String"
                }
            },
            lastModified: {
                serializedName: "last-modified",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            clientRequestId: {
                serializedName: "x-ms-client-request-id",
                type: {
                    name: "String"
                }
            },
            requestId: {
                serializedName: "x-ms-request-id",
                type: {
                    name: "String"
                }
            },
            version: {
                serializedName: "x-ms-version",
                type: {
                    name: "String"
                }
            }
        }
    }
};
var PathFlushDataHeaders = {
    serializedName: "path-flushdata-headers",
    type: {
        name: "Composite",
        className: "PathFlushDataHeaders",
        modelProperties: {
            date: {
                serializedName: "date",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            eTag: {
                serializedName: "etag",
                type: {
                    name: "String"
                }
            },
            lastModified: {
                serializedName: "last-modified",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            contentLength: {
                serializedName: "content-length",
                type: {
                    name: "Number"
                }
            },
            clientRequestId: {
                serializedName: "x-ms-client-request-id",
                type: {
                    name: "String"
                }
            },
            requestId: {
                serializedName: "x-ms-request-id",
                type: {
                    name: "String"
                }
            },
            version: {
                serializedName: "x-ms-version",
                type: {
                    name: "String"
                }
            }
        }
    }
};
var PathAppendDataHeaders = {
    serializedName: "path-appenddata-headers",
    type: {
        name: "Composite",
        className: "PathAppendDataHeaders",
        modelProperties: {
            date: {
                serializedName: "date",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            requestId: {
                serializedName: "x-ms-request-id",
                type: {
                    name: "String"
                }
            },
            clientRequestId: {
                serializedName: "x-ms-client-request-id",
                type: {
                    name: "String"
                }
            },
            version: {
                serializedName: "x-ms-version",
                type: {
                    name: "String"
                }
            }
        }
    }
};

/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for
 * license information.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is
 * regenerated.
 */
var acl = {
    parameterPath: [
        "options",
        "acl"
    ],
    mapper: {
        serializedName: "x-ms-acl",
        type: {
            name: "String"
        }
    }
};
var action0 = {
    parameterPath: "action",
    mapper: {
        required: true,
        serializedName: "action",
        type: {
            name: "Enum",
            allowedValues: [
                "append",
                "flush",
                "setProperties",
                "setAccessControl"
            ]
        }
    }
};
var action1 = {
    parameterPath: [
        "options",
        "action"
    ],
    mapper: {
        serializedName: "action",
        type: {
            name: "Enum",
            allowedValues: [
                "getAccessControl",
                "getStatus"
            ]
        }
    }
};
var action2 = {
    parameterPath: "action",
    mapper: {
        required: true,
        isConstant: true,
        serializedName: "action",
        defaultValue: 'setAccessControl',
        type: {
            name: "String"
        }
    }
};
var action3 = {
    parameterPath: "action",
    mapper: {
        required: true,
        isConstant: true,
        serializedName: "action",
        defaultValue: 'flush',
        type: {
            name: "String"
        }
    }
};
var action4 = {
    parameterPath: "action",
    mapper: {
        required: true,
        isConstant: true,
        serializedName: "action",
        defaultValue: 'append',
        type: {
            name: "String"
        }
    }
};
var cacheControl = {
    parameterPath: [
        "options",
        "pathHttpHeaders",
        "cacheControl"
    ],
    mapper: {
        serializedName: "x-ms-cache-control",
        type: {
            name: "String"
        }
    }
};
var close = {
    parameterPath: [
        "options",
        "close"
    ],
    mapper: {
        serializedName: "close",
        type: {
            name: "Boolean"
        }
    }
};
var contentDisposition = {
    parameterPath: [
        "options",
        "pathHttpHeaders",
        "contentDisposition"
    ],
    mapper: {
        serializedName: "x-ms-content-disposition",
        type: {
            name: "String"
        }
    }
};
var contentEncoding = {
    parameterPath: [
        "options",
        "pathHttpHeaders",
        "contentEncoding"
    ],
    mapper: {
        serializedName: "x-ms-content-encoding",
        type: {
            name: "String"
        }
    }
};
var contentLanguage = {
    parameterPath: [
        "options",
        "pathHttpHeaders",
        "contentLanguage"
    ],
    mapper: {
        serializedName: "x-ms-content-language",
        type: {
            name: "String"
        }
    }
};
var contentLength = {
    parameterPath: [
        "options",
        "contentLength"
    ],
    mapper: {
        serializedName: "Content-Length",
        constraints: {
            InclusiveMinimum: 0
        },
        type: {
            name: "Number"
        }
    }
};
var contentMD5 = {
    parameterPath: [
        "options",
        "pathHttpHeaders",
        "contentMD5"
    ],
    mapper: {
        serializedName: "x-ms-content-md5",
        type: {
            name: "ByteArray"
        }
    }
};
var contentType = {
    parameterPath: [
        "options",
        "pathHttpHeaders",
        "contentType"
    ],
    mapper: {
        serializedName: "x-ms-content-type",
        type: {
            name: "String"
        }
    }
};
var continuation = {
    parameterPath: [
        "options",
        "continuation"
    ],
    mapper: {
        serializedName: "continuation",
        type: {
            name: "String"
        }
    }
};
var group = {
    parameterPath: [
        "options",
        "group"
    ],
    mapper: {
        serializedName: "x-ms-group",
        type: {
            name: "String"
        }
    }
};
var ifMatch = {
    parameterPath: [
        "options",
        "modifiedAccessConditions",
        "ifMatch"
    ],
    mapper: {
        serializedName: "If-Match",
        type: {
            name: "String"
        }
    }
};
var ifModifiedSince = {
    parameterPath: [
        "options",
        "modifiedAccessConditions",
        "ifModifiedSince"
    ],
    mapper: {
        serializedName: "If-Modified-Since",
        type: {
            name: "DateTimeRfc1123"
        }
    }
};
var ifNoneMatch = {
    parameterPath: [
        "options",
        "modifiedAccessConditions",
        "ifNoneMatch"
    ],
    mapper: {
        serializedName: "If-None-Match",
        type: {
            name: "String"
        }
    }
};
var ifUnmodifiedSince = {
    parameterPath: [
        "options",
        "modifiedAccessConditions",
        "ifUnmodifiedSince"
    ],
    mapper: {
        serializedName: "If-Unmodified-Since",
        type: {
            name: "DateTimeRfc1123"
        }
    }
};
var leaseId = {
    parameterPath: [
        "options",
        "leaseAccessConditions",
        "leaseId"
    ],
    mapper: {
        serializedName: "x-ms-lease-id",
        type: {
            name: "String"
        }
    }
};
var maxResults = {
    parameterPath: [
        "options",
        "maxResults"
    ],
    mapper: {
        serializedName: "maxResults",
        constraints: {
            InclusiveMinimum: 1
        },
        type: {
            name: "Number"
        }
    }
};
var mode = {
    parameterPath: [
        "options",
        "mode"
    ],
    mapper: {
        serializedName: "mode",
        type: {
            name: "Enum",
            allowedValues: [
                "legacy",
                "posix"
            ]
        }
    }
};
var owner = {
    parameterPath: [
        "options",
        "owner"
    ],
    mapper: {
        serializedName: "x-ms-owner",
        type: {
            name: "String"
        }
    }
};
var path = {
    parameterPath: [
        "options",
        "path"
    ],
    mapper: {
        serializedName: "directory",
        type: {
            name: "String"
        }
    }
};
var permissions = {
    parameterPath: [
        "options",
        "permissions"
    ],
    mapper: {
        serializedName: "x-ms-permissions",
        type: {
            name: "String"
        }
    }
};
var position = {
    parameterPath: [
        "options",
        "position"
    ],
    mapper: {
        serializedName: "position",
        type: {
            name: "Number"
        }
    }
};
var properties = {
    parameterPath: [
        "options",
        "properties"
    ],
    mapper: {
        serializedName: "x-ms-properties",
        type: {
            name: "String"
        }
    }
};
var proposedLeaseId = {
    parameterPath: [
        "options",
        "proposedLeaseId"
    ],
    mapper: {
        serializedName: "x-ms-proposed-lease-id",
        type: {
            name: "String"
        }
    }
};
var range = {
    parameterPath: [
        "options",
        "range"
    ],
    mapper: {
        serializedName: "Range",
        type: {
            name: "String"
        }
    }
};
var recursive0 = {
    parameterPath: "recursive",
    mapper: {
        required: true,
        serializedName: "recursive",
        type: {
            name: "Boolean"
        }
    }
};
var recursive1 = {
    parameterPath: [
        "options",
        "recursive"
    ],
    mapper: {
        serializedName: "recursive",
        type: {
            name: "Boolean"
        }
    }
};
var renameSource = {
    parameterPath: [
        "options",
        "renameSource"
    ],
    mapper: {
        serializedName: "x-ms-rename-source",
        type: {
            name: "String"
        }
    }
};
var requestId = {
    parameterPath: [
        "options",
        "requestId"
    ],
    mapper: {
        serializedName: "x-ms-client-request-id",
        type: {
            name: "String"
        }
    }
};
var resource1 = {
    parameterPath: "resource",
    mapper: {
        required: true,
        isConstant: true,
        serializedName: "resource",
        defaultValue: 'filesystem',
        type: {
            name: "String"
        }
    }
};
var resource2 = {
    parameterPath: [
        "options",
        "resource"
    ],
    mapper: {
        serializedName: "resource",
        type: {
            name: "Enum",
            allowedValues: [
                "directory",
                "file"
            ]
        }
    }
};
var retainUncommittedData = {
    parameterPath: [
        "options",
        "retainUncommittedData"
    ],
    mapper: {
        serializedName: "retainUncommittedData",
        type: {
            name: "Boolean"
        }
    }
};
var sourceIfMatch = {
    parameterPath: [
        "options",
        "sourceModifiedAccessConditions",
        "sourceIfMatch"
    ],
    mapper: {
        serializedName: "x-ms-source-if-match",
        type: {
            name: "String"
        }
    }
};
var sourceIfModifiedSince = {
    parameterPath: [
        "options",
        "sourceModifiedAccessConditions",
        "sourceIfModifiedSince"
    ],
    mapper: {
        serializedName: "x-ms-source-if-modified-since",
        type: {
            name: "DateTimeRfc1123"
        }
    }
};
var sourceIfNoneMatch = {
    parameterPath: [
        "options",
        "sourceModifiedAccessConditions",
        "sourceIfNoneMatch"
    ],
    mapper: {
        serializedName: "x-ms-source-if-none-match",
        type: {
            name: "String"
        }
    }
};
var sourceIfUnmodifiedSince = {
    parameterPath: [
        "options",
        "sourceModifiedAccessConditions",
        "sourceIfUnmodifiedSince"
    ],
    mapper: {
        serializedName: "x-ms-source-if-unmodified-since",
        type: {
            name: "DateTimeRfc1123"
        }
    }
};
var sourceLeaseId = {
    parameterPath: [
        "options",
        "sourceLeaseId"
    ],
    mapper: {
        serializedName: "x-ms-source-lease-id",
        type: {
            name: "String"
        }
    }
};
var timeout = {
    parameterPath: [
        "options",
        "timeout"
    ],
    mapper: {
        serializedName: "timeout",
        constraints: {
            InclusiveMinimum: 0
        },
        type: {
            name: "Number"
        }
    }
};
var transactionalContentHash = {
    parameterPath: [
        "options",
        "pathHttpHeaders",
        "transactionalContentHash"
    ],
    mapper: {
        serializedName: "Content-MD5",
        type: {
            name: "ByteArray"
        }
    }
};
var umask = {
    parameterPath: [
        "options",
        "umask"
    ],
    mapper: {
        serializedName: "x-ms-umask",
        type: {
            name: "String"
        }
    }
};
var upn = {
    parameterPath: [
        "options",
        "upn"
    ],
    mapper: {
        serializedName: "upn",
        type: {
            name: "Boolean"
        }
    }
};
var url = {
    parameterPath: "url",
    mapper: {
        required: true,
        serializedName: "url",
        defaultValue: '',
        type: {
            name: "String"
        }
    },
    skipEncoding: true
};
var version = {
    parameterPath: "version",
    mapper: {
        required: true,
        isConstant: true,
        serializedName: "x-ms-version",
        defaultValue: '2019-07-07',
        type: {
            name: "String"
        }
    }
};
var xMsLeaseAction = {
    parameterPath: "xMsLeaseAction",
    mapper: {
        required: true,
        serializedName: "x-ms-lease-action",
        type: {
            name: "Enum",
            allowedValues: [
                "acquire",
                "break",
                "change",
                "renew",
                "release"
            ]
        }
    }
};
var xMsLeaseBreakPeriod = {
    parameterPath: [
        "options",
        "xMsLeaseBreakPeriod"
    ],
    mapper: {
        serializedName: "x-ms-lease-break-period",
        type: {
            name: "Number"
        }
    }
};
var xMsLeaseDuration = {
    parameterPath: [
        "options",
        "xMsLeaseDuration"
    ],
    mapper: {
        serializedName: "x-ms-lease-duration",
        type: {
            name: "Number"
        }
    }
};
var xMsRangeGetContentMd5 = {
    parameterPath: [
        "options",
        "xMsRangeGetContentMd5"
    ],
    mapper: {
        serializedName: "x-ms-range-get-content-md5",
        type: {
            name: "Boolean"
        }
    }
};

/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */

var Mappers = /*#__PURE__*/Object.freeze({
    __proto__: null,
    FileSystemCreateHeaders: FileSystemCreateHeaders,
    FileSystemDeleteHeaders: FileSystemDeleteHeaders,
    FileSystemGetPropertiesHeaders: FileSystemGetPropertiesHeaders,
    FileSystemListPathsHeaders: FileSystemListPathsHeaders,
    FileSystemSetPropertiesHeaders: FileSystemSetPropertiesHeaders,
    Path: Path,
    PathList: PathList,
    StorageError: StorageError,
    StorageErrorError: StorageErrorError
});

/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for
 * license information.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is
 * regenerated.
 */
/** Class representing a FileSystemOperations. */
var FileSystemOperations = /** @class */ (function () {
    /**
     * Create a FileSystemOperations.
     * @param {StorageClientContext} client Reference to the service client.
     */
    function FileSystemOperations(client) {
        this.client = client;
    }
    FileSystemOperations.prototype.create = function (options, callback) {
        return this.client.sendOperationRequest({
            options: options
        }, createOperationSpec, callback);
    };
    FileSystemOperations.prototype.setProperties = function (options, callback) {
        return this.client.sendOperationRequest({
            options: options
        }, setPropertiesOperationSpec, callback);
    };
    FileSystemOperations.prototype.getProperties = function (options, callback) {
        return this.client.sendOperationRequest({
            options: options
        }, getPropertiesOperationSpec, callback);
    };
    FileSystemOperations.prototype.deleteMethod = function (options, callback) {
        return this.client.sendOperationRequest({
            options: options
        }, deleteMethodOperationSpec, callback);
    };
    FileSystemOperations.prototype.listPaths = function (recursive, options, callback) {
        return this.client.sendOperationRequest({
            recursive: recursive,
            options: options
        }, listPathsOperationSpec, callback);
    };
    return FileSystemOperations;
}());
// Operation Specifications
var serializer = new coreHttp.Serializer(Mappers);
var createOperationSpec = {
    httpMethod: "PUT",
    path: "{filesystem}",
    urlParameters: [
        url
    ],
    queryParameters: [
        resource1,
        timeout
    ],
    headerParameters: [
        properties,
        requestId,
        version
    ],
    responses: {
        201: {
            headersMapper: FileSystemCreateHeaders
        },
        default: {
            bodyMapper: StorageError,
            headersMapper: FileSystemCreateHeaders
        }
    },
    serializer: serializer
};
var setPropertiesOperationSpec = {
    httpMethod: "PATCH",
    path: "{filesystem}",
    urlParameters: [
        url
    ],
    queryParameters: [
        resource1,
        timeout
    ],
    headerParameters: [
        properties,
        requestId,
        version,
        ifModifiedSince,
        ifUnmodifiedSince
    ],
    responses: {
        200: {
            headersMapper: FileSystemSetPropertiesHeaders
        },
        default: {
            bodyMapper: StorageError,
            headersMapper: FileSystemSetPropertiesHeaders
        }
    },
    serializer: serializer
};
var getPropertiesOperationSpec = {
    httpMethod: "HEAD",
    path: "{filesystem}",
    urlParameters: [
        url
    ],
    queryParameters: [
        resource1,
        timeout
    ],
    headerParameters: [
        requestId,
        version
    ],
    responses: {
        200: {
            headersMapper: FileSystemGetPropertiesHeaders
        },
        default: {
            bodyMapper: StorageError,
            headersMapper: FileSystemGetPropertiesHeaders
        }
    },
    serializer: serializer
};
var deleteMethodOperationSpec = {
    httpMethod: "DELETE",
    path: "{filesystem}",
    urlParameters: [
        url
    ],
    queryParameters: [
        resource1,
        timeout
    ],
    headerParameters: [
        requestId,
        version,
        ifModifiedSince,
        ifUnmodifiedSince
    ],
    responses: {
        202: {
            headersMapper: FileSystemDeleteHeaders
        },
        default: {
            bodyMapper: StorageError,
            headersMapper: FileSystemDeleteHeaders
        }
    },
    serializer: serializer
};
var listPathsOperationSpec = {
    httpMethod: "GET",
    path: "{filesystem}",
    urlParameters: [
        url
    ],
    queryParameters: [
        continuation,
        path,
        recursive0,
        maxResults,
        upn,
        resource1,
        timeout
    ],
    headerParameters: [
        requestId,
        version
    ],
    responses: {
        200: {
            bodyMapper: PathList,
            headersMapper: FileSystemListPathsHeaders
        },
        default: {
            bodyMapper: StorageError,
            headersMapper: FileSystemListPathsHeaders
        }
    },
    serializer: serializer
};

/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */

var Mappers$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    PathAppendDataHeaders: PathAppendDataHeaders,
    PathCreateHeaders: PathCreateHeaders,
    PathDeleteHeaders: PathDeleteHeaders,
    PathFlushDataHeaders: PathFlushDataHeaders,
    PathGetPropertiesHeaders: PathGetPropertiesHeaders,
    PathLeaseHeaders: PathLeaseHeaders,
    PathReadHeaders: PathReadHeaders,
    PathSetAccessControlHeaders: PathSetAccessControlHeaders,
    PathUpdateHeaders: PathUpdateHeaders,
    StorageError: StorageError,
    StorageErrorError: StorageErrorError
});

/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for
 * license information.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is
 * regenerated.
 */
/** Class representing a PathOperations. */
var PathOperations = /** @class */ (function () {
    /**
     * Create a PathOperations.
     * @param {StorageClientContext} client Reference to the service client.
     */
    function PathOperations(client) {
        this.client = client;
    }
    PathOperations.prototype.create = function (options, callback) {
        return this.client.sendOperationRequest({
            options: options
        }, createOperationSpec$1, callback);
    };
    PathOperations.prototype.update = function (action, body, options, callback) {
        return this.client.sendOperationRequest({
            action: action,
            body: body,
            options: options
        }, updateOperationSpec, callback);
    };
    PathOperations.prototype.lease = function (xMsLeaseAction, options, callback) {
        return this.client.sendOperationRequest({
            xMsLeaseAction: xMsLeaseAction,
            options: options
        }, leaseOperationSpec, callback);
    };
    PathOperations.prototype.read = function (options, callback) {
        return this.client.sendOperationRequest({
            options: options
        }, readOperationSpec, callback);
    };
    PathOperations.prototype.getProperties = function (options, callback) {
        return this.client.sendOperationRequest({
            options: options
        }, getPropertiesOperationSpec$1, callback);
    };
    PathOperations.prototype.deleteMethod = function (options, callback) {
        return this.client.sendOperationRequest({
            options: options
        }, deleteMethodOperationSpec$1, callback);
    };
    PathOperations.prototype.setAccessControl = function (options, callback) {
        return this.client.sendOperationRequest({
            options: options
        }, setAccessControlOperationSpec, callback);
    };
    PathOperations.prototype.flushData = function (options, callback) {
        return this.client.sendOperationRequest({
            options: options
        }, flushDataOperationSpec, callback);
    };
    PathOperations.prototype.appendData = function (body, options, callback) {
        return this.client.sendOperationRequest({
            body: body,
            options: options
        }, appendDataOperationSpec, callback);
    };
    return PathOperations;
}());
// Operation Specifications
var serializer$1 = new coreHttp.Serializer(Mappers$1);
var createOperationSpec$1 = {
    httpMethod: "PUT",
    path: "{filesystem}/{path}",
    urlParameters: [
        url
    ],
    queryParameters: [
        resource2,
        continuation,
        mode,
        timeout
    ],
    headerParameters: [
        renameSource,
        sourceLeaseId,
        properties,
        permissions,
        umask,
        requestId,
        version,
        cacheControl,
        contentEncoding,
        contentLanguage,
        contentDisposition,
        contentType,
        leaseId,
        ifMatch,
        ifNoneMatch,
        ifModifiedSince,
        ifUnmodifiedSince,
        sourceIfMatch,
        sourceIfNoneMatch,
        sourceIfModifiedSince,
        sourceIfUnmodifiedSince
    ],
    responses: {
        201: {
            headersMapper: PathCreateHeaders
        },
        default: {
            bodyMapper: StorageError,
            headersMapper: PathCreateHeaders
        }
    },
    serializer: serializer$1
};
var updateOperationSpec = {
    httpMethod: "PATCH",
    path: "{filesystem}/{path}",
    urlParameters: [
        url
    ],
    queryParameters: [
        action0,
        position,
        retainUncommittedData,
        close,
        timeout
    ],
    headerParameters: [
        contentLength,
        properties,
        owner,
        group,
        permissions,
        acl,
        requestId,
        version,
        contentMD5,
        cacheControl,
        contentType,
        contentDisposition,
        contentEncoding,
        contentLanguage,
        leaseId,
        ifMatch,
        ifNoneMatch,
        ifModifiedSince,
        ifUnmodifiedSince
    ],
    requestBody: {
        parameterPath: "body",
        mapper: {
            required: true,
            serializedName: "body",
            type: {
                name: "Stream"
            }
        }
    },
    contentType: "application/octet-stream",
    responses: {
        200: {
            headersMapper: PathUpdateHeaders
        },
        202: {
            headersMapper: PathUpdateHeaders
        },
        default: {
            bodyMapper: StorageError,
            headersMapper: PathUpdateHeaders
        }
    },
    serializer: serializer$1
};
var leaseOperationSpec = {
    httpMethod: "POST",
    path: "{filesystem}/{path}",
    urlParameters: [
        url
    ],
    queryParameters: [
        timeout
    ],
    headerParameters: [
        xMsLeaseAction,
        xMsLeaseDuration,
        xMsLeaseBreakPeriod,
        proposedLeaseId,
        requestId,
        version,
        leaseId,
        ifMatch,
        ifNoneMatch,
        ifModifiedSince,
        ifUnmodifiedSince
    ],
    responses: {
        200: {
            headersMapper: PathLeaseHeaders
        },
        201: {
            headersMapper: PathLeaseHeaders
        },
        202: {
            headersMapper: PathLeaseHeaders
        },
        default: {
            bodyMapper: StorageError,
            headersMapper: PathLeaseHeaders
        }
    },
    serializer: serializer$1
};
var readOperationSpec = {
    httpMethod: "GET",
    path: "{filesystem}/{path}",
    urlParameters: [
        url
    ],
    queryParameters: [
        timeout
    ],
    headerParameters: [
        range,
        xMsRangeGetContentMd5,
        requestId,
        version,
        leaseId,
        ifMatch,
        ifNoneMatch,
        ifModifiedSince,
        ifUnmodifiedSince
    ],
    responses: {
        200: {
            bodyMapper: {
                serializedName: "parsedResponse",
                type: {
                    name: "Stream"
                }
            },
            headersMapper: PathReadHeaders
        },
        206: {
            bodyMapper: {
                serializedName: "parsedResponse",
                type: {
                    name: "Stream"
                }
            },
            headersMapper: PathReadHeaders
        },
        default: {
            bodyMapper: StorageError,
            headersMapper: PathReadHeaders
        }
    },
    serializer: serializer$1
};
var getPropertiesOperationSpec$1 = {
    httpMethod: "HEAD",
    path: "{filesystem}/{path}",
    urlParameters: [
        url
    ],
    queryParameters: [
        action1,
        upn,
        timeout
    ],
    headerParameters: [
        requestId,
        version,
        leaseId,
        ifMatch,
        ifNoneMatch,
        ifModifiedSince,
        ifUnmodifiedSince
    ],
    responses: {
        200: {
            headersMapper: PathGetPropertiesHeaders
        },
        default: {
            bodyMapper: StorageError,
            headersMapper: PathGetPropertiesHeaders
        }
    },
    serializer: serializer$1
};
var deleteMethodOperationSpec$1 = {
    httpMethod: "DELETE",
    path: "{filesystem}/{path}",
    urlParameters: [
        url
    ],
    queryParameters: [
        recursive1,
        continuation,
        timeout
    ],
    headerParameters: [
        requestId,
        version,
        leaseId,
        ifMatch,
        ifNoneMatch,
        ifModifiedSince,
        ifUnmodifiedSince
    ],
    responses: {
        200: {
            headersMapper: PathDeleteHeaders
        },
        default: {
            bodyMapper: StorageError,
            headersMapper: PathDeleteHeaders
        }
    },
    serializer: serializer$1
};
var setAccessControlOperationSpec = {
    httpMethod: "PATCH",
    path: "{filesystem}/{path}",
    urlParameters: [
        url
    ],
    queryParameters: [
        timeout,
        action2
    ],
    headerParameters: [
        owner,
        group,
        permissions,
        acl,
        requestId,
        version,
        leaseId,
        ifMatch,
        ifNoneMatch,
        ifModifiedSince,
        ifUnmodifiedSince
    ],
    responses: {
        200: {
            headersMapper: PathSetAccessControlHeaders
        },
        default: {
            bodyMapper: StorageError,
            headersMapper: PathSetAccessControlHeaders
        }
    },
    serializer: serializer$1
};
var flushDataOperationSpec = {
    httpMethod: "PATCH",
    path: "{filesystem}/{path}",
    urlParameters: [
        url
    ],
    queryParameters: [
        timeout,
        position,
        retainUncommittedData,
        close,
        action3
    ],
    headerParameters: [
        contentLength,
        requestId,
        version,
        contentMD5,
        cacheControl,
        contentType,
        contentDisposition,
        contentEncoding,
        contentLanguage,
        leaseId,
        ifMatch,
        ifNoneMatch,
        ifModifiedSince,
        ifUnmodifiedSince
    ],
    responses: {
        200: {
            headersMapper: PathFlushDataHeaders
        },
        default: {
            bodyMapper: StorageError,
            headersMapper: PathFlushDataHeaders
        }
    },
    serializer: serializer$1
};
var appendDataOperationSpec = {
    httpMethod: "PATCH",
    path: "{filesystem}/{path}",
    urlParameters: [
        url
    ],
    queryParameters: [
        position,
        timeout,
        action4
    ],
    headerParameters: [
        contentLength,
        requestId,
        version,
        transactionalContentHash,
        leaseId
    ],
    requestBody: {
        parameterPath: "body",
        mapper: {
            required: true,
            serializedName: "body",
            type: {
                name: "Stream"
            }
        }
    },
    responses: {
        202: {
            headersMapper: PathAppendDataHeaders
        },
        default: {
            bodyMapper: StorageError,
            headersMapper: PathAppendDataHeaders
        }
    },
    serializer: serializer$1
};

// Copyright (c) Microsoft Corporation.
/**
 * The @azure/logger configuration for this package.
 */
var logger = logger$1.createClientLogger("storage-file-datalake");

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
var SDK_VERSION = "12.0.0-preview.8";
var SERVICE_VERSION = "2019-07-07";
var StorageOAuthScopes = "https://storage.azure.com/.default";
var StorageDataLakeLoggingAllowedHeaderNames = [
    "Access-Control-Allow-Origin",
    "Cache-Control",
    "Content-Length",
    "Content-Type",
    "Date",
    "Request-Id",
    "traceparent",
    "Transfer-Encoding",
    "User-Agent",
    "x-ms-client-request-id",
    "x-ms-date",
    "x-ms-error-code",
    "x-ms-request-id",
    "x-ms-return-client-request-id",
    "x-ms-version",
    "Accept-Ranges",
    "Content-Disposition",
    "Content-Encoding",
    "Content-Language",
    "Content-MD5",
    "Content-Range",
    "ETag",
    "Last-Modified",
    "Server",
    "Vary",
    "x-ms-content-crc64",
    "x-ms-copy-action",
    "x-ms-copy-completion-time",
    "x-ms-copy-id",
    "x-ms-copy-progress",
    "x-ms-copy-status",
    "x-ms-has-immutability-policy",
    "x-ms-has-legal-hold",
    "x-ms-lease-state",
    "x-ms-lease-status",
    "x-ms-range",
    "x-ms-request-server-encrypted",
    "x-ms-server-encrypted",
    "x-ms-snapshot",
    "x-ms-source-range",
    "If-Match",
    "If-Modified-Since",
    "If-None-Match",
    "If-Unmodified-Since",
    "x-ms-access-tier",
    "x-ms-access-tier-change-time",
    "x-ms-access-tier-inferred",
    "x-ms-account-kind",
    "x-ms-archive-status",
    "x-ms-blob-append-offset",
    "x-ms-blob-cache-control",
    "x-ms-blob-committed-block-count",
    "x-ms-blob-condition-appendpos",
    "x-ms-blob-condition-maxsize",
    "x-ms-blob-content-disposition",
    "x-ms-blob-content-encoding",
    "x-ms-blob-content-language",
    "x-ms-blob-content-length",
    "x-ms-blob-content-md5",
    "x-ms-blob-content-type",
    "x-ms-blob-public-access",
    "x-ms-blob-sequence-number",
    "x-ms-blob-type",
    "x-ms-copy-destination-snapshot",
    "x-ms-creation-time",
    "x-ms-default-encryption-scope",
    "x-ms-delete-snapshots",
    "x-ms-delete-type-permanent",
    "x-ms-deny-encryption-scope-override",
    "x-ms-encryption-algorithm",
    "x-ms-if-sequence-number-eq",
    "x-ms-if-sequence-number-le",
    "x-ms-if-sequence-number-lt",
    "x-ms-incremental-copy",
    "x-ms-lease-action",
    "x-ms-lease-break-period",
    "x-ms-lease-duration",
    "x-ms-lease-id",
    "x-ms-lease-time",
    "x-ms-page-write",
    "x-ms-proposed-lease-id",
    "x-ms-range-get-content-md5",
    "x-ms-rehydrate-priority",
    "x-ms-sequence-number-action",
    "x-ms-sku-name",
    "x-ms-source-content-md5",
    "x-ms-source-if-match",
    "x-ms-source-if-modified-since",
    "x-ms-source-if-none-match",
    "x-ms-source-if-unmodified-since",
    "x-ms-tag-count",
    "x-ms-encryption-key-sha256"
];
var StorageDataLakeLoggingAllowedQueryParameters = [
    "comp",
    "maxresults",
    "rscc",
    "rscd",
    "rsce",
    "rscl",
    "rsct",
    "se",
    "si",
    "sip",
    "sp",
    "spr",
    "sr",
    "srt",
    "ss",
    "st",
    "sv",
    "include",
    "marker",
    "prefix",
    "copyid",
    "restype",
    "blockid",
    "blocklisttype",
    "delimiter",
    "prevsnapshot",
    "ske",
    "skoid",
    "sks",
    "skt",
    "sktid",
    "skv",
    "snapshot"
];
var UrlConstants = {
    Parameters: {
        FORCE_BROWSER_NO_CACHE: "_",
        SIGNATURE: "sig",
        SNAPSHOT: "snapshot",
        TIMEOUT: "timeout"
    }
};
var HeaderConstants = {
    AUTHORIZATION: "Authorization",
    AUTHORIZATION_SCHEME: "Bearer",
    CONTENT_ENCODING: "Content-Encoding",
    CONTENT_ID: "Content-ID",
    CONTENT_LANGUAGE: "Content-Language",
    CONTENT_LENGTH: "Content-Length",
    CONTENT_MD5: "Content-Md5",
    CONTENT_TRANSFER_ENCODING: "Content-Transfer-Encoding",
    CONTENT_TYPE: "Content-Type",
    COOKIE: "Cookie",
    DATE: "date",
    IF_MATCH: "if-match",
    IF_MODIFIED_SINCE: "if-modified-since",
    IF_NONE_MATCH: "if-none-match",
    IF_UNMODIFIED_SINCE: "if-unmodified-since",
    PREFIX_FOR_STORAGE: "x-ms-",
    RANGE: "Range",
    USER_AGENT: "User-Agent",
    X_MS_CLIENT_REQUEST_ID: "x-ms-client-request-id",
    X_MS_COPY_SOURCE: "x-ms-copy-source",
    X_MS_DATE: "x-ms-date",
    X_MS_ERROR_CODE: "x-ms-error-code",
    X_MS_VERSION: "x-ms-version"
};
// Mapping pairs to transform url from dfs endpoint to blob endpoint
// Customize this value to add more mapping patterns
var ToBlobEndpointHostMappings = [["dfs.core.windows.net", "blob.core.windows.net"]];
// Mapping pairs to transform url from blob endpoint to dfs endpoint
// Customize this value to add more mapping patterns
var ToDfsEndpointHostMappings = [["blob.core.windows.net", "dfs.core.windows.net"]];

/**
 * Reserved URL characters must be properly escaped for Storage services like Blob or File.
 *
 * ## URL encode and escape strategy for JS SDKs
 *
 * When customers pass a URL string into XxxClient classes constructors, the URL string may already be URL encoded or not.
 * But before sending to Azure Storage server, the URL must be encoded. However, it's hard for a SDK to guess whether the URL
 * string has been encoded or not. We have 2 potential strategies, and chose strategy two for the XxxClient constructors.
 *
 * ### Strategy One: Assume the customer URL string is not encoded, and always encode URL string in SDK.
 *
 * This is what legacy V2 SDK does, simple and works for most of the cases.
 * - When customer URL string is "http://account.blob.core.windows.net/con/b:",
 *   SDK will encode it to "http://account.blob.core.windows.net/con/b%3A" and send to server. A blob named "b:" will be created.
 * - When customer URL string is "http://account.blob.core.windows.net/con/b%3A",
 *   SDK will encode it to "http://account.blob.core.windows.net/con/b%253A" and send to server. A blob named "b%3A" will be created.
 *
 * But this strategy will make it not possible to create a blob with "?" in it's name. Because when customer URL string is
 * "http://account.blob.core.windows.net/con/blob?name", the "?name" will be treated as URL paramter instead of blob name.
 * If customer URL string is "http://account.blob.core.windows.net/con/blob%3Fname", a blob named "blob%3Fname" will be created.
 * V2 SDK doesn't have this issue because it doesn't allow customer pass in a full URL, it accepts a separate blob name and encodeURIComponent for it.
 * We cannot accept a SDK cannot create a blob name with "?". So we implement strategy two:
 *
 * ### Strategy Two: SDK doesn't assume the URL has been encoded or not. It will just escape the special characters.
 *
 * This is what V10 Blob Go SDK does. It accepts a URL type in Go, and call url.EscapedPath() to escape the special chars unescaped.
 * - When customer URL string is "http://account.blob.core.windows.net/con/b:",
 *   SDK will escape ":" like "http://account.blob.core.windows.net/con/b%3A" and send to server. A blob named "b:" will be created.
 * - When customer URL string is "http://account.blob.core.windows.net/con/b%3A",
 *   There is no special characters, so send "http://account.blob.core.windows.net/con/b%3A" to server. A blob named "b:" will be created.
 * - When customer URL string is "http://account.blob.core.windows.net/con/b%253A",
 *   There is no special characters, so send "http://account.blob.core.windows.net/con/b%253A" to server. A blob named "b%3A" will be created.
 *
 * This strategy gives us flexibility to create with any special characters. But "%" will be treated as a special characters, if the URL string
 * is not encoded, there shouldn't a "%" in the URL string, otherwise the URL is not a valid URL.
 * If customer needs to create a blob with "%" in it's blob name, use "%25" instead of "%". Just like above 3rd sample.
 * And following URL strings are invalid:
 * - "http://account.blob.core.windows.net/con/b%"
 * - "http://account.blob.core.windows.net/con/b%2"
 * - "http://account.blob.core.windows.net/con/b%G"
 *
 * Another special character is "?", use "%2F" to represent a blob name with "?" in a URL string.
 *
 * ### Strategy for containerName, blobName or other specific XXXName parameters in methods such as `containerClient.getBlobClient(blobName)`
 *
 * We will apply strategy one, and call encodeURIComponent for these parameters like blobName. Because what customers passes in is a plain name instead of a URL.
 *
 * @see https://docs.microsoft.com/en-us/rest/api/storageservices/naming-and-referencing-containers--blobs--and-metadata
 * @see https://docs.microsoft.com/en-us/rest/api/storageservices/naming-and-referencing-shares--directories--files--and-metadata
 *
 * @export
 * @param {string} url
 * @returns {string}
 */
function escapeURLPath(url) {
    var urlParsed = coreHttp.URLBuilder.parse(url);
    var path = urlParsed.getPath();
    path = path || "/";
    path = escape(path);
    urlParsed.setPath(path);
    return urlParsed.toString();
}
/**
 * Internal escape method implemented Strategy Two mentioned in escapeURL() description.
 *
 * @param {string} text
 * @returns {string}
 */
function escape(text) {
    return encodeURIComponent(text)
        .replace(/%2F/g, "/") // Don't escape for "/"
        .replace(/'/g, "%27") // Escape for "'"
        .replace(/\+/g, "%20")
        .replace(/%25/g, "%"); // Revert encoded "%"
}
/**
 * Append a string to URL path. Will remove duplicated "/" in front of the string
 * when URL path ends with a "/".
 *
 * @export
 * @param {string} url Source URL string
 * @param {string} name String to be appended to URL
 * @returns {string} An updated URL string
 */
function appendToURLPath(url, name) {
    var urlParsed = coreHttp.URLBuilder.parse(url);
    var path = urlParsed.getPath();
    path = path ? (path.endsWith("/") ? "" + path + name : path + "/" + name) : name;
    urlParsed.setPath(path);
    return urlParsed.toString();
}
/**
 * Set URL parameter name and value. If name exists in URL parameters, old value
 * will be replaced by name key. If not provide value, the parameter will be deleted.
 *
 * @export
 * @param {string} url Source URL string
 * @param {string} name Parameter name
 * @param {string} [value] Parameter value
 * @returns {string} An updated URL string
 */
function setURLParameter(url, name, value) {
    var urlParsed = coreHttp.URLBuilder.parse(url);
    urlParsed.setQueryParameter(name, value);
    return urlParsed.toString();
}
/**
 * Set URL host.
 *
 * @export
 * @param {string} url Source URL string
 * @param {string} host New host string
 * @returns An updated URL string
 */
function setURLHost(url, host) {
    var urlParsed = coreHttp.URLBuilder.parse(url);
    urlParsed.setHost(host);
    return urlParsed.toString();
}
/**
 * Get URL path from an URL string.
 *
 * @export
 * @param {string} url Source URL string
 * @returns {(string | undefined)}
 */
function getURLPath(url) {
    var urlParsed = coreHttp.URLBuilder.parse(url);
    return urlParsed.getPath();
}
/**
 * Set URL path.
 *
 * @export
 * @param {string} url
 * @param {string} [path]
 * @returns {string}
 */
function setURLPath(url, path) {
    var urlParsed = coreHttp.URLBuilder.parse(url);
    urlParsed.setPath(path);
    return urlParsed.toString();
}
/**
 * Get URL scheme from an URL string.
 *
 * @export
 * @param {string} url Source URL string
 * @returns {(string | undefined)}
 */
function getURLScheme(url) {
    var urlParsed = coreHttp.URLBuilder.parse(url);
    return urlParsed.getScheme();
}
/**
 * Get URL query key value pairs from an URL string.
 *
 * @export
 * @param {string} url
 * @returns {{[key: string]: string}}
 */
function getURLQueries(url) {
    var queryString = coreHttp.URLBuilder.parse(url).getQuery();
    if (!queryString) {
        return {};
    }
    queryString = queryString.trim();
    queryString = queryString.startsWith("?") ? queryString.substr(1) : queryString;
    var querySubStrings = queryString.split("&");
    querySubStrings = querySubStrings.filter(function (value) {
        var indexOfEqual = value.indexOf("=");
        var lastIndexOfEqual = value.lastIndexOf("=");
        return (indexOfEqual > 0 && indexOfEqual === lastIndexOfEqual && lastIndexOfEqual < value.length - 1);
    });
    var queries = {};
    for (var _i = 0, querySubStrings_1 = querySubStrings; _i < querySubStrings_1.length; _i++) {
        var querySubString = querySubStrings_1[_i];
        var splitResults = querySubString.split("=");
        var key = splitResults[0];
        var value = splitResults[1];
        queries[key] = value;
    }
    return queries;
}
/**
 * Rounds a date off to seconds.
 *
 * @export
 * @param {Date} date
 * @param {boolean} [withMilliseconds=true] If true, YYYY-MM-DDThh:mm:ss.fffffffZ will be returned;
 *                                          If false, YYYY-MM-DDThh:mm:ssZ will be returned.
 * @returns {string} Date string in ISO8061 format, with or without 7 milliseconds component
 */
function truncatedISO8061Date(date, withMilliseconds) {
    if (withMilliseconds === void 0) { withMilliseconds = true; }
    // Date.toISOString() will return like "2018-10-29T06:34:36.139Z"
    var dateString = date.toISOString();
    return withMilliseconds
        ? dateString.substring(0, dateString.length - 1) + "0000" + "Z"
        : dateString.substring(0, dateString.length - 5) + "Z";
}
/**
 * Base64 encode.
 *
 * @export
 * @param {string} content
 * @returns {string}
 */
function base64encode(content) {
    return !coreHttp.isNode ? btoa(content) : Buffer.from(content).toString("base64");
}
/**
 * Delay specified time interval.
 *
 * @export
 * @param {number} timeInMs
 * @param {AbortSignalLike} [aborter]
 * @param {Error} [abortError]
 */
function delay(timeInMs, aborter, abortError) {
    return tslib.__awaiter(this, void 0, void 0, function () {
        return tslib.__generator(this, function (_a) {
            return [2 /*return*/, new Promise(function (resolve, reject) {
                    var timeout;
                    var abortHandler = function () {
                        if (timeout !== undefined) {
                            clearTimeout(timeout);
                        }
                        reject(abortError);
                    };
                    var resolveHandler = function () {
                        if (aborter !== undefined) {
                            aborter.removeEventListener("abort", abortHandler);
                        }
                        resolve();
                    };
                    timeout = setTimeout(resolveHandler, timeInMs);
                    if (aborter !== undefined) {
                        aborter.addEventListener("abort", abortHandler);
                    }
                })];
        });
    });
}
/**
 * If two strings are equal when compared case insensitive.
 *
 * @export
 * @param {string} str1
 * @param {string} str2
 * @returns {boolean}
 */
function iEqual(str1, str2) {
    return str1.toLocaleLowerCase() === str2.toLocaleLowerCase();
}
/**
 * Extracts account name from the blobEndpointUrl
 * @param {string} blobEndpointUrl blobEndpointUrl to extract the account name from
 * @returns {string} account name
 */
function getAccountNameFromUrl(blobEndpointUrl) {
    var parsedUrl = coreHttp.URLBuilder.parse(blobEndpointUrl);
    var accountName;
    try {
        if (parsedUrl.getHost().split(".")[1] === "blob") {
            // `${defaultEndpointsProtocol}://${accountName}.blob.${endpointSuffix}`;
            accountName = parsedUrl.getHost().split(".")[0];
        }
        else {
            // IPv4/IPv6 address hosts... Example - http://192.0.0.10:10001/devstoreaccount1/
            // Single word domain without a [dot] in the endpoint... Example - http://localhost:10001/devstoreaccount1/
            // .getPath() -> /devstoreaccount1/
            accountName = parsedUrl.getPath().split("/")[1];
        }
        if (!accountName) {
            throw new Error("Provided accountName is invalid.");
        }
        return accountName;
    }
    catch (error) {
        throw new Error("Unable to extract accountName with provided information.");
    }
}

/**
 * StorageBrowserPolicy will handle differences between Node.js and browser runtime, including:
 *
 * 1. Browsers cache GET/HEAD requests by adding conditional headers such as 'IF_MODIFIED_SINCE'.
 * StorageBrowserPolicy is a policy used to add a timestamp query to GET/HEAD request URL
 * thus avoid the browser cache.
 *
 * 2. Remove cookie header for security
 *
 * 3. Remove content-length header to avoid browsers warning
 *
 * @class StorageBrowserPolicy
 * @extends {BaseRequestPolicy}
 */
var StorageBrowserPolicy = /** @class */ (function (_super) {
    tslib.__extends(StorageBrowserPolicy, _super);
    /**
     * Creates an instance of StorageBrowserPolicy.
     * @param {RequestPolicy} nextPolicy
     * @param {RequestPolicyOptions} options
     * @memberof StorageBrowserPolicy
     */
    function StorageBrowserPolicy(nextPolicy, options) {
        return _super.call(this, nextPolicy, options) || this;
    }
    /**
     * Sends out request.
     *
     * @param {WebResource} request
     * @returns {Promise<HttpOperationResponse>}
     * @memberof StorageBrowserPolicy
     */
    StorageBrowserPolicy.prototype.sendRequest = function (request) {
        return tslib.__awaiter(this, void 0, void 0, function () {
            return tslib.__generator(this, function (_a) {
                {
                    return [2 /*return*/, this._nextPolicy.sendRequest(request)];
                }
            });
        });
    };
    return StorageBrowserPolicy;
}(coreHttp.BaseRequestPolicy));

// Copyright (c) Microsoft Corporation. All rights reserved.
/**
 * StorageBrowserPolicyFactory is a factory class helping generating StorageBrowserPolicy objects.
 *
 * @export
 * @class StorageBrowserPolicyFactory
 * @implements {RequestPolicyFactory}
 */
var StorageBrowserPolicyFactory = /** @class */ (function () {
    function StorageBrowserPolicyFactory() {
    }
    /**
     * Creates a StorageBrowserPolicyFactory object.
     *
     * @param {RequestPolicy} nextPolicy
     * @param {RequestPolicyOptions} options
     * @returns {StorageBrowserPolicy}
     * @memberof StorageBrowserPolicyFactory
     */
    StorageBrowserPolicyFactory.prototype.create = function (nextPolicy, options) {
        return new StorageBrowserPolicy(nextPolicy, options);
    };
    return StorageBrowserPolicyFactory;
}());

(function (StorageRetryPolicyType) {
    /**
     * Exponential retry. Retry time delay grows exponentially.
     */
    StorageRetryPolicyType[StorageRetryPolicyType["EXPONENTIAL"] = 0] = "EXPONENTIAL";
    /**
     * Linear retry. Retry time delay grows linearly.
     */
    StorageRetryPolicyType[StorageRetryPolicyType["FIXED"] = 1] = "FIXED";
})(exports.StorageRetryPolicyType || (exports.StorageRetryPolicyType = {}));
// Default values of StorageRetryOptions
var DEFAULT_RETRY_OPTIONS = {
    maxRetryDelayInMs: 120 * 1000,
    maxTries: 4,
    retryDelayInMs: 4 * 1000,
    retryPolicyType: exports.StorageRetryPolicyType.EXPONENTIAL,
    secondaryHost: "",
    tryTimeoutInMs: undefined // Use server side default timeout strategy
};
var RETRY_ABORT_ERROR = new abortController.AbortError("The operation was aborted.");
/**
 * Retry policy with exponential retry and linear retry implemented.
 *
 * @class RetryPolicy
 * @extends {BaseRequestPolicy}
 */
var StorageRetryPolicy = /** @class */ (function (_super) {
    tslib.__extends(StorageRetryPolicy, _super);
    /**
     * Creates an instance of RetryPolicy.
     *
     * @param {RequestPolicy} nextPolicy
     * @param {RequestPolicyOptions} options
     * @param {StorageRetryOptions} [retryOptions=DEFAULT_RETRY_OPTIONS]
     * @memberof StorageRetryPolicy
     */
    function StorageRetryPolicy(nextPolicy, options, retryOptions) {
        if (retryOptions === void 0) { retryOptions = DEFAULT_RETRY_OPTIONS; }
        var _this = _super.call(this, nextPolicy, options) || this;
        // Initialize retry options
        _this.retryOptions = {
            retryPolicyType: retryOptions.retryPolicyType
                ? retryOptions.retryPolicyType
                : DEFAULT_RETRY_OPTIONS.retryPolicyType,
            maxTries: retryOptions.maxTries && retryOptions.maxTries >= 1
                ? Math.floor(retryOptions.maxTries)
                : DEFAULT_RETRY_OPTIONS.maxTries,
            tryTimeoutInMs: retryOptions.tryTimeoutInMs && retryOptions.tryTimeoutInMs >= 0
                ? retryOptions.tryTimeoutInMs
                : DEFAULT_RETRY_OPTIONS.tryTimeoutInMs,
            retryDelayInMs: retryOptions.retryDelayInMs && retryOptions.retryDelayInMs >= 0
                ? Math.min(retryOptions.retryDelayInMs, retryOptions.maxRetryDelayInMs
                    ? retryOptions.maxRetryDelayInMs
                    : DEFAULT_RETRY_OPTIONS.maxRetryDelayInMs)
                : DEFAULT_RETRY_OPTIONS.retryDelayInMs,
            maxRetryDelayInMs: retryOptions.maxRetryDelayInMs && retryOptions.maxRetryDelayInMs >= 0
                ? retryOptions.maxRetryDelayInMs
                : DEFAULT_RETRY_OPTIONS.maxRetryDelayInMs,
            secondaryHost: retryOptions.secondaryHost
                ? retryOptions.secondaryHost
                : DEFAULT_RETRY_OPTIONS.secondaryHost
        };
        return _this;
    }
    /**
     * Sends request.
     *
     * @param {WebResource} request
     * @returns {Promise<HttpOperationResponse>}
     * @memberof StorageRetryPolicy
     */
    StorageRetryPolicy.prototype.sendRequest = function (request) {
        return tslib.__awaiter(this, void 0, void 0, function () {
            return tslib.__generator(this, function (_a) {
                return [2 /*return*/, this.attemptSendRequest(request, false, 1)];
            });
        });
    };
    /**
     * Decide and perform next retry. Won't mutate request parameter.
     *
     * @protected
     * @param {WebResource} request
     * @param {boolean} secondaryHas404  If attempt was against the secondary & it returned a StatusNotFound (404), then
     *                                   the resource was not found. This may be due to replication delay. So, in this
     *                                   case, we'll never try the secondary again for this operation.
     * @param {number} attempt           How many retries has been attempted to performed, starting from 1, which includes
     *                                   the attempt will be performed by this method call.
     * @returns {Promise<HttpOperationResponse>}
     * @memberof StorageRetryPolicy
     */
    StorageRetryPolicy.prototype.attemptSendRequest = function (request, secondaryHas404, attempt) {
        return tslib.__awaiter(this, void 0, void 0, function () {
            var newRequest, isPrimaryRetry, response, err_1;
            return tslib.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        newRequest = request.clone();
                        isPrimaryRetry = secondaryHas404 ||
                            !this.retryOptions.secondaryHost ||
                            !(request.method === "GET" || request.method === "HEAD" || request.method === "OPTIONS") ||
                            attempt % 2 === 1;
                        if (!isPrimaryRetry) {
                            newRequest.url = setURLHost(newRequest.url, this.retryOptions.secondaryHost);
                        }
                        // Set the server-side timeout query parameter "timeout=[seconds]"
                        if (this.retryOptions.tryTimeoutInMs) {
                            newRequest.url = setURLParameter(newRequest.url, UrlConstants.Parameters.TIMEOUT, Math.floor(this.retryOptions.tryTimeoutInMs / 1000).toString());
                        }
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, 3, , 4]);
                        logger.info("RetryPolicy: =====> Try=" + attempt + " " + (isPrimaryRetry ? "Primary" : "Secondary"));
                        return [4 /*yield*/, this._nextPolicy.sendRequest(newRequest)];
                    case 2:
                        response = _a.sent();
                        if (!this.shouldRetry(isPrimaryRetry, attempt, response)) {
                            return [2 /*return*/, response];
                        }
                        secondaryHas404 = secondaryHas404 || (!isPrimaryRetry && response.status === 404);
                        return [3 /*break*/, 4];
                    case 3:
                        err_1 = _a.sent();
                        logger.error("RetryPolicy: Caught error, message: " + err_1.message + ", code: " + err_1.code);
                        if (!this.shouldRetry(isPrimaryRetry, attempt, response, err_1)) {
                            throw err_1;
                        }
                        return [3 /*break*/, 4];
                    case 4: return [4 /*yield*/, this.delay(isPrimaryRetry, attempt, request.abortSignal)];
                    case 5:
                        _a.sent();
                        return [4 /*yield*/, this.attemptSendRequest(request, secondaryHas404, ++attempt)];
                    case 6: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    /**
     * Decide whether to retry according to last HTTP response and retry counters.
     *
     * @protected
     * @param {boolean} isPrimaryRetry
     * @param {number} attempt
     * @param {HttpOperationResponse} [response]
     * @param {RestError} [err]
     * @returns {boolean}
     * @memberof StorageRetryPolicy
     */
    StorageRetryPolicy.prototype.shouldRetry = function (isPrimaryRetry, attempt, response, err) {
        if (attempt >= this.retryOptions.maxTries) {
            logger.info("RetryPolicy: Attempt(s) " + attempt + " >= maxTries " + this.retryOptions
                .maxTries + ", no further try.");
            return false;
        }
        // Handle network failures, you may need to customize the list when you implement
        // your own http client
        var retriableErrors = [
            "ETIMEDOUT",
            "ESOCKETTIMEDOUT",
            "ECONNREFUSED",
            "ECONNRESET",
            "ENOENT",
            "ENOTFOUND",
            "TIMEOUT",
            "EPIPE",
            "REQUEST_SEND_ERROR" // For default xhr based http client provided in ms-rest-js
        ];
        if (err) {
            for (var _i = 0, retriableErrors_1 = retriableErrors; _i < retriableErrors_1.length; _i++) {
                var retriableError = retriableErrors_1[_i];
                if (err.name.toUpperCase().includes(retriableError) ||
                    err.message.toUpperCase().includes(retriableError) ||
                    (err.code &&
                        err.code
                            .toString()
                            .toUpperCase()
                            .includes(retriableError))) {
                    logger.info("RetryPolicy: Network error " + retriableError + " found, will retry.");
                    return true;
                }
            }
        }
        // If attempt was against the secondary & it returned a StatusNotFound (404), then
        // the resource was not found. This may be due to replication delay. So, in this
        // case, we'll never try the secondary again for this operation.
        if (response || err) {
            var statusCode = response ? response.status : err ? err.statusCode : 0;
            if (!isPrimaryRetry && statusCode === 404) {
                logger.info("RetryPolicy: Secondary access with 404, will retry.");
                return true;
            }
            // Server internal error or server timeout
            if (statusCode === 503 || statusCode === 500) {
                logger.info("RetryPolicy: Will retry for status code " + statusCode + ".");
                return true;
            }
        }
        return false;
    };
    /**
     * Delay a calculated time between retries.
     *
     * @private
     * @param {boolean} isPrimaryRetry
     * @param {number} attempt
     * @param {AbortSignalLike} [abortSignal]
     * @memberof StorageRetryPolicy
     */
    StorageRetryPolicy.prototype.delay = function (isPrimaryRetry, attempt, abortSignal) {
        return tslib.__awaiter(this, void 0, void 0, function () {
            var delayTimeInMs;
            return tslib.__generator(this, function (_a) {
                delayTimeInMs = 0;
                if (isPrimaryRetry) {
                    switch (this.retryOptions.retryPolicyType) {
                        case exports.StorageRetryPolicyType.EXPONENTIAL:
                            delayTimeInMs = Math.min((Math.pow(2, attempt - 1) - 1) * this.retryOptions.retryDelayInMs, this.retryOptions.maxRetryDelayInMs);
                            break;
                        case exports.StorageRetryPolicyType.FIXED:
                            delayTimeInMs = this.retryOptions.retryDelayInMs;
                            break;
                    }
                }
                else {
                    delayTimeInMs = Math.random() * 1000;
                }
                logger.info("RetryPolicy: Delay for " + delayTimeInMs + "ms");
                return [2 /*return*/, delay(delayTimeInMs, abortSignal, RETRY_ABORT_ERROR)];
            });
        });
    };
    return StorageRetryPolicy;
}(coreHttp.BaseRequestPolicy));

// Copyright (c) Microsoft Corporation. All rights reserved.
/**
 * StorageRetryPolicyFactory is a factory class helping generating {@link StorageRetryPolicy} objects.
 *
 * @export
 * @class StorageRetryPolicyFactory
 * @implements {RequestPolicyFactory}
 */
var StorageRetryPolicyFactory = /** @class */ (function () {
    /**
     * Creates an instance of StorageRetryPolicyFactory.
     * @param {StorageRetryOptions} [retryOptions]
     * @memberof StorageRetryPolicyFactory
     */
    function StorageRetryPolicyFactory(retryOptions) {
        this.retryOptions = retryOptions;
    }
    /**
     * Creates a StorageRetryPolicy object.
     *
     * @param {RequestPolicy} nextPolicy
     * @param {RequestPolicyOptions} options
     * @returns {StorageRetryPolicy}
     * @memberof StorageRetryPolicyFactory
     */
    StorageRetryPolicyFactory.prototype.create = function (nextPolicy, options) {
        return new StorageRetryPolicy(nextPolicy, options, this.retryOptions);
    };
    return StorageRetryPolicyFactory;
}());

// Copyright (c) Microsoft Corporation. All rights reserved.
/**
 * TelemetryPolicy is a policy used to tag user-agent header for every requests.
 *
 * @class TelemetryPolicy
 * @extends {BaseRequestPolicy}
 */
var TelemetryPolicy = /** @class */ (function (_super) {
    tslib.__extends(TelemetryPolicy, _super);
    /**
     * Creates an instance of TelemetryPolicy.
     * @param {RequestPolicy} nextPolicy
     * @param {RequestPolicyOptions} options
     * @param {string} telemetry
     * @memberof TelemetryPolicy
     */
    function TelemetryPolicy(nextPolicy, options, telemetry) {
        var _this = _super.call(this, nextPolicy, options) || this;
        _this.telemetry = telemetry;
        return _this;
    }
    /**
     * Sends out request.
     *
     * @param {WebResource} request
     * @returns {Promise<HttpOperationResponse>}
     * @memberof TelemetryPolicy
     */
    TelemetryPolicy.prototype.sendRequest = function (request) {
        return tslib.__awaiter(this, void 0, void 0, function () {
            return tslib.__generator(this, function (_a) {
                {
                    if (!request.headers) {
                        request.headers = new coreHttp.HttpHeaders();
                    }
                    if (!request.headers.get(HeaderConstants.USER_AGENT)) {
                        request.headers.set(HeaderConstants.USER_AGENT, this.telemetry);
                    }
                }
                return [2 /*return*/, this._nextPolicy.sendRequest(request)];
            });
        });
    };
    return TelemetryPolicy;
}(coreHttp.BaseRequestPolicy));

// Copyright (c) Microsoft Corporation. All rights reserved.
/**
 * TelemetryPolicyFactory is a factory class helping generating {@link TelemetryPolicy} objects.
 *
 * @export
 * @class TelemetryPolicyFactory
 * @implements {RequestPolicyFactory}
 */
var TelemetryPolicyFactory = /** @class */ (function () {
    /**
     * Creates an instance of TelemetryPolicyFactory.
     * @param {UserAgentOptions} [telemetry]
     * @memberof TelemetryPolicyFactory
     */
    function TelemetryPolicyFactory(telemetry) {
        var userAgentInfo = [];
        {
            if (telemetry) {
                var telemetryString = (telemetry.userAgentPrefix || "").replace(" ", "");
                if (telemetryString.length > 0 && userAgentInfo.indexOf(telemetryString) === -1) {
                    userAgentInfo.push(telemetryString);
                }
            }
            // e.g. azsdk-js-storagedatalake/10.0.0
            var libInfo = "azsdk-js-storagedatalake/" + SDK_VERSION;
            if (userAgentInfo.indexOf(libInfo) === -1) {
                userAgentInfo.push(libInfo);
            }
            // e.g. (NODE-VERSION 4.9.1; Windows_NT 10.0.16299)
            var runtimeInfo = "(NODE-VERSION " + process.version + "; " + os.type() + " " + os.release() + ")";
            if (userAgentInfo.indexOf(runtimeInfo) === -1) {
                userAgentInfo.push(runtimeInfo);
            }
        }
        this.telemetryString = userAgentInfo.join(" ");
    }
    /**
     * Creates a TelemetryPolicy object.
     *
     * @param {RequestPolicy} nextPolicy
     * @param {RequestPolicyOptions} options
     * @returns {TelemetryPolicy}
     * @memberof TelemetryPolicyFactory
     */
    TelemetryPolicyFactory.prototype.create = function (nextPolicy, options) {
        return new TelemetryPolicy(nextPolicy, options, this.telemetryString);
    };
    return TelemetryPolicyFactory;
}());

/**
 * A Pipeline class containing HTTP request policies.
 * You can create a default Pipeline by calling {@link newPipeline}.
 * Or you can create a Pipeline with your own policies by the constructor of Pipeline.
 *
 * Refer to {@link newPipeline} and provided policies before implementing your
 * customized Pipeline.
 *
 * @export
 * @class Pipeline
 */
var Pipeline = /** @class */ (function (_super) {
    tslib.__extends(Pipeline, _super);
    /**
     * Creates an instance of Pipeline. Customize HTTPClient by implementing IHttpClient interface.
     *
     * @param {RequestPolicyFactory[]} factories
     * @param {PipelineOptions} [options={}]
     * @memberof Pipeline
     */
    function Pipeline(factories, options) {
        if (options === void 0) { options = {}; }
        var _this = _super.call(this, factories, options) || this;
        _this.factories = factories;
        _this.options = options;
        return _this;
    }
    /**
     * Transfer Pipeline object to ServiceClientOptions object which is required by
     * ServiceClient constructor.
     *
     * @returns {ServiceClientOptions} The ServiceClientOptions object from this Pipeline.
     * @memberof Pipeline
     */
    Pipeline.prototype.toServiceClientOptions = function () {
        return {
            httpClient: this.options.httpClient,
            requestPolicyFactories: this.factories
        };
    };
    return Pipeline;
}(storageBlob.Pipeline));
/**
 * Creates a new Pipeline object with Credential provided.
 *
 * @export
 * @param {StorageSharedKeyCredential | AnonymousCredential | TokenCredential} credential  Such as AnonymousCredential, StorageSharedKeyCredential or any credential from the @azure/identity package to authenticate requests to the service. You can also provide an object that implements the TokenCredential interface. If not specified, AnonymousCredential is used.
 * @param {StoragePipelineOptions} [pipelineOptions] Optional. Options.
 * @returns {Pipeline} A new Pipeline object.
 */
function newPipeline(credential, pipelineOptions) {
    // Order is important. Closer to the API at the top & closer to the network at the bottom.
    // The credential's policy factory must appear close to the wire so it can sign any
    // changes made by other factories (like UniqueRequestIDPolicyFactory)
    if (pipelineOptions === void 0) { pipelineOptions = {}; }
    var telemetryPolicy = new TelemetryPolicyFactory(pipelineOptions.userAgentOptions);
    var factories = [
        coreHttp.tracingPolicy({ userAgent: telemetryPolicy.telemetryString }),
        coreHttp.keepAlivePolicy(pipelineOptions.keepAliveOptions),
        telemetryPolicy,
        coreHttp.generateClientRequestIdPolicy(),
        new StorageBrowserPolicyFactory(),
        coreHttp.deserializationPolicy(),
        new StorageRetryPolicyFactory(pipelineOptions.retryOptions),
        coreHttp.logPolicy({
            logger: logger.info,
            allowedHeaderNames: StorageDataLakeLoggingAllowedHeaderNames,
            allowedQueryParameters: StorageDataLakeLoggingAllowedQueryParameters
        })
    ];
    {
        // ProxyPolicy is only avaiable in Node.js runtime, not in browsers
        factories.push(coreHttp.proxyPolicy(pipelineOptions.proxyOptions));
    }
    factories.push(coreHttp.isTokenCredential(credential)
        ? coreHttp.bearerTokenAuthenticationPolicy(credential, StorageOAuthScopes)
        : credential);
    return new Pipeline(factories, {
        httpClient: pipelineOptions.httpClient
    });
}

/**
 * StorageSharedKeyCredentialPolicy is a policy used to sign HTTP request with a shared key.
 *
 * @export
 * @class StorageSharedKeyCredentialPolicy
 * @extends {CredentialPolicy}
 */
var StorageSharedKeyCredentialPolicy = /** @class */ (function (_super) {
    tslib.__extends(StorageSharedKeyCredentialPolicy, _super);
    /**
     * Creates an instance of StorageSharedKeyCredentialPolicy.
     * @param {RequestPolicy} nextPolicy
     * @param {RequestPolicyOptions} options
     * @param {StorageSharedKeyCredential} factory
     * @memberof StorageSharedKeyCredentialPolicy
     */
    function StorageSharedKeyCredentialPolicy(nextPolicy, options, factory) {
        var _this = _super.call(this, nextPolicy, options) || this;
        _this.factory = factory;
        return _this;
    }
    /**
     * Signs request.
     *
     * @protected
     * @param {WebResource} request
     * @returns {WebResource}
     * @memberof StorageSharedKeyCredentialPolicy
     */
    StorageSharedKeyCredentialPolicy.prototype.signRequest = function (request) {
        request.headers.set(HeaderConstants.X_MS_DATE, new Date().toUTCString());
        if (request.body && typeof request.body === "string" && request.body.length > 0) {
            request.headers.set(HeaderConstants.CONTENT_LENGTH, Buffer.byteLength(request.body));
        }
        var stringToSign = [
            request.method.toUpperCase(),
            this.getHeaderValueToSign(request, HeaderConstants.CONTENT_LANGUAGE),
            this.getHeaderValueToSign(request, HeaderConstants.CONTENT_ENCODING),
            this.getHeaderValueToSign(request, HeaderConstants.CONTENT_LENGTH),
            this.getHeaderValueToSign(request, HeaderConstants.CONTENT_MD5),
            this.getHeaderValueToSign(request, HeaderConstants.CONTENT_TYPE),
            this.getHeaderValueToSign(request, HeaderConstants.DATE),
            this.getHeaderValueToSign(request, HeaderConstants.IF_MODIFIED_SINCE),
            this.getHeaderValueToSign(request, HeaderConstants.IF_MATCH),
            this.getHeaderValueToSign(request, HeaderConstants.IF_NONE_MATCH),
            this.getHeaderValueToSign(request, HeaderConstants.IF_UNMODIFIED_SINCE),
            this.getHeaderValueToSign(request, HeaderConstants.RANGE)
        ].join("\n") +
            "\n" +
            this.getCanonicalizedHeadersString(request) +
            this.getCanonicalizedResourceString(request);
        var signature = this.factory.computeHMACSHA256(stringToSign);
        request.headers.set(HeaderConstants.AUTHORIZATION, "SharedKey " + this.factory.accountName + ":" + signature);
        // Workaround for https://github.com/axios/axios/issues/2107
        // We should always keep the 'content-length' header once the issue is solved
        // For a better explanation about this workaround, look here: https://github.com/Azure/azure-sdk-for-js/pull/3273
        if (typeof request.body !== "function" && !(request.body && request.onUploadProgress)) {
            request.headers.remove(HeaderConstants.CONTENT_LENGTH);
        }
        // Workaround for node-fetch which will set content-type for dfs append data operations based on Patch
        if (typeof request.body !== "function" && !request.headers.get(HeaderConstants.CONTENT_TYPE)) {
            request.headers.set(HeaderConstants.CONTENT_TYPE, "");
        }
        // console.log(`[URL]:${request.url}`);
        // console.log(`[HEADERS]:${request.headers.toString()}`);
        // console.log(`[STRING TO SIGN]:${JSON.stringify(stringToSign)}`);
        // console.log(`[KEY]: ${request.headers.get(HeaderConstants.AUTHORIZATION)}`);
        return request;
    };
    /**
     * Retrieve header value according to shared key sign rules.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/authenticate-with-shared-key
     *
     * @private
     * @param {WebResource} request
     * @param {string} headerName
     * @returns {string}
     * @memberof StorageSharedKeyCredentialPolicy
     */
    StorageSharedKeyCredentialPolicy.prototype.getHeaderValueToSign = function (request, headerName) {
        var value = request.headers.get(headerName);
        if (!value) {
            return "";
        }
        // When using version 2015-02-21 or later, if Content-Length is zero, then
        // set the Content-Length part of the StringToSign to an empty string.
        // https://docs.microsoft.com/en-us/rest/api/storageservices/authenticate-with-shared-key
        if (headerName === HeaderConstants.CONTENT_LENGTH && value === "0") {
            return "";
        }
        return value;
    };
    /**
     * To construct the CanonicalizedHeaders portion of the signature string, follow these steps:
     * 1. Retrieve all headers for the resource that begin with x-ms-, including the x-ms-date header.
     * 2. Convert each HTTP header name to lowercase.
     * 3. Sort the headers lexicographically by header name, in ascending order.
     *    Each header may appear only once in the string.
     * 4. Replace any linear whitespace in the header value with a single space.
     * 5. Trim any whitespace around the colon in the header.
     * 6. Finally, append a new-line character to each canonicalized header in the resulting list.
     *    Construct the CanonicalizedHeaders string by concatenating all headers in this list into a single string.
     *
     * @private
     * @param {WebResource} request
     * @returns {string}
     * @memberof StorageSharedKeyCredentialPolicy
     */
    StorageSharedKeyCredentialPolicy.prototype.getCanonicalizedHeadersString = function (request) {
        var headersArray = request.headers.headersArray().filter(function (value) {
            return value.name.toLowerCase().startsWith(HeaderConstants.PREFIX_FOR_STORAGE);
        });
        headersArray.sort(function (a, b) {
            return a.name.toLowerCase().localeCompare(b.name.toLowerCase());
        });
        // Remove duplicate headers
        headersArray = headersArray.filter(function (value, index, array) {
            if (index > 0 && value.name.toLowerCase() === array[index - 1].name.toLowerCase()) {
                return false;
            }
            return true;
        });
        var canonicalizedHeadersStringToSign = "";
        headersArray.forEach(function (header) {
            canonicalizedHeadersStringToSign += header.name
                .toLowerCase()
                .trimRight() + ":" + header.value.trimLeft() + "\n";
        });
        return canonicalizedHeadersStringToSign;
    };
    /**
     * Retrieves the webResource canonicalized resource string.
     *
     * @private
     * @param {WebResource} request
     * @returns {string}
     * @memberof StorageSharedKeyCredentialPolicy
     */
    StorageSharedKeyCredentialPolicy.prototype.getCanonicalizedResourceString = function (request) {
        var path = getURLPath(request.url) || "/";
        var canonicalizedResourceString = "";
        canonicalizedResourceString += "/" + this.factory.accountName + path;
        var queries = getURLQueries(request.url);
        var lowercaseQueries = {};
        if (queries) {
            var queryKeys = [];
            for (var key in queries) {
                if (queries.hasOwnProperty(key)) {
                    var lowercaseKey = key.toLowerCase();
                    lowercaseQueries[lowercaseKey] = queries[key];
                    queryKeys.push(lowercaseKey);
                }
            }
            queryKeys.sort();
            for (var _i = 0, queryKeys_1 = queryKeys; _i < queryKeys_1.length; _i++) {
                var key = queryKeys_1[_i];
                canonicalizedResourceString += "\n" + key + ":" + decodeURIComponent(lowercaseQueries[key]);
            }
        }
        return canonicalizedResourceString;
    };
    return StorageSharedKeyCredentialPolicy;
}(CredentialPolicy));

// Copyright (c) Microsoft Corporation. All rights reserved.
/**
 * ONLY AVAILABLE IN NODE.JS RUNTIME.
 *
 * StorageSharedKeyCredential for account key authorization of Azure Storage service.
 *
 * @export
 * @class StorageSharedKeyCredential
 * @extends {Credential}
 */
var StorageSharedKeyCredential = /** @class */ (function (_super) {
    tslib.__extends(StorageSharedKeyCredential, _super);
    /**
     * Creates an instance of StorageSharedKeyCredential.
     * @param {string} accountName
     * @param {string} accountKey
     * @memberof StorageSharedKeyCredential
     */
    function StorageSharedKeyCredential(accountName, accountKey) {
        var _this = _super.call(this) || this;
        _this.accountName = accountName;
        _this.accountKey = Buffer.from(accountKey, "base64");
        return _this;
    }
    /**
     * Creates a StorageSharedKeyCredentialPolicy object.
     *
     * @param {RequestPolicy} nextPolicy
     * @param {RequestPolicyOptions} options
     * @returns {StorageSharedKeyCredentialPolicy}
     * @memberof StorageSharedKeyCredential
     */
    StorageSharedKeyCredential.prototype.create = function (nextPolicy, options) {
        return new StorageSharedKeyCredentialPolicy(nextPolicy, options, this);
    };
    /**
     * Generates a hash signature for an HTTP request or for a SAS.
     *
     * @param {string} stringToSign
     * @returns {string}
     * @memberof StorageSharedKeyCredential
     */
    StorageSharedKeyCredential.prototype.computeHMACSHA256 = function (stringToSign) {
        return crypto.createHmac("sha256", this.accountKey)
            .update(stringToSign, "utf8")
            .digest("base64");
    };
    return StorageSharedKeyCredential;
}(Credential));

/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for
 * license information.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is
 * regenerated.
 */
var packageName = "azure-storage-datalake";
var packageVersion = "1.0.0";
var StorageClientContext = /** @class */ (function (_super) {
    tslib.__extends(StorageClientContext, _super);
    /**
     * Initializes a new instance of the StorageClientContext class.
     * @param url The URL of the service account, container, or blob that is the targe of the desired
     * operation.
     * @param [options] The parameter options
     */
    function StorageClientContext(url, options) {
        var _this = this;
        if (url == undefined) {
            throw new Error("'url' cannot be null.");
        }
        if (!options) {
            options = {};
        }
        if (!options.userAgent) {
            var defaultUserAgent = coreHttp.getDefaultUserAgentValue();
            options.userAgent = packageName + "/" + packageVersion + " " + defaultUserAgent;
        }
        _this = _super.call(this, undefined, options) || this;
        _this.resource = 'filesystem';
        _this.version = '2019-07-07';
        _this.baseUri = "{url}";
        _this.requestContentType = "application/json; charset=utf-8";
        _this.url = url;
        return _this;
    }
    return StorageClientContext;
}(coreHttp.ServiceClient));

/**
 * Get a blob endpoint URL from incoming blob or dfs endpoint URLs.
 * Only handle known host name pair patterns, add more patterns into ToBlobEndpointHostMappings in constants.ts.
 *
 * Expected input and outputs:
 * http://account.blob.core.windows.net     => http://account.blob.core.windows.net
 * http://account.dfs.core.windows.net      => http://account.blob.core.windows.net
 * http://127.0.0.1:10000                   => http://127.0.0.1:10000
 * http://account.blob.core.windows.net/abc => http://account.blob.core.windows.net/abc
 * http://account.dfs.core.windows.net/abc  => http://account.blob.core.windows.net/abc
 * http://127.0.0.1:10000/abc               => http://127.0.0.1:10000/abc
 *
 * @export
 * @param {string} url
 * @returns {string}
 */
function toBlobEndpointUrl(url) {
    var urlParsed = coreHttp.URLBuilder.parse(url);
    var host = urlParsed.getHost();
    if (host === undefined) {
        throw RangeError("toBlobEndpointUrl() parameter url " + url + " doesn't include valid host.");
    }
    for (var _i = 0, ToBlobEndpointHostMappings_1 = ToBlobEndpointHostMappings; _i < ToBlobEndpointHostMappings_1.length; _i++) {
        var mapping = ToBlobEndpointHostMappings_1[_i];
        if (host.includes(mapping[0])) {
            host = host.replace(mapping[0], mapping[1]);
            break;
        }
    }
    urlParsed.setHost(host);
    return urlParsed.toString();
}
/**
 * Get a dfs endpoint URL from incoming blob or dfs endpoint URLs.
 * Only handle known host name pair patterns, add more patterns into ToDfsEndpointHostMappings in constants.ts.
 *
 * Expected input and outputs:
 * http://account.blob.core.windows.net     => http://account.dfs.core.windows.net
 * http://account.dfs.core.windows.net      => http://account.dfs.core.windows.net
 * http://127.0.0.1:10000                   => http://127.0.0.1:10000
 * http://account.blob.core.windows.net/abc => http://account.dfs.core.windows.net/abc
 * http://account.dfs.core.windows.net/abc  => http://account.dfs.core.windows.net/abc
 * http://127.0.0.1:10000/abc               => http://127.0.0.1:10000/abc
 *
 * @export
 * @param {string} url
 * @returns {string}
 */
function toDfsEndpointUrl(url) {
    var urlParsed = coreHttp.URLBuilder.parse(url);
    var host = urlParsed.getHost();
    if (host === undefined) {
        throw RangeError("toDfsEndpointUrl() parameter url " + url + " doesn't include valid host.");
    }
    for (var _i = 0, ToDfsEndpointHostMappings_1 = ToDfsEndpointHostMappings; _i < ToDfsEndpointHostMappings_1.length; _i++) {
        var mapping = ToDfsEndpointHostMappings_1[_i];
        if (host.includes(mapping[0])) {
            host = host.replace(mapping[0], mapping[1]);
            break;
        }
    }
    urlParsed.setHost(host);
    return urlParsed.toString();
}
function toFileSystemAsyncIterableIterator(iter) {
    var _a;
    return _a = {
            next: function () {
                return tslib.__awaiter(this, void 0, void 0, function () {
                    var rawResult;
                    return tslib.__generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, iter.next()];
                            case 1:
                                rawResult = _a.sent();
                                if (rawResult.value) {
                                    rawResult.value.fileSystemItems = rawResult.value.containerItems.map(function (val) {
                                        return tslib.__assign(tslib.__assign({}, val), { properties: tslib.__assign(tslib.__assign({}, val.properties), { publicAccess: toPublicAccessType(val.properties.publicAccess) }) });
                                    });
                                }
                                return [2 /*return*/, rawResult];
                        }
                    });
                });
            }
        },
        _a[Symbol.asyncIterator] = function () {
            return this;
        },
        _a;
}
function toFileSystemPagedAsyncIterableIterator(iter) {
    var _a;
    return _a = {
            next: function () {
                return tslib.__awaiter(this, void 0, void 0, function () {
                    var rawResult, result;
                    return tslib.__generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, iter.next()];
                            case 1:
                                rawResult = _a.sent();
                                result = rawResult;
                                if (result.value) {
                                    result.value.properties.publicAccess = toPublicAccessType(rawResult.value.properties.publicAccess);
                                }
                                return [2 /*return*/, result];
                        }
                    });
                });
            }
        },
        _a[Symbol.asyncIterator] = function () {
            return this;
        },
        _a.byPage = function (settings) {
            if (settings === void 0) { settings = {}; }
            return toFileSystemAsyncIterableIterator(iter.byPage(settings));
        },
        _a;
}
function toContainerPublicAccessType(publicAccessType) {
    if (!publicAccessType) {
        return undefined;
    }
    switch (publicAccessType) {
        case "filesystem":
            return "container";
        case "file":
            return "blob";
        default:
            throw TypeError("toContainerPublicAccessType() parameter " + publicAccessType + " is not recognized.");
    }
}
function toPublicAccessType(containerPublicAccessType) {
    if (!containerPublicAccessType) {
        return undefined;
    }
    switch (containerPublicAccessType) {
        case "container":
            return "filesystem";
        case "blob":
            return "file";
        default:
            throw TypeError("toPublicAccessType() parameter " + containerPublicAccessType + " is not recognized.");
    }
}
function toProperties(metadata) {
    if (metadata === undefined) {
        return undefined;
    }
    var properties = [];
    for (var key in metadata) {
        if (metadata.hasOwnProperty(key)) {
            var value = metadata[key];
            properties.push(key + "=" + base64encode(value));
        }
    }
    return properties.join(",");
}
function toPathGetAccessControlResponse(response) {
    return tslib.__assign(tslib.__assign({}, response), { _response: response._response, permissions: toPermissions(response.permissions), acl: toAcl(response.acl) });
}
function toRolePermissions(permissionsString, allowStickyBit) {
    if (allowStickyBit === void 0) { allowStickyBit = false; }
    var error = new RangeError("toRolePermissions() Invalid role permissions string " + permissionsString);
    if (permissionsString.length !== 3) {
        throw error;
    }
    permissionsString = permissionsString.toLowerCase();
    var read = false;
    if (permissionsString[0] === "r") {
        read = true;
    }
    else if (permissionsString[0] !== "-") {
        throw error;
    }
    var write = false;
    if (permissionsString[1] === "w") {
        write = true;
    }
    else if (permissionsString[1] !== "-") {
        throw error;
    }
    var execute = false;
    if (permissionsString[2] === "x") {
        execute = true;
    }
    else if (allowStickyBit) {
        if (permissionsString[2] === "t") {
            execute = true;
        }
        else if (permissionsString[2] !== "-") {
            throw error;
        }
    }
    else if (permissionsString[2] !== "-") {
        throw error;
    }
    return { read: read, write: write, execute: execute };
}
function toPermissions(permissionsString) {
    if (permissionsString === undefined || permissionsString === "" || permissionsString === null) {
        return undefined;
    }
    if (permissionsString.length !== 9 && permissionsString.length !== 10) {
        throw RangeError("toPermissions() Invalid permissions string " + permissionsString);
    }
    // Case insensitive
    permissionsString = permissionsString.toLowerCase();
    var stickyBit = false;
    if (permissionsString[8] === "t") {
        stickyBit = true;
    }
    var extendedAcls = false;
    if (permissionsString.length === 10) {
        if (permissionsString[9] === "+") {
            extendedAcls = true;
        }
        else {
            throw RangeError("toPermissions() Invalid extendedAcls bit " + permissionsString[9] + " in permissions string " + permissionsString);
        }
    }
    var owner = toRolePermissions(permissionsString.substr(0, 3), false);
    var group = toRolePermissions(permissionsString.substr(3, 3), false);
    var other = toRolePermissions(permissionsString.substr(6, 3), true);
    return {
        owner: owner,
        group: group,
        other: other,
        stickyBit: stickyBit,
        extendedAcls: extendedAcls
    };
}
function toAccessControlItem(aclItemString) {
    var error = new RangeError("toAccessControlItem() Parameter access control item string " + aclItemString + " is not valid.");
    if (aclItemString === "") {
        throw error;
    }
    aclItemString = aclItemString.toLowerCase();
    var parts = aclItemString.split(":");
    if (parts.length < 3 || parts.length > 4) {
        throw error;
    }
    var defaultScope = false;
    var index = 0;
    if (parts.length === 4) {
        if (parts[index] !== "default") {
            throw error;
        }
        defaultScope = true;
        index++;
    }
    var accessControlType = parts[index++];
    if (accessControlType !== "user" &&
        accessControlType !== "group" &&
        accessControlType !== "mask" &&
        accessControlType !== "other") {
        throw error;
    }
    var entityId = parts[index++];
    var permissions = toRolePermissions(parts[index++]);
    return {
        defaultScope: defaultScope,
        accessControlType: accessControlType,
        entityId: entityId,
        permissions: permissions
    };
}
function toAcl(aclString) {
    if (aclString === undefined || aclString === "" || aclString === null) {
        return [];
    }
    var acls = [];
    var aclParts = aclString.split(",");
    for (var _i = 0, aclParts_1 = aclParts; _i < aclParts_1.length; _i++) {
        var aclPart = aclParts_1[_i];
        acls.push(toAccessControlItem(aclPart));
    }
    return acls;
}
function toAccessControlItemString(item) {
    return "" + (item.defaultScope ? "default:" : "") + item.accessControlType + ":" + item.entityId + ":" + toRolePermissionsString(item.permissions);
}
function toAclString(acl) {
    return acl.map(toAccessControlItemString).join(",");
}
function toRolePermissionsString(p, stickyBit) {
    if (stickyBit === void 0) { stickyBit = false; }
    return "" + (p.read ? "r" : "-") + (p.write ? "w" : "-") + (stickyBit ? "t" : p.execute ? "x" : "-");
}
function toPermissionsString(permissions) {
    return "" + toRolePermissionsString(permissions.owner) + toRolePermissionsString(permissions.group) + toRolePermissionsString(permissions.other, permissions.stickyBit) + (permissions.extendedAcls ? "+" : "");
}

// Copyright (c) Microsoft Corporation. All rights reserved.
/**
 * A StorageClient represents a based URL class for {@link BlobServiceClient}, {@link ContainerClient}
 * and etc.
 *
 * @export
 * @class StorageClient
 */
var StorageClient = /** @class */ (function () {
    /**
     * Creates an instance of StorageClient.
     * @param {string} url url to resource
     * @param {Pipeline} pipeline request policy pipeline.
     * @memberof StorageClient
     */
    function StorageClient(url, pipeline) {
        // URL should be encoded and only once, protocol layer shouldn't encode URL again
        this.url = escapeURLPath(url);
        this.blobEndpointUrl = toBlobEndpointUrl(this.url);
        this.dfsEndpointUrl = toDfsEndpointUrl(this.url);
        this.accountName = getAccountNameFromUrl(this.blobEndpointUrl);
        this.pipeline = pipeline;
        this.storageClientContext = new StorageClientContext(this.dfsEndpointUrl, pipeline.toServiceClientOptions());
        this.isHttps = iEqual(getURLScheme(this.url) || "", "https");
        this.credential = new AnonymousCredential();
        for (var _i = 0, _a = this.pipeline.factories; _i < _a.length; _i++) {
            var factory = _a[_i];
            if ((coreHttp.isNode && factory instanceof StorageSharedKeyCredential) ||
                factory instanceof AnonymousCredential ||
                coreHttp.isTokenCredential(factory)) {
                this.credential = factory;
            }
        }
        // Override protocol layer's default content-type
        var storageClientContext = this.storageClientContext;
        storageClientContext.requestContentType = undefined;
    }
    return StorageClient;
}());

/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
(function (PathResourceType) {
    PathResourceType["Directory"] = "directory";
    PathResourceType["File"] = "file";
})(exports.PathResourceType || (exports.PathResourceType = {}));
(function (PathRenameMode) {
    PathRenameMode["Legacy"] = "legacy";
    PathRenameMode["Posix"] = "posix";
})(exports.PathRenameMode || (exports.PathRenameMode = {}));
/**
 * Defines values for PathUpdateAction.
 * Possible values include: 'append', 'flush', 'setProperties', 'setAccessControl'
 * @readonly
 * @enum {string}
 */
var PathUpdateAction;
(function (PathUpdateAction) {
    PathUpdateAction["Append"] = "append";
    PathUpdateAction["Flush"] = "flush";
    PathUpdateAction["SetProperties"] = "setProperties";
    PathUpdateAction["SetAccessControl"] = "setAccessControl";
})(PathUpdateAction || (PathUpdateAction = {}));
/**
 * Defines values for PathLeaseAction.
 * Possible values include: 'acquire', 'break', 'change', 'renew', 'release'
 * @readonly
 * @enum {string}
 */
var PathLeaseAction;
(function (PathLeaseAction) {
    PathLeaseAction["Acquire"] = "acquire";
    PathLeaseAction["Break"] = "break";
    PathLeaseAction["Change"] = "change";
    PathLeaseAction["Renew"] = "renew";
    PathLeaseAction["Release"] = "release";
})(PathLeaseAction || (PathLeaseAction = {}));
(function (PathGetPropertiesAction) {
    PathGetPropertiesAction["GetAccessControl"] = "getAccessControl";
    PathGetPropertiesAction["GetStatus"] = "getStatus";
})(exports.PathGetPropertiesAction || (exports.PathGetPropertiesAction = {}));

// Copyright (c) Microsoft Corporation.
var _defaultHttpClient = new coreHttp.DefaultHttpClient();
function getCachedDefaultHttpClient() {
    return _defaultHttpClient;
}

/**
 * A DataLakePathClient represents a URL to the Azure Storage path (directory or file).
 *
 * @export
 * @class DataLakePathClient
 * @extends {StorageClient}
 */
var DataLakePathClient = /** @class */ (function (_super) {
    tslib.__extends(DataLakePathClient, _super);
    function DataLakePathClient(url, credentialOrPipeline, options) {
        var _this = this;
        // when options.httpClient is not specified, passing in a DefaultHttpClient instance to
        // avoid each client creating its own http client.
        var newOptions = tslib.__assign({ httpClient: getCachedDefaultHttpClient() }, options);
        if (credentialOrPipeline instanceof Pipeline) {
            _this = _super.call(this, url, credentialOrPipeline) || this;
        }
        else {
            var credential = void 0;
            if (credentialOrPipeline === undefined) {
                credential = new AnonymousCredential();
            }
            else {
                credential = credentialOrPipeline;
            }
            var pipeline = newPipeline(credential, newOptions);
            _this = _super.call(this, url, pipeline) || this;
        }
        _this.pathContext = new PathOperations(_this.storageClientContext);
        _this.blobClient = new storageBlob.BlobClient(_this.blobEndpointUrl, _this.pipeline);
        return _this;
    }
    Object.defineProperty(DataLakePathClient.prototype, "fileSystemName", {
        /**
         * Name of current file system.
         *
         * @readonly
         * @type {string}
         * @memberof DataLakePathClient
         */
        get: function () {
            return this.blobClient.containerName;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DataLakePathClient.prototype, "name", {
        /**
         * Name of current path (directory or file).
         *
         * @readonly
         * @type {string}
         * @memberof DataLakePathClient
         */
        get: function () {
            return this.blobClient.name;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Convert current DataLakePathClient to DataLakeDirectoryClient if current path is a directory.
     *
     * @returns {DataLakeDirectoryClient}
     * @memberof DataLakePathClient
     */
    DataLakePathClient.prototype.toDirectoryClient = function () {
        return new DataLakeDirectoryClient(this.dfsEndpointUrl, this.pipeline);
    };
    /**
     * Convert current DataLakePathClient to DataLakeFileClient if current path is a file.
     *
     * @returns {DataLakeFileClient}
     * @memberof DataLakePathClient
     */
    DataLakePathClient.prototype.toFileClient = function () {
        return new DataLakeFileClient(this.dfsEndpointUrl, this.pipeline);
    };
    /**
     * Get a {@link DataLakeLeaseClient} that manages leases on the path (directory or file).
     *
     * @param {string} [proposeLeaseId] Optional. Initial proposed lease Id.
     * @returns {DataLakeLeaseClient}
     * @memberof DataLakePathClient
     */
    DataLakePathClient.prototype.getDataLakeLeaseClient = function (proposeLeaseId) {
        return new DataLakeLeaseClient(this.blobClient.getBlobLeaseClient(proposeLeaseId));
    };
    /**
     * Create a directory or path.
     *
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/datalakestoragegen2/path/create
     *
     * @param {PathResourceType} resourceType Resource type, "directory" or "file".
     * @param {PathCreateOptions} [options={}] Optional. Options when creating path.
     * @returns {Promise<PathCreateResponse>}
     * @memberof DataLakePathClient
     */
    DataLakePathClient.prototype.create = function (resourceType, options) {
        if (options === void 0) { options = {}; }
        return tslib.__awaiter(this, void 0, void 0, function () {
            var _a, span, spanOptions, e_1;
            return tslib.__generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        options.conditions = options.conditions || {};
                        _a = createSpan("DataLakePathClient-create", options.tracingOptions), span = _a.span, spanOptions = _a.spanOptions;
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 3, 4, 5]);
                        return [4 /*yield*/, this.pathContext.create(tslib.__assign(tslib.__assign({}, options), { resource: resourceType, leaseAccessConditions: options.conditions, modifiedAccessConditions: options.conditions, properties: toProperties(options.metadata), spanOptions: spanOptions }))];
                    case 2: return [2 /*return*/, _b.sent()];
                    case 3:
                        e_1 = _b.sent();
                        span.setStatus({
                            code: src_1.UNKNOWN,
                            message: e_1.message
                        });
                        throw e_1;
                    case 4:
                        span.end();
                        return [7 /*endfinally*/];
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Delete current path (directory or file).
     *
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/datalakestoragegen2/path/delete
     *
     * @param {boolean} [recursive] Required and valid only when the resource is a directory. If "true", all paths beneath the directory will be deleted.
     * @param {PathDeleteOptions} [options={}] Optional. Options when deleting path.
     * @returns {Promise<PathDeleteResponse>}
     * @memberof DataLakePathClient
     */
    DataLakePathClient.prototype.delete = function (recursive, options) {
        if (options === void 0) { options = {}; }
        return tslib.__awaiter(this, void 0, void 0, function () {
            var _a, span, spanOptions, continuation, response, e_2;
            return tslib.__generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        options.conditions = options.conditions || {};
                        _a = createSpan("DataLakePathClient-delete", options.tracingOptions), span = _a.span, spanOptions = _a.spanOptions;
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 6, 7, 8]);
                        continuation = void 0;
                        response = void 0;
                        _b.label = 2;
                    case 2: return [4 /*yield*/, this.pathContext.deleteMethod({
                            continuation: continuation,
                            recursive: recursive,
                            leaseAccessConditions: options.conditions,
                            modifiedAccessConditions: options.conditions,
                            spanOptions: spanOptions
                        })];
                    case 3:
                        response = _b.sent();
                        continuation = response.continuation;
                        _b.label = 4;
                    case 4:
                        if (continuation !== undefined && continuation !== "") return [3 /*break*/, 2];
                        _b.label = 5;
                    case 5: return [2 /*return*/, response];
                    case 6:
                        e_2 = _b.sent();
                        span.setStatus({
                            code: src_1.UNKNOWN,
                            message: e_2.message
                        });
                        throw e_2;
                    case 7:
                        span.end();
                        return [7 /*endfinally*/];
                    case 8: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Returns the access control data for a path (directory of file).
     *
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/datalakestoragegen2/path/getproperties
     *
     * @param {PathGetAccessControlOptions} [options={}] Optional. Options when getting file access control.
     * @returns {Promise<PathGetAccessControlResponse>}
     * @memberof DataLakePathClient
     */
    DataLakePathClient.prototype.getAccessControl = function (options) {
        if (options === void 0) { options = {}; }
        return tslib.__awaiter(this, void 0, void 0, function () {
            var _a, span, spanOptions, response, e_3;
            return tslib.__generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        options.conditions = options.conditions || {};
                        _a = createSpan("DataLakePathClient-getAccessControl", options.tracingOptions), span = _a.span, spanOptions = _a.spanOptions;
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 3, 4, 5]);
                        return [4 /*yield*/, this.pathContext.getProperties({
                                action: exports.PathGetPropertiesAction.GetAccessControl,
                                upn: options.userPrincipalName,
                                leaseAccessConditions: options.conditions,
                                modifiedAccessConditions: options.conditions,
                                spanOptions: spanOptions
                            })];
                    case 2:
                        response = _b.sent();
                        return [2 /*return*/, toPathGetAccessControlResponse(response)];
                    case 3:
                        e_3 = _b.sent();
                        span.setStatus({
                            code: src_1.UNKNOWN,
                            message: e_3.message
                        });
                        throw e_3;
                    case 4:
                        span.end();
                        return [7 /*endfinally*/];
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Set the access control data for a path (directory of file).
     *
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/datalakestoragegen2/path/update
     *
     * @param {PathAccessControlItem[]} acl The POSIX access control list for the file or directory.
     * @param {PathSetAccessControlOptions} [options={}] Optional. Options when setting path access control.
     * @returns {Promise<PathSetAccessControlResponse>}
     * @memberof DataLakePathClient
     */
    DataLakePathClient.prototype.setAccessControl = function (acl, options) {
        if (options === void 0) { options = {}; }
        return tslib.__awaiter(this, void 0, void 0, function () {
            var _a, span, spanOptions, e_4;
            return tslib.__generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        options.conditions = options.conditions || {};
                        _a = createSpan("DataLakePathClient-setAccessControl", options.tracingOptions), span = _a.span, spanOptions = _a.spanOptions;
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 3, 4, 5]);
                        return [4 /*yield*/, this.pathContext.setAccessControl(tslib.__assign(tslib.__assign({}, options), { acl: toAclString(acl), leaseAccessConditions: options.conditions, modifiedAccessConditions: options.conditions, spanOptions: spanOptions }))];
                    case 2: return [2 /*return*/, _b.sent()];
                    case 3:
                        e_4 = _b.sent();
                        span.setStatus({
                            code: src_1.UNKNOWN,
                            message: e_4.message
                        });
                        throw e_4;
                    case 4:
                        span.end();
                        return [7 /*endfinally*/];
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Sets the file permissions on a path.
     *
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/datalakestoragegen2/path/update
     *
     * @param {PathPermissions} permissions The POSIX access permissions for the file owner, the file owning group, and others.
     * @param {PathSetPermissionsOptions} [options={}] Optional. Options when setting path permissions.
     * @returns {Promise<PathSetPermissionsResponse>}
     * @memberof DataLakePathClient
     */
    DataLakePathClient.prototype.setPermissions = function (permissions, options) {
        if (options === void 0) { options = {}; }
        return tslib.__awaiter(this, void 0, void 0, function () {
            var _a, span, spanOptions, e_5;
            return tslib.__generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        options.conditions = options.conditions || {};
                        _a = createSpan("DataLakePathClient-setPermissions", options.tracingOptions), span = _a.span, spanOptions = _a.spanOptions;
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 3, 4, 5]);
                        return [4 /*yield*/, this.pathContext.setAccessControl(tslib.__assign(tslib.__assign({}, options), { permissions: toPermissionsString(permissions), leaseAccessConditions: options.conditions, modifiedAccessConditions: options.conditions, spanOptions: spanOptions }))];
                    case 2: return [2 /*return*/, _b.sent()];
                    case 3:
                        e_5 = _b.sent();
                        span.setStatus({
                            code: src_1.UNKNOWN,
                            message: e_5.message
                        });
                        throw e_5;
                    case 4:
                        span.end();
                        return [7 /*endfinally*/];
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Returns all user-defined metadata, standard HTTP properties, and system properties
     * for the path (directory or file).
     *
     * WARNING: The `metadata` object returned in the response will have its keys in lowercase, even if
     * they originally contained uppercase characters. This differs from the metadata keys returned by
     * the methods of {@link DataLakeFileSystemClient} that list paths using the `includeMetadata` option, which
     * will retain their original casing.
     *
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/get-blob-properties
     *
     * @param {PathGetPropertiesOptions} [options={}] Optional. Options when getting path properties.
     * @returns {Promise<PathGetPropertiesResponse>}
     * @memberof DataLakePathClient
     */
    DataLakePathClient.prototype.getProperties = function (options) {
        if (options === void 0) { options = {}; }
        return tslib.__awaiter(this, void 0, void 0, function () {
            var _a, span, spanOptions, e_6;
            return tslib.__generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = createSpan("DataLakePathClient-getProperties", options.tracingOptions), span = _a.span, spanOptions = _a.spanOptions;
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 3, 4, 5]);
                        return [4 /*yield*/, this.blobClient.getProperties(tslib.__assign(tslib.__assign({}, options), { customerProvidedKey: undefined, tracingOptions: tslib.__assign(tslib.__assign({}, options.tracingOptions), { spanOptions: spanOptions }) }))];
                    case 2: return [2 /*return*/, _b.sent()];
                    case 3:
                        e_6 = _b.sent();
                        span.setStatus({
                            code: src_1.UNKNOWN,
                            message: e_6.message
                        });
                        throw e_6;
                    case 4:
                        span.end();
                        return [7 /*endfinally*/];
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Sets system properties on the path (directory or file).
     *
     * If no value provided, or no value provided for the specified blob HTTP headers,
     * these blob HTTP headers without a value will be cleared.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/set-blob-properties
     *
     * @param {PathHttpHeaders} httpHeaders
     * @param {PathSetHttpHeadersOptions} [options={}]
     * @returns {Promise<PathSetHttpHeadersResponse>}
     * @memberof DataLakePathClient
     */
    DataLakePathClient.prototype.setHttpHeaders = function (httpHeaders, options) {
        if (options === void 0) { options = {}; }
        return tslib.__awaiter(this, void 0, void 0, function () {
            var _a, span, spanOptions, e_7;
            return tslib.__generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = createSpan("DataLakePathClient-setHttpHeaders", options.tracingOptions), span = _a.span, spanOptions = _a.spanOptions;
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 3, 4, 5]);
                        return [4 /*yield*/, this.blobClient.setHTTPHeaders({
                                blobCacheControl: httpHeaders.cacheControl,
                                blobContentType: httpHeaders.contentType,
                                blobContentMD5: httpHeaders.contentMD5,
                                blobContentEncoding: httpHeaders.contentEncoding,
                                blobContentLanguage: httpHeaders.contentLanguage,
                                blobContentDisposition: httpHeaders.contentDisposition
                            }, tslib.__assign(tslib.__assign({}, options), { tracingOptions: tslib.__assign(tslib.__assign({}, options.tracingOptions), { spanOptions: spanOptions }) }))];
                    case 2: return [2 /*return*/, _b.sent()];
                    case 3:
                        e_7 = _b.sent();
                        span.setStatus({
                            code: src_1.UNKNOWN,
                            message: e_7.message
                        });
                        throw e_7;
                    case 4:
                        span.end();
                        return [7 /*endfinally*/];
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Sets user-defined metadata for the specified path (directory of file) as one or more name-value pairs.
     *
     * If no option provided, or no metadata defined in the parameter, the path
     * metadata will be removed.
     *
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/set-blob-metadata
     *
     * @param {Metadata} [metadata] Optional. Replace existing metadata with this value.
     *                              If no value provided the existing metadata will be removed.
     * @param {PathSetMetadataOptions} [options={}] Optional. Options when setting path metadata.
     * @returns {Promise<PathSetMetadataResponse>}
     * @memberof DataLakePathClient
     */
    DataLakePathClient.prototype.setMetadata = function (metadata, options) {
        if (options === void 0) { options = {}; }
        return tslib.__awaiter(this, void 0, void 0, function () {
            var _a, span, spanOptions, e_8;
            return tslib.__generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = createSpan("DataLakePathClient-setMetadata", options.tracingOptions), span = _a.span, spanOptions = _a.spanOptions;
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 3, 4, 5]);
                        return [4 /*yield*/, this.blobClient.setMetadata(metadata, tslib.__assign(tslib.__assign({}, options), { customerProvidedKey: undefined, tracingOptions: tslib.__assign(tslib.__assign({}, options.tracingOptions), { spanOptions: spanOptions }) }))];
                    case 2: return [2 /*return*/, _b.sent()];
                    case 3:
                        e_8 = _b.sent();
                        span.setStatus({
                            code: src_1.UNKNOWN,
                            message: e_8.message
                        });
                        throw e_8;
                    case 4:
                        span.end();
                        return [7 /*endfinally*/];
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    DataLakePathClient.prototype.move = function (destinationPathOrFileSystem, destinationPathOrOptions, options) {
        return tslib.__awaiter(this, void 0, void 0, function () {
            var destinationFileSystem, destinationPath, _a, span, spanOptions, renameSource, renameDestination, destinationUrl, destPathClient, e_9;
            return tslib.__generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        destinationFileSystem = this.fileSystemName;
                        destinationPath = destinationPathOrFileSystem;
                        if (typeof destinationPathOrOptions === "string") {
                            destinationFileSystem = destinationPathOrFileSystem;
                            destinationPath = destinationPathOrOptions;
                            options = options || {};
                        }
                        else {
                            options = destinationPathOrOptions || {};
                        }
                        options.conditions = options.conditions || {};
                        options.destinationConditions = options.destinationConditions || {};
                        _a = createSpan("DataLakePathClient-move", options.tracingOptions), span = _a.span, spanOptions = _a.spanOptions;
                        renameSource = "/" + this.fileSystemName + "/" + this.name;
                        renameDestination = "/" + destinationFileSystem + "/" + destinationPath;
                        destinationUrl = setURLPath(this.dfsEndpointUrl, renameDestination);
                        destPathClient = new DataLakePathClient(destinationUrl, this.pipeline);
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 3, 4, 5]);
                        return [4 /*yield*/, destPathClient.pathContext.create({
                                mode: exports.PathRenameMode.Legacy,
                                renameSource: renameSource,
                                sourceLeaseId: options.conditions.leaseId,
                                leaseAccessConditions: options.destinationConditions,
                                sourceModifiedAccessConditions: {
                                    sourceIfMatch: options.conditions.ifMatch,
                                    sourceIfNoneMatch: options.conditions.ifNoneMatch,
                                    sourceIfModifiedSince: options.conditions.ifModifiedSince,
                                    sourceIfUnmodifiedSince: options.conditions.ifUnmodifiedSince
                                },
                                modifiedAccessConditions: options.destinationConditions,
                                spanOptions: spanOptions
                            })];
                    case 2: return [2 /*return*/, _b.sent()];
                    case 3:
                        e_9 = _b.sent();
                        span.setStatus({
                            code: src_1.UNKNOWN,
                            message: e_9.message
                        });
                        throw e_9;
                    case 4:
                        span.end();
                        return [7 /*endfinally*/];
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    return DataLakePathClient;
}(StorageClient));
/**
 * A DataLakeDirectoryClient represents a URL to the Azure Storage directory.
 *
 * @export
 * @class DataLakeDirectoryClient
 * @extends {DataLakePathClient}
 */
var DataLakeDirectoryClient = /** @class */ (function (_super) {
    tslib.__extends(DataLakeDirectoryClient, _super);
    function DataLakeDirectoryClient() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    DataLakeDirectoryClient.prototype.create = function (resourceTypeOrOptions, options) {
        if (options === void 0) { options = {}; }
        return tslib.__awaiter(this, void 0, void 0, function () {
            var _a, span, spanOptions, e_10;
            return tslib.__generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        if (resourceTypeOrOptions === exports.PathResourceType.Directory) {
                            return [2 /*return*/, _super.prototype.create.call(this, resourceTypeOrOptions, options)];
                        }
                        if (resourceTypeOrOptions === exports.PathResourceType.File) {
                            throw TypeError("DataLakeDirectoryClient:create() resourceType cannot be " + exports.PathResourceType.File + ". Refer to DataLakeFileClient for file creation.");
                        }
                        options = resourceTypeOrOptions || {};
                        options.conditions = options.conditions || {};
                        _a = createSpan("DataLakeDirectoryClient-create", options.tracingOptions), span = _a.span, spanOptions = _a.spanOptions;
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 3, 4, 5]);
                        return [4 /*yield*/, _super.prototype.create.call(this, exports.PathResourceType.Directory, tslib.__assign(tslib.__assign({}, options), { tracingOptions: tslib.__assign(tslib.__assign({}, options.tracingOptions), { spanOptions: spanOptions }) }))];
                    case 2: return [2 /*return*/, _b.sent()];
                    case 3:
                        e_10 = _b.sent();
                        span.setStatus({
                            code: src_1.UNKNOWN,
                            message: e_10.message
                        });
                        throw e_10;
                    case 4:
                        span.end();
                        return [7 /*endfinally*/];
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Creates a {@link DataLakeDirectoryClient} object under current directory.
     *
     * @param {string} subdirectoryName Subdirectory name.
     * @returns {DataLakeDirectoryClient}
     * @memberof DataLakeDirectoryClient
     */
    DataLakeDirectoryClient.prototype.getSubdirectoryClient = function (subdirectoryName) {
        return new DataLakeDirectoryClient(appendToURLPath(this.url, encodeURIComponent(subdirectoryName)), this.pipeline);
    };
    /**
     * Creates a {@link DataLakeFileClient} object under current directory.
     *
     * @param {string} fileName
     * @returns {DataLakeFileClient}
     * @memberof DataLakeDirectoryClient
     */
    DataLakeDirectoryClient.prototype.getFileClient = function (fileName) {
        return new DataLakeFileClient(appendToURLPath(this.url, encodeURIComponent(fileName)), this.pipeline);
    };
    return DataLakeDirectoryClient;
}(DataLakePathClient));
/**
 * A DataLakeFileClient represents a URL to the Azure Storage file.
 *
 * @export
 * @class DataLakeFileClient
 * @extends {DataLakePathClient}
 */
var DataLakeFileClient = /** @class */ (function (_super) {
    tslib.__extends(DataLakeFileClient, _super);
    function DataLakeFileClient(url, credentialOrPipeline, options) {
        var _this = this;
        if (credentialOrPipeline instanceof Pipeline) {
            _this = _super.call(this, url, credentialOrPipeline) || this;
        }
        else {
            var credential = void 0;
            if (credentialOrPipeline === undefined) {
                credential = new AnonymousCredential();
            }
            else {
                credential = credentialOrPipeline;
            }
            var pipeline = newPipeline(credential, options);
            _this = _super.call(this, url, pipeline) || this;
        }
        _this.pathContextInternal = new PathOperations(_this.storageClientContext);
        _this.blobClientInternal = new storageBlob.BlobClient(_this.blobEndpointUrl, _this.pipeline);
        return _this;
    }
    DataLakeFileClient.prototype.create = function (resourceTypeOrOptions, options) {
        if (options === void 0) { options = {}; }
        return tslib.__awaiter(this, void 0, void 0, function () {
            var _a, span, spanOptions, e_11;
            return tslib.__generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        if (resourceTypeOrOptions === exports.PathResourceType.File) {
                            return [2 /*return*/, _super.prototype.create.call(this, resourceTypeOrOptions, options)];
                        }
                        if (resourceTypeOrOptions === exports.PathResourceType.Directory) {
                            throw TypeError("DataLakeFileClient:create() resourceType cannot be " + exports.PathResourceType.Directory + ". Refer to DataLakeDirectoryClient for directory creation.");
                        }
                        options = resourceTypeOrOptions || {};
                        options.conditions = options.conditions || {};
                        _a = createSpan("DataLakeFileClient-create", options.tracingOptions), span = _a.span, spanOptions = _a.spanOptions;
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 3, 4, 5]);
                        return [4 /*yield*/, _super.prototype.create.call(this, exports.PathResourceType.File, tslib.__assign(tslib.__assign({}, options), { tracingOptions: tslib.__assign(tslib.__assign({}, options.tracingOptions), { spanOptions: spanOptions }) }))];
                    case 2: return [2 /*return*/, _b.sent()];
                    case 3:
                        e_11 = _b.sent();
                        span.setStatus({
                            code: src_1.UNKNOWN,
                            message: e_11.message
                        });
                        throw e_11;
                    case 4:
                        span.end();
                        return [7 /*endfinally*/];
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Downloads a file from the service, including its metadata and properties.
     *
     * * In Node.js, data returns in a Readable stream readableStreamBody
     * * In browsers, data returns in a promise contentAsBlob
     *
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/get-blob
     *
     * * Example usage (Node.js):
     *
     * ```js
     * // Download and convert a file to a string
     * const downloadResponse = await fileClient.read();
     * const downloaded = await streamToString(downloadResponse.readableStreamBody);
     * console.log("Downloaded file content:", downloaded);
     *
     * async function streamToString(readableStream) {
     *   return new Promise((resolve, reject) => {
     *     const chunks = [];
     *     readableStream.on("data", (data) => {
     *       chunks.push(data.toString());
     *     });
     *     readableStream.on("end", () => {
     *       resolve(chunks.join(""));
     *     });
     *     readableStream.on("error", reject);
     *   });
     * }
     * ```
     *
     * Example usage (browser):
     *
     * ```js
     * // Download and convert a file to a string
     * const downloadResponse = await fileClient.read();
     * const downloaded = await blobToString(await downloadResponse.contentAsBlob);
     * console.log("Downloaded file content", downloaded);
     *
     * async function blobToString(blob: Blob): Promise<string> {
     *   const fileReader = new FileReader();
     *   return new Promise<string>((resolve, reject) => {
     *     fileReader.onloadend = (ev: any) => {
     *       resolve(ev.target!.result);
     *     };
     *     fileReader.onerror = reject;
     *     fileReader.readAsText(blob);
     *   });
     * }
     * ```
     *
     * @param {number} [offset=0] Optional. Offset to read file, default value is 0.
     * @param {number} [count] Optional. How many bytes to read, default will read from offset to the end.
     * @param {FileReadOptions} [options={}] Optional. Options when reading file.
     * @returns {Promise<FileReadResponse>}
     * @memberof DataLakeFileClient
     */
    DataLakeFileClient.prototype.read = function (offset, count, options) {
        if (offset === void 0) { offset = 0; }
        if (options === void 0) { options = {}; }
        return tslib.__awaiter(this, void 0, void 0, function () {
            var _a, span, spanOptions, rawResponse, response, e_12;
            return tslib.__generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = createSpan("DataLakeFileClient-read", options.tracingOptions), span = _a.span, spanOptions = _a.spanOptions;
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 3, 4, 5]);
                        return [4 /*yield*/, this.blobClientInternal.download(offset, count, tslib.__assign(tslib.__assign({}, options), { tracingOptions: tslib.__assign(tslib.__assign({}, options.tracingOptions), { spanOptions: spanOptions }) }))];
                    case 2:
                        rawResponse = _b.sent();
                        response = rawResponse;
                        if (!coreHttp.isNode && !response.contentAsBlob) {
                            response.contentAsBlob = rawResponse.blobBody;
                        }
                        response.fileContentMD5 = rawResponse.blobContentMD5;
                        response._response.parsedHeaders.fileContentMD5 =
                            rawResponse._response.parsedHeaders.blobContentMD5;
                        delete rawResponse.blobContentMD5;
                        delete rawResponse._response.parsedHeaders.blobContentMD5;
                        return [2 /*return*/, response];
                    case 3:
                        e_12 = _b.sent();
                        span.setStatus({
                            code: src_1.UNKNOWN,
                            message: e_12.message
                        });
                        throw e_12;
                    case 4:
                        span.end();
                        return [7 /*endfinally*/];
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Uploads data to be appended to a file. Data can only be appended to a file.
     * To apply perviously uploaded data to a file, call flush.
     *
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/datalakestoragegen2/path/update
     *
     * @param {HttpRequestBody} body Content to be uploaded.
     * @param {number} offset Append offset in bytes.
     * @param {number} length Length of content to append.
     * @param {FileAppendOptions} [options={}] Optional. Options when appending data.
     * @returns {Promise<FileAppendResponse>}
     * @memberof DataLakeFileClient
     */
    DataLakeFileClient.prototype.append = function (body, offset, length, options) {
        if (options === void 0) { options = {}; }
        return tslib.__awaiter(this, void 0, void 0, function () {
            var _a, span, spanOptions, e_13;
            return tslib.__generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        options.conditions = options.conditions || {};
                        _a = createSpan("DataLakeFileClient-append", options.tracingOptions), span = _a.span, spanOptions = _a.spanOptions;
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 3, 4, 5]);
                        return [4 /*yield*/, this.pathContextInternal.appendData(body, {
                                pathHttpHeaders: {
                                    contentMD5: options.transactionalContentMD5
                                },
                                position: offset,
                                contentLength: length,
                                leaseAccessConditions: options.conditions,
                                onUploadProgress: options.onProgress,
                                spanOptions: spanOptions
                            })];
                    case 2: return [2 /*return*/, _b.sent()];
                    case 3:
                        e_13 = _b.sent();
                        span.setStatus({
                            code: src_1.UNKNOWN,
                            message: e_13.message
                        });
                        throw e_13;
                    case 4:
                        span.end();
                        return [7 /*endfinally*/];
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Flushes (writes) previously appended data to a file.
     *
     * @param {number} position File position to flush.
     *                          This parameter allows the caller to upload data in parallel and control the order in which it is appended to the file.
     *                          It is required when uploading data to be appended to the file and when flushing previously uploaded data to the file.
     *                          The value must be the position where the data is to be appended. Uploaded data is not immediately flushed, or written,
     *                          to the file. To flush, the previously uploaded data must be contiguous, the position parameter must be specified and
     *                          equal to the length of the file after all data has been written, and there must not be a request entity body included
     *                          with the request.
     * @param {FileFlushOptions} [options={}] Optional. Options when flushing data.
     * @returns {Promise<FileFlushResponse>}
     * @memberof DataLakeFileClient
     */
    DataLakeFileClient.prototype.flush = function (position, options) {
        if (options === void 0) { options = {}; }
        return tslib.__awaiter(this, void 0, void 0, function () {
            var _a, span, spanOptions, e_14;
            return tslib.__generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        options.conditions = options.conditions || {};
                        _a = createSpan("DataLakeFileClient-flush", options.tracingOptions), span = _a.span, spanOptions = _a.spanOptions;
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 3, 4, 5]);
                        return [4 /*yield*/, this.pathContextInternal.flushData(tslib.__assign(tslib.__assign({}, options), { position: position, contentLength: 0, leaseAccessConditions: options.conditions, modifiedAccessConditions: options.conditions, spanOptions: spanOptions }))];
                    case 2: return [2 /*return*/, _b.sent()];
                    case 3:
                        e_14 = _b.sent();
                        span.setStatus({
                            code: src_1.UNKNOWN,
                            message: e_14.message
                        });
                        throw e_14;
                    case 4:
                        span.end();
                        return [7 /*endfinally*/];
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    return DataLakeFileClient;
}(DataLakePathClient));

/**
 * A DataLakeFileSystemClient represents a URL to the Azure Storage file system
 * allowing you to manipulate its directories and files.
 *
 * @export
 * @class DataLakeFileSystemClient
 * @extends {StorageClient}
 */
var DataLakeFileSystemClient = /** @class */ (function (_super) {
    tslib.__extends(DataLakeFileSystemClient, _super);
    function DataLakeFileSystemClient(url, credentialOrPipeline, options) {
        var _this = this;
        // when options.httpClient is not specified, passing in a DefaultHttpClient instance to
        // avoid each client creating its own http client.
        var newOptions = tslib.__assign({ httpClient: getCachedDefaultHttpClient() }, options);
        if (credentialOrPipeline instanceof Pipeline) {
            _this = _super.call(this, url, credentialOrPipeline) || this;
        }
        else {
            var credential = void 0;
            if (credentialOrPipeline === undefined) {
                credential = new AnonymousCredential();
            }
            else {
                credential = credentialOrPipeline;
            }
            var pipeline = newPipeline(credential, newOptions);
            _this = _super.call(this, url, pipeline) || this;
        }
        _this.fileSystemContext = new FileSystemOperations(_this.storageClientContext);
        _this.blobContainerClient = new storageBlob.ContainerClient(_this.blobEndpointUrl, _this.pipeline);
        return _this;
    }
    Object.defineProperty(DataLakeFileSystemClient.prototype, "name", {
        /**
         * Name of current file system.
         *
         * @readonly
         * @type {string}
         * @memberof DataLakeFileSystemClient
         */
        get: function () {
            return this.blobContainerClient.containerName;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Creates a {@link DataLakeDirectoryClient} object under current file system.
     *
     * @param {string} directoryName
     * @returns {DataLakeDirectoryClient}
     * @memberof DataLakeFileSystemClient
     */
    DataLakeFileSystemClient.prototype.getDirectoryClient = function (directoryName) {
        return new DataLakeDirectoryClient(appendToURLPath(this.url, encodeURIComponent(directoryName)), this.pipeline);
    };
    /**
     * Creates a {@link DataLakeFileClient} object under current file system.
     *
     * @param {string} fileName
     * @returns {DataLakeFileClient}
     * @memberof DataLakeFileSystemClient
     */
    DataLakeFileSystemClient.prototype.getFileClient = function (fileName) {
        return new DataLakeFileClient(appendToURLPath(this.url, encodeURIComponent(fileName)), this.pipeline);
    };
    /**
     * Get a {@link DataLakeLeaseClient} that manages leases on the file system.
     *
     * @param {string} [proposeLeaseId] Optional. Initial proposed lease Id.
     * @returns {DataLakeLeaseClient}
     * @memberof DataLakeFileSystemClient
     */
    DataLakeFileSystemClient.prototype.getDataLakeLeaseClient = function (proposeLeaseId) {
        return new DataLakeLeaseClient(this.blobContainerClient.getBlobLeaseClient(proposeLeaseId));
    };
    /**
     * Creates a new file system under the specified account. If the file system with
     * the same name already exists, the operation fails.
     *
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/create-container
     *
     * @param {FileSystemCreateOptions} [options={}] Optional. Options when creating file system.
     * @returns {Promise<FileSystemCreateResponse>}
     * @memberof DataLakeFileSystemClient
     */
    DataLakeFileSystemClient.prototype.create = function (options) {
        if (options === void 0) { options = {}; }
        return tslib.__awaiter(this, void 0, void 0, function () {
            var _a, span, spanOptions, e_1;
            return tslib.__generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = createSpan("DataLakeFileSystemClient-create", options.tracingOptions), span = _a.span, spanOptions = _a.spanOptions;
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 3, 4, 5]);
                        return [4 /*yield*/, this.blobContainerClient.create(tslib.__assign(tslib.__assign({}, options), { access: toContainerPublicAccessType(options.access), tracingOptions: tslib.__assign(tslib.__assign({}, options.tracingOptions), { spanOptions: spanOptions }) }))];
                    case 2: return [2 /*return*/, _b.sent()];
                    case 3:
                        e_1 = _b.sent();
                        span.setStatus({
                            code: src_1.UNKNOWN,
                            message: e_1.message
                        });
                        throw e_1;
                    case 4:
                        span.end();
                        return [7 /*endfinally*/];
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Delete current file system.
     *
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/delete-container
     *
     * @param {FileSystemDeleteOptions} [options={}] Optional. Options when deleting file system.
     * @returns {Promise<FileSystemDeleteResponse>}
     * @memberof DataLakeFileSystemClient
     */
    DataLakeFileSystemClient.prototype.delete = function (options) {
        if (options === void 0) { options = {}; }
        return tslib.__awaiter(this, void 0, void 0, function () {
            var _a, span, spanOptions, e_2;
            return tslib.__generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = createSpan("DataLakeFileSystemClient-delete", options.tracingOptions), span = _a.span, spanOptions = _a.spanOptions;
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 3, 4, 5]);
                        return [4 /*yield*/, this.blobContainerClient.delete(tslib.__assign(tslib.__assign({}, options), { tracingOptions: tslib.__assign(tslib.__assign({}, options.tracingOptions), { spanOptions: spanOptions }) }))];
                    case 2: return [2 /*return*/, _b.sent()];
                    case 3:
                        e_2 = _b.sent();
                        span.setStatus({
                            code: src_1.UNKNOWN,
                            message: e_2.message
                        });
                        throw e_2;
                    case 4:
                        span.end();
                        return [7 /*endfinally*/];
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Returns all user-defined metadata and system properties for the specified
     * file system.
     *
     * WARNING: The `metadata` object returned in the response will have its keys in lowercase, even if
     * they originally contained uppercase characters. This differs from the metadata keys returned by
     * the `listFileSystems` method of {@link DataLakeServiceClient} using the `includeMetadata` option, which
     * will retain their original casing.
     *
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/get-container-properties
     *
     * @param {FileSystemGetPropertiesOptions} [options={}] Optional. Options when getting file system properties.
     * @returns {Promise<FileSystemGetPropertiesResponse>}
     * @memberof DataLakeFileSystemClient
     */
    DataLakeFileSystemClient.prototype.getProperties = function (options) {
        if (options === void 0) { options = {}; }
        return tslib.__awaiter(this, void 0, void 0, function () {
            var _a, span, spanOptions, rawResponse, response, e_3;
            return tslib.__generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = createSpan("DataLakeFileSystemClient-getProperties", options.tracingOptions), span = _a.span, spanOptions = _a.spanOptions;
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 3, 4, 5]);
                        return [4 /*yield*/, this.blobContainerClient.getProperties(tslib.__assign(tslib.__assign({}, options), { tracingOptions: tslib.__assign(tslib.__assign({}, options.tracingOptions), { spanOptions: spanOptions }) }))];
                    case 2:
                        rawResponse = _b.sent();
                        response = rawResponse;
                        response.publicAccess = toPublicAccessType(rawResponse.blobPublicAccess);
                        response._response.parsedHeaders.publicAccess = response.publicAccess;
                        delete rawResponse.blobPublicAccess;
                        delete rawResponse._response.parsedHeaders.blobPublicAccess;
                        return [2 /*return*/, response];
                    case 3:
                        e_3 = _b.sent();
                        span.setStatus({
                            code: src_1.UNKNOWN,
                            message: e_3.message
                        });
                        throw e_3;
                    case 4:
                        span.end();
                        return [7 /*endfinally*/];
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Sets one or more user-defined name-value pairs for the specified file system.
     *
     * If no option provided, or no metadata defined in the parameter, the file system
     * metadata will be removed.
     *
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/set-container-metadata
     *
     * @param {Metadata} [metadata] Replace existing metadata with this value.
     *                              If no value provided the existing metadata will be removed.
     * @param {FileSystemSetMetadataOptions} [options={}] Optional. Options when setting file system metadata.
     * @returns {Promise<FileSystemSetMetadataResponse>}
     * @memberof DataLakeFileSystemClient
     */
    DataLakeFileSystemClient.prototype.setMetadata = function (metadata, options) {
        if (options === void 0) { options = {}; }
        return tslib.__awaiter(this, void 0, void 0, function () {
            var _a, span, spanOptions, e_4;
            return tslib.__generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = createSpan("DataLakeFileSystemClient-setMetadata", options.tracingOptions), span = _a.span, spanOptions = _a.spanOptions;
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 3, 4, 5]);
                        return [4 /*yield*/, this.blobContainerClient.setMetadata(metadata, tslib.__assign(tslib.__assign({}, options), { tracingOptions: tslib.__assign(tslib.__assign({}, options.tracingOptions), { spanOptions: spanOptions }) }))];
                    case 2: return [2 /*return*/, _b.sent()];
                    case 3:
                        e_4 = _b.sent();
                        span.setStatus({
                            code: src_1.UNKNOWN,
                            message: e_4.message
                        });
                        throw e_4;
                    case 4:
                        span.end();
                        return [7 /*endfinally*/];
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Gets the permissions for the specified file system. The permissions indicate
     * whether file system data may be accessed publicly.
     *
     * WARNING: JavaScript Date will potentially lose precision when parsing startsOn and expiresOn strings.
     * For example, new Date("2018-12-31T03:44:23.8827891Z").toISOString() will get "2018-12-31T03:44:23.882Z".
     *
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/get-container-acl
     *
     * @param {FileSystemGetAccessPolicyOptions} [options={}] Optional. Options when getting file system access policy.
     * @returns {Promise<FileSystemGetAccessPolicyResponse>}
     * @memberof DataLakeFileSystemClient
     */
    DataLakeFileSystemClient.prototype.getAccessPolicy = function (options) {
        if (options === void 0) { options = {}; }
        return tslib.__awaiter(this, void 0, void 0, function () {
            var _a, span, spanOptions, rawResponse, response, e_5;
            return tslib.__generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = createSpan("DataLakeFileSystemClient-getAccessPolicy", options.tracingOptions), span = _a.span, spanOptions = _a.spanOptions;
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 3, 4, 5]);
                        return [4 /*yield*/, this.blobContainerClient.getAccessPolicy(tslib.__assign(tslib.__assign({}, options), { tracingOptions: tslib.__assign(tslib.__assign({}, options.tracingOptions), { spanOptions: spanOptions }) }))];
                    case 2:
                        rawResponse = _b.sent();
                        response = rawResponse;
                        response.publicAccess = toPublicAccessType(rawResponse.blobPublicAccess);
                        response._response.parsedHeaders.publicAccess = response.publicAccess;
                        delete rawResponse.blobPublicAccess;
                        delete rawResponse._response.parsedHeaders.blobPublicAccess;
                        return [2 /*return*/, response];
                    case 3:
                        e_5 = _b.sent();
                        span.setStatus({
                            code: src_1.UNKNOWN,
                            message: e_5.message
                        });
                        throw e_5;
                    case 4:
                        span.end();
                        return [7 /*endfinally*/];
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Sets the permissions for the specified file system. The permissions indicate
     * whether directories or files in a file system may be accessed publicly.
     *
     * When you set permissions for a file system, the existing permissions are replaced.
     * If no access or containerAcl provided, the existing file system ACL will be
     * removed.
     *
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/set-container-acl
     *
     * @param {PublicAccessType} [access] Optional. The level of public access to data in the file system.
     * @param {SignedIdentifier<AccessPolicy>[]} [fileSystemAcl] Optional. Array of elements each having a unique Id and details of the access policy.
     * @param {FileSystemSetAccessPolicyOptions} [options={}] Optional. Options when setting file system access policy.
     * @returns {Promise<FileSystemSetAccessPolicyResponse>}
     * @memberof DataLakeFileSystemClient
     */
    DataLakeFileSystemClient.prototype.setAccessPolicy = function (access, fileSystemAcl, options) {
        if (options === void 0) { options = {}; }
        return tslib.__awaiter(this, void 0, void 0, function () {
            var _a, span, spanOptions, e_6;
            return tslib.__generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = createSpan("DataLakeFileSystemClient-setAccessPolicy", options.tracingOptions), span = _a.span, spanOptions = _a.spanOptions;
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 3, 4, 5]);
                        return [4 /*yield*/, this.blobContainerClient.setAccessPolicy(toContainerPublicAccessType(access), fileSystemAcl, tslib.__assign(tslib.__assign({}, options), { tracingOptions: tslib.__assign(tslib.__assign({}, options.tracingOptions), { spanOptions: spanOptions }) }))];
                    case 2: return [2 /*return*/, _b.sent()];
                    case 3:
                        e_6 = _b.sent();
                        span.setStatus({
                            code: src_1.UNKNOWN,
                            message: e_6.message
                        });
                        throw e_6;
                    case 4:
                        span.end();
                        return [7 /*endfinally*/];
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Returns an async iterable iterator to list all the paths (directories and files)
     * under the specified file system.
     *
     * .byPage() returns an async iterable iterator to list the paths in pages.
     *
     * Example using `for await` syntax:
     *
     * ```js
     * // Get the fileSystemClient before you run these snippets,
     * // Can be obtained from `serviceClient.getFileSystemClient("<your-filesystem-name>");`
     * let i = 1;
     * for await (const path of fileSystemClient.listPaths()) {
     *   console.log(`Path ${i++}: ${path.name}, isDirectory?: ${path.isDirectory}`);
     * }
     * ```
     *
     * Example using `iter.next()`:
     *
     * ```js
     * let i = 1;
     * let iter = fileSystemClient.listPaths();
     * let pathItem = await iter.next();
     * while (!pathItem.done) {
     *   console.log(`Path ${i++}: ${pathItem.value.name}, isDirectory?: ${pathItem.value.isDirectory}`);
     *   pathItem = await iter.next();
     * }
     * ```
     *
     * Example using `byPage()`:
     *
     * ```js
     * // passing optional maxPageSize in the page settings
     * let i = 1;
     * for await (const response of fileSystemClient.listPaths().byPage({ maxPageSize: 20 })) {
     *   for (const path of response.pathItems) {
     *     console.log(`Path ${i++}: ${path.name}, isDirectory?: ${path.isDirectory}`);
     *   }
     * }
     * ```
     *
     * Example using paging with a marker:
     *
     * ```js
     * let i = 1;
     * let iterator = fileSystemClient.listPaths().byPage({ maxPageSize: 2 });
     * let response = (await iterator.next()).value;
     *
     * // Prints 2 path names
     * for (const path of response.pathItems) {
     *   console.log(`Path ${i++}: ${path.name}, isDirectory?: ${path.isDirectory}`);
     * }
     *
     * // Gets next marker
     * let marker = response.continuationToken;
     *
     * // Passing next marker as continuationToken
     *
     * iterator = fileSystemClient.listPaths().byPage({ continuationToken: marker, maxPageSize: 10 });
     * response = (await iterator.next()).value;
     *
     * // Prints 10 path names
     * for (const path of response.pathItems) {
     *   console.log(`Path ${i++}: ${path.name}, isDirectory?: ${path.isDirectory}`);
     * }
     * ```
     *
     * @see https://docs.microsoft.com/rest/api/storageservices/list-blobs
     *
     * @param {ListPathsOptions} [options={}] Optional. Options when listing paths.
     * @returns {PagedAsyncIterableIterator<Path, FileSystemListPathsResponse>}
     * @memberof DataLakeFileSystemClient
     */
    DataLakeFileSystemClient.prototype.listPaths = function (options) {
        var _a;
        var _this = this;
        if (options === void 0) { options = {}; }
        options.path = options.path === "" ? undefined : options.path;
        var iter = this.listItems(options);
        return _a = {
                next: function () {
                    return iter.next();
                }
            },
            _a[Symbol.asyncIterator] = function () {
                return this;
            },
            _a.byPage = function (settings) {
                if (settings === void 0) { settings = {}; }
                return _this.listSegments(settings.continuationToken, tslib.__assign({ maxResults: settings.maxPageSize }, options));
            },
            _a;
    };
    DataLakeFileSystemClient.prototype.listItems = function (options) {
        if (options === void 0) { options = {}; }
        return tslib.__asyncGenerator(this, arguments, function listItems_1() {
            var _a, _b, response, e_7_1;
            var e_7, _c;
            return tslib.__generator(this, function (_d) {
                switch (_d.label) {
                    case 0:
                        _d.trys.push([0, 7, 8, 13]);
                        _a = tslib.__asyncValues(this.listSegments(undefined, options));
                        _d.label = 1;
                    case 1: return [4 /*yield*/, tslib.__await(_a.next())];
                    case 2:
                        if (!(_b = _d.sent(), !_b.done)) return [3 /*break*/, 6];
                        response = _b.value;
                        return [5 /*yield**/, tslib.__values(tslib.__asyncDelegator(tslib.__asyncValues(response.pathItems || [])))];
                    case 3: return [4 /*yield*/, tslib.__await.apply(void 0, [_d.sent()])];
                    case 4:
                        _d.sent();
                        _d.label = 5;
                    case 5: return [3 /*break*/, 1];
                    case 6: return [3 /*break*/, 13];
                    case 7:
                        e_7_1 = _d.sent();
                        e_7 = { error: e_7_1 };
                        return [3 /*break*/, 13];
                    case 8:
                        _d.trys.push([8, , 11, 12]);
                        if (!(_b && !_b.done && (_c = _a.return))) return [3 /*break*/, 10];
                        return [4 /*yield*/, tslib.__await(_c.call(_a))];
                    case 9:
                        _d.sent();
                        _d.label = 10;
                    case 10: return [3 /*break*/, 12];
                    case 11:
                        if (e_7) throw e_7.error;
                        return [7 /*endfinally*/];
                    case 12: return [7 /*endfinally*/];
                    case 13: return [2 /*return*/];
                }
            });
        });
    };
    DataLakeFileSystemClient.prototype.listSegments = function (continuation, options) {
        if (options === void 0) { options = {}; }
        return tslib.__asyncGenerator(this, arguments, function listSegments_1() {
            var response;
            return tslib.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!(!!continuation || continuation === undefined)) return [3 /*break*/, 6];
                        _a.label = 1;
                    case 1: return [4 /*yield*/, tslib.__await(this.listPathsSegment(continuation, options))];
                    case 2:
                        response = _a.sent();
                        continuation = response.continuation;
                        return [4 /*yield*/, tslib.__await(response)];
                    case 3: return [4 /*yield*/, _a.sent()];
                    case 4:
                        _a.sent();
                        _a.label = 5;
                    case 5:
                        if (continuation) return [3 /*break*/, 1];
                        _a.label = 6;
                    case 6: return [2 /*return*/];
                }
            });
        });
    };
    DataLakeFileSystemClient.prototype.listPathsSegment = function (continuation, options) {
        if (options === void 0) { options = {}; }
        return tslib.__awaiter(this, void 0, void 0, function () {
            var _a, span, spanOptions, rawResponse, response, _i, _b, path, e_8;
            return tslib.__generator(this, function (_c) {
                switch (_c.label) {
                    case 0:
                        _a = createSpan("DataLakeFileSystemClient-listPathsSegment", options.tracingOptions), span = _a.span, spanOptions = _a.spanOptions;
                        _c.label = 1;
                    case 1:
                        _c.trys.push([1, 3, 4, 5]);
                        return [4 /*yield*/, this.fileSystemContext.listPaths(options.recursive || false, tslib.__assign(tslib.__assign({ continuation: continuation }, options), { upn: options.userPrincipalName, spanOptions: spanOptions }))];
                    case 2:
                        rawResponse = _c.sent();
                        response = rawResponse;
                        response.pathItems = [];
                        for (_i = 0, _b = rawResponse.paths || []; _i < _b.length; _i++) {
                            path = _b[_i];
                            response.pathItems.push(tslib.__assign(tslib.__assign({}, path), { permissions: toPermissions(path.permissions) }));
                        }
                        delete rawResponse.paths;
                        return [2 /*return*/, response];
                    case 3:
                        e_8 = _c.sent();
                        span.setStatus({
                            code: src_1.UNKNOWN,
                            message: e_8.message
                        });
                        throw e_8;
                    case 4:
                        span.end();
                        return [7 /*endfinally*/];
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    return DataLakeFileSystemClient;
}(StorageClient));

// Copyright (c) Microsoft Corporation. All rights reserved.
/**
 * DataLakeServiceClient allows you to manipulate Azure
 * Data Lake service resources and file systems. The storage account provides
 * the top-level namespace for the Data Lake service.
 *
 * @export
 * @class DataLakeServiceClient
 * @extends {StorageClient}
 */
var DataLakeServiceClient = /** @class */ (function (_super) {
    tslib.__extends(DataLakeServiceClient, _super);
    function DataLakeServiceClient(url, credentialOrPipeline, options) {
        var _this = this;
        // when options.httpClient is not specified, passing in a DefaultHttpClient instance to
        // avoid each client creating its own http client.
        var newOptions = tslib.__assign({ httpClient: getCachedDefaultHttpClient() }, options);
        if (credentialOrPipeline instanceof Pipeline) {
            _this = _super.call(this, url, credentialOrPipeline) || this;
        }
        else {
            var credential = void 0;
            if (credentialOrPipeline === undefined) {
                credential = new AnonymousCredential();
            }
            else {
                credential = credentialOrPipeline;
            }
            var pipeline = newPipeline(credential, newOptions);
            _this = _super.call(this, url, pipeline) || this;
        }
        // this.serviceContext = new Service(this.storageClientContext);
        _this.blobServiceClient = new storageBlob.BlobServiceClient(_this.blobEndpointUrl, _this.pipeline);
        return _this;
    }
    /**
     * Creates a {@link DataLakeFileSystemClient} object.
     *
     * @param {string} fileSystemName File system name.
     * @returns {DataLakeFileSystemClient}
     * @memberof DataLakeServiceClient
     */
    DataLakeServiceClient.prototype.getFileSystemClient = function (fileSystemName) {
        return new DataLakeFileSystemClient(appendToURLPath(this.url, encodeURIComponent(fileSystemName)), this.pipeline);
    };
    /**
     * ONLY AVAILABLE WHEN USING BEARER TOKEN AUTHENTICATION (TokenCredential).
     *
     * Retrieves a user delegation key for the Data Lake service. This is only a valid operation when using
     * bearer token authentication.
     *
     * @example
     * ```js
     * // Generate user delegation SAS for a file system
     * const userDelegationKey = await dataLakeServiceClient.getUserDelegationKey(startsOn, expiresOn);
     * const fileSystemSAS = generateDataLakeSASQueryParameters({
     *     fileSystemName, // Required
     *     permissions: FileSystemSASPermissions.parse("racwdl"), // Required
     *     startsOn, // Required. Date type
     *     expiresOn, // Optional. Date type
     *     ipRange: { start: "0.0.0.0", end: "255.255.255.255" }, // Optional
     *     protocol: SASProtocol.HttpsAndHttp, // Optional
     *     version: "2018-11-09" // Must >= 2018-11-09 to generate user delegation SAS
     *   },
     *   userDelegationKey, // UserDelegationKey
     *   accountName
     * ).toString();
     * ```
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/get-user-delegation-key
     *
     * @param {Date} startsOn The start time for the user delegation SAS. Must be within 7 days of the current time.
     * @param {Date} expiresOn The end time for the user delegation SAS. Must be within 7 days of the current time.
     * @param {ServiceGetUserDelegationKeyOptions} [options={}]
     * @returns {Promise<ServiceGetUserDelegationKeyResponse>}
     * @memberof DataLakeServiceClient
     */
    DataLakeServiceClient.prototype.getUserDelegationKey = function (startsOn, expiresOn, options) {
        if (options === void 0) { options = {}; }
        return tslib.__awaiter(this, void 0, void 0, function () {
            var _a, span, spanOptions, e_1;
            return tslib.__generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = createSpan("DataLakeServiceClient-getUserDelegationKey", options.tracingOptions), span = _a.span, spanOptions = _a.spanOptions;
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 3, 4, 5]);
                        return [4 /*yield*/, this.blobServiceClient.getUserDelegationKey(startsOn, expiresOn, tslib.__assign(tslib.__assign({}, options), { tracingOptions: tslib.__assign(tslib.__assign({}, options.tracingOptions), { spanOptions: spanOptions }) }))];
                    case 2: return [2 /*return*/, _b.sent()];
                    case 3:
                        e_1 = _b.sent();
                        span.setStatus({
                            code: src_1.UNKNOWN,
                            message: e_1.message
                        });
                        throw e_1;
                    case 4:
                        span.end();
                        return [7 /*endfinally*/];
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Returns an async iterable iterator to list all the file systems
     * under the specified account.
     *
     * .byPage() returns an async iterable iterator to list the file systems in pages.
     *
     * Example using `for await` syntax:
     *
     * ```js
     * let i = 1;
     * for await (const fileSystem of serviceClient.listFileSystems()) {
     *   console.log(`FileSystem ${i++}: ${fileSystem.name}`);
     * }
     * ```
     *
     * Example using `iter.next()`:
     *
     * ```js
     * let i = 1;
     * const iter = serviceClient.listFileSystems();
     * let fileSystemItem = await iter.next();
     * while (!fileSystemItem.done) {
     *   console.log(`FileSystem ${i++}: ${fileSystemItem.value.name}`);
     *   fileSystemItem = await iter.next();
     * }
     * ```
     *
     * Example using `byPage()`:
     *
     * ```js
     * // passing optional maxPageSize in the page settings
     * let i = 1;
     * for await (const response of serviceClient.listFileSystems().byPage({ maxPageSize: 20 })) {
     *   if (response.fileSystemItems) {
     *     for (const fileSystem of response.fileSystemItems) {
     *       console.log(`FileSystem ${i++}: ${fileSystem.name}`);
     *     }
     *   }
     * }
     * ```
     *
     * Example using paging with a marker:
     *
     * ```js
     * let i = 1;
     * let iterator = serviceClient.listFileSystems().byPage({ maxPageSize: 2 });
     * let response = (await iterator.next()).value;
     *
     * // Prints 2 file system names
     * if (response.fileSystemItems) {
     *   for (const fileSystem of response.fileSystemItems) {
     *     console.log(`FileSystem ${i++}: ${fileSystem.name}`);
     *   }
     * }
     *
     * // Gets next marker
     * let marker = response.continuationToken;
     * // Passing next marker as continuationToken
     * iterator = serviceClient
     *   .listContainers()
     *   .byPage({ continuationToken: marker, maxPageSize: 10 });
     * response = (await iterator.next()).value;
     *
     * // Prints 10 file system names
     * if (response.fileSystemItems) {
     *   for (const fileSystem of response.fileSystemItems) {
     *      console.log(`FileSystem ${i++}: ${fileSystem.name}`);
     *   }
     * }
     * ```
     *
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/list-containers2
     *
     * @param {ServiceListFileSystemsOptions} [options={}]
     * @returns {PagedAsyncIterableIterator<FileSystemItem, ServiceListFileSystemsSegmentResponse>}
     * @memberof DataLakeServiceClient
     */
    DataLakeServiceClient.prototype.listFileSystems = function (options) {
        if (options === void 0) { options = {}; }
        return toFileSystemPagedAsyncIterableIterator(this.blobServiceClient.listContainers(options));
    };
    return DataLakeServiceClient;
}(StorageClient));

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
/**
 * ONLY AVAILABLE IN NODE.JS RUNTIME.
 *
 * This is a helper class to construct a string representing the permissions granted by an AccountSAS. Setting a value
 * to true means that any SAS which uses these permissions will grant permissions for that operation. Once all the
 * values are set, this should be serialized with toString and set as the permissions field on an
 * {@link AccountSASSignatureValues} object. It is possible to construct the permissions string without this class, but
 * the order of the permissions is particular and this class guarantees correctness.
 *
 * @export
 * @class AccountSASPermissions
 */
var AccountSASPermissions = /** @class */ (function () {
    function AccountSASPermissions() {
        /**
         * Permission to read resources and list queues and tables granted.
         *
         * @type {boolean}
         * @memberof AccountSASPermissions
         */
        this.read = false;
        /**
         * Permission to write resources granted.
         *
         * @type {boolean}
         * @memberof AccountSASPermissions
         */
        this.write = false;
        /**
         * Permission to delete blobs and files granted.
         *
         * @type {boolean}
         * @memberof AccountSASPermissions
         */
        this.delete = false;
        /**
         * Permission to list blob containers, blobs, shares, directories, and files granted.
         *
         * @type {boolean}
         * @memberof AccountSASPermissions
         */
        this.list = false;
        /**
         * Permission to add messages, table entities, and append to blobs granted.
         *
         * @type {boolean}
         * @memberof AccountSASPermissions
         */
        this.add = false;
        /**
         * Permission to create blobs and files granted.
         *
         * @type {boolean}
         * @memberof AccountSASPermissions
         */
        this.create = false;
        /**
         * Permissions to update messages and table entities granted.
         *
         * @type {boolean}
         * @memberof AccountSASPermissions
         */
        this.update = false;
        /**
         * Permission to get and delete messages granted.
         *
         * @type {boolean}
         * @memberof AccountSASPermissions
         */
        this.process = false;
    }
    /**
     * Parse initializes the AccountSASPermissions fields from a string.
     *
     * @static
     * @param {string} permissions
     * @returns {AccountSASPermissions}
     * @memberof AccountSASPermissions
     */
    AccountSASPermissions.parse = function (permissions) {
        var accountSASPermissions = new AccountSASPermissions();
        for (var _i = 0, permissions_1 = permissions; _i < permissions_1.length; _i++) {
            var c = permissions_1[_i];
            switch (c) {
                case "r":
                    accountSASPermissions.read = true;
                    break;
                case "w":
                    accountSASPermissions.write = true;
                    break;
                case "d":
                    accountSASPermissions.delete = true;
                    break;
                case "l":
                    accountSASPermissions.list = true;
                    break;
                case "a":
                    accountSASPermissions.add = true;
                    break;
                case "c":
                    accountSASPermissions.create = true;
                    break;
                case "u":
                    accountSASPermissions.update = true;
                    break;
                case "p":
                    accountSASPermissions.process = true;
                    break;
                default:
                    throw new RangeError("Invalid permission character: " + c);
            }
        }
        return accountSASPermissions;
    };
    /**
     * Produces the SAS permissions string for an Azure Storage account.
     * Call this method to set AccountSASSignatureValues Permissions field.
     *
     * Using this method will guarantee the resource types are in
     * an order accepted by the service.
     *
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/constructing-an-account-sas
     *
     * @returns {string}
     * @memberof AccountSASPermissions
     */
    AccountSASPermissions.prototype.toString = function () {
        // The order of the characters should be as specified here to ensure correctness:
        // https://docs.microsoft.com/en-us/rest/api/storageservices/constructing-an-account-sas
        // Use a string array instead of string concatenating += operator for performance
        var permissions = [];
        if (this.read) {
            permissions.push("r");
        }
        if (this.write) {
            permissions.push("w");
        }
        if (this.delete) {
            permissions.push("d");
        }
        if (this.list) {
            permissions.push("l");
        }
        if (this.add) {
            permissions.push("a");
        }
        if (this.create) {
            permissions.push("c");
        }
        if (this.update) {
            permissions.push("u");
        }
        if (this.process) {
            permissions.push("p");
        }
        return permissions.join("");
    };
    return AccountSASPermissions;
}());

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
/**
 * ONLY AVAILABLE IN NODE.JS RUNTIME.
 *
 * This is a helper class to construct a string representing the resources accessible by an AccountSAS. Setting a value
 * to true means that any SAS which uses these permissions will grant access to that resource type. Once all the
 * values are set, this should be serialized with toString and set as the resources field on an
 * {@link AccountSASSignatureValues} object. It is possible to construct the resources string without this class, but
 * the order of the resources is particular and this class guarantees correctness.
 *
 * @export
 * @class AccountSASResourceTypes
 */
var AccountSASResourceTypes = /** @class */ (function () {
    function AccountSASResourceTypes() {
        /**
         * Permission to access service level APIs granted.
         *
         * @type {boolean}
         * @memberof AccountSASResourceTypes
         */
        this.service = false;
        /**
         * Permission to access container level APIs (Blob Containers, Tables, Queues, File Shares, File Systems) granted.
         *
         * @type {boolean}
         * @memberof AccountSASResourceTypes
         */
        this.container = false;
        /**
         * Permission to access object level APIs (Blobs, Table Entities, Queue Messages, Files, Directories) granted.
         *
         * @type {boolean}
         * @memberof AccountSASResourceTypes
         */
        this.object = false;
    }
    /**
     * Creates an {@link AccountSASResourceTypes} from the specified resource types string. This method will throw an
     * Error if it encounters a character that does not correspond to a valid resource type.
     *
     * @static
     * @param {string} resourceTypes
     * @returns {AccountSASResourceTypes}
     * @memberof AccountSASResourceTypes
     */
    AccountSASResourceTypes.parse = function (resourceTypes) {
        var accountSASResourceTypes = new AccountSASResourceTypes();
        for (var _i = 0, resourceTypes_1 = resourceTypes; _i < resourceTypes_1.length; _i++) {
            var c = resourceTypes_1[_i];
            switch (c) {
                case "s":
                    accountSASResourceTypes.service = true;
                    break;
                case "c":
                    accountSASResourceTypes.container = true;
                    break;
                case "o":
                    accountSASResourceTypes.object = true;
                    break;
                default:
                    throw new RangeError("Invalid resource type: " + c);
            }
        }
        return accountSASResourceTypes;
    };
    /**
     * Converts the given resource types to a string.
     *
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/constructing-an-account-sas
     *
     * @returns {string}
     * @memberof AccountSASResourceTypes
     */
    AccountSASResourceTypes.prototype.toString = function () {
        var resourceTypes = [];
        if (this.service) {
            resourceTypes.push("s");
        }
        if (this.container) {
            resourceTypes.push("c");
        }
        if (this.object) {
            resourceTypes.push("o");
        }
        return resourceTypes.join("");
    };
    return AccountSASResourceTypes;
}());

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
/**
 * ONLY AVAILABLE IN NODE.JS RUNTIME.
 *
 * This is a helper class to construct a string representing the services accessible by an AccountSAS. Setting a value
 * to true means that any SAS which uses these permissions will grant access to that service. Once all the
 * values are set, this should be serialized with toString and set as the services field on an
 * {@link AccountSASSignatureValues} object. It is possible to construct the services string without this class, but
 * the order of the services is particular and this class guarantees correctness.
 *
 * @export
 * @class AccountSASServices
 */
var AccountSASServices = /** @class */ (function () {
    function AccountSASServices() {
        /**
         * Permission to access blob and data lake resources granted.
         *
         * @type {boolean}
         * @memberof AccountSASServices
         */
        this.blob = false;
        /**
         * Permission to access file resources granted.
         *
         * @type {boolean}
         * @memberof AccountSASServices
         */
        this.file = false;
        /**
         * Permission to access queue resources granted.
         *
         * @type {boolean}
         * @memberof AccountSASServices
         */
        this.queue = false;
        /**
         * Permission to access table resources granted.
         *
         * @type {boolean}
         * @memberof AccountSASServices
         */
        this.table = false;
    }
    /**
     * Creates an {@link AccountSASServices} from the specified services string. This method will throw an
     * Error if it encounters a character that does not correspond to a valid service.
     *
     * @static
     * @param {string} services
     * @returns {AccountSASServices}
     * @memberof AccountSASServices
     */
    AccountSASServices.parse = function (services) {
        var accountSASServices = new AccountSASServices();
        for (var _i = 0, services_1 = services; _i < services_1.length; _i++) {
            var c = services_1[_i];
            switch (c) {
                case "b":
                    accountSASServices.blob = true;
                    break;
                case "f":
                    accountSASServices.file = true;
                    break;
                case "q":
                    accountSASServices.queue = true;
                    break;
                case "t":
                    accountSASServices.table = true;
                    break;
                default:
                    throw new RangeError("Invalid service character: " + c);
            }
        }
        return accountSASServices;
    };
    /**
     * Converts the given services to a string.
     *
     * @returns {string}
     * @memberof AccountSASServices
     */
    AccountSASServices.prototype.toString = function () {
        var services = [];
        if (this.blob) {
            services.push("b");
        }
        if (this.table) {
            services.push("t");
        }
        if (this.queue) {
            services.push("q");
        }
        if (this.file) {
            services.push("f");
        }
        return services.join("");
    };
    return AccountSASServices;
}());

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
/**
 * Generate SasIPRange format string. For example:
 *
 * "8.8.8.8" or "1.1.1.1-255.255.255.255"
 *
 * @export
 * @param {SasIPRange} ipRange
 * @returns {string}
 */
function ipRangeToString(ipRange) {
    return ipRange.end ? ipRange.start + "-" + ipRange.end : ipRange.start;
}

(function (SASProtocol) {
    /**
     * Protocol that allows HTTPS only
     */
    SASProtocol["Https"] = "https";
    /**
     * Protocol that allows both HTTPS and HTTP
     */
    SASProtocol["HttpsAndHttp"] = "https,http";
})(exports.SASProtocol || (exports.SASProtocol = {}));
/**
 * Represents the components that make up an Azure Storage SAS' query parameters. This type is not constructed directly
 * by the user; it is only generated by the {@link AccountSASSignatureValues} and {@link BlobSASSignatureValues}
 * types. Once generated, it can be encoded into a {@code String} and appended to a URL directly (though caution should
 * be taken here in case there are existing query parameters, which might affect the appropriate means of appending
 * these query parameters).
 *
 * NOTE: Instances of this class are immutable.
 *
 * @export
 * @class SASQueryParameters
 */
var SASQueryParameters = /** @class */ (function () {
    /**
     * Creates an instance of SASQueryParameters.
     *
     * @param {string} version Representing the storage version
     * @param {string} signature Representing the signature for the SAS token
     * @param {string} [permissions] Representing the storage permissions
     * @param {string} [services] Representing the storage services being accessed (only for Account SAS)
     * @param {string} [resourceTypes] Representing the storage resource types being accessed (only for Account SAS)
     * @param {SASProtocol} [protocol] Representing the allowed HTTP protocol(s)
     * @param {Date} [startsOn] Representing the start time for this SAS token
     * @param {Date} [expiresOn] Representing the expiry time for this SAS token
     * @param {SasIPRange} [ipRange] Representing the range of valid IP addresses for this SAS token
     * @param {string} [identifier] Representing the signed identifier (only for Service SAS)
     * @param {string} [resource] Representing the storage container or blob (only for Service SAS)
     * @param {string} [cacheControl] Representing the cache-control header (only for Blob/File Service SAS)
     * @param {string} [contentDisposition] Representing the content-disposition header (only for Blob/File Service SAS)
     * @param {string} [contentEncoding] Representing the content-encoding header (only for Blob/File Service SAS)
     * @param {string} [contentLanguage] Representing the content-language header (only for Blob/File Service SAS)
     * @param {string} [contentType] Representing the content-type header (only for Blob/File Service SAS)
     * @param {userDelegationKey} [userDelegationKey] Representing the user delegation key properties
     * @memberof SASQueryParameters
     */
    function SASQueryParameters(version, signature, permissions, services, resourceTypes, protocol, startsOn, expiresOn, ipRange, identifier, resource, cacheControl, contentDisposition, contentEncoding, contentLanguage, contentType, userDelegationKey) {
        this.version = version;
        this.services = services;
        this.resourceTypes = resourceTypes;
        this.expiresOn = expiresOn;
        this.permissions = permissions;
        this.protocol = protocol;
        this.startsOn = startsOn;
        this.ipRangeInner = ipRange;
        this.identifier = identifier;
        this.resource = resource;
        this.signature = signature;
        this.cacheControl = cacheControl;
        this.contentDisposition = contentDisposition;
        this.contentEncoding = contentEncoding;
        this.contentLanguage = contentLanguage;
        this.contentType = contentType;
        if (userDelegationKey) {
            this.signedOid = userDelegationKey.signedObjectId;
            this.signedTenentId = userDelegationKey.signedTenantId;
            this.signedStartsOn = userDelegationKey.signedStartsOn;
            this.signedExpiresOn = userDelegationKey.signedExpiresOn;
            this.signedService = userDelegationKey.signedService;
            this.signedVersion = userDelegationKey.signedVersion;
        }
    }
    Object.defineProperty(SASQueryParameters.prototype, "ipRange", {
        /**
         * Optional. IP range allowed for this SAS.
         *
         * @readonly
         * @type {(SasIPRange | undefined)}
         * @memberof SASQueryParameters
         */
        get: function () {
            if (this.ipRangeInner) {
                return {
                    end: this.ipRangeInner.end,
                    start: this.ipRangeInner.start
                };
            }
            return undefined;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Encodes all SAS query parameters into a string that can be appended to a URL.
     *
     * @returns {string}
     * @memberof SASQueryParameters
     */
    SASQueryParameters.prototype.toString = function () {
        var params = [
            "sv",
            "ss",
            "srt",
            "spr",
            "st",
            "se",
            "sip",
            "si",
            "skoid",
            "sktid",
            "skt",
            "ske",
            "sks",
            "skv",
            "sr",
            "sp",
            "sig",
            "rscc",
            "rscd",
            "rsce",
            "rscl",
            "rsct"
        ];
        var queries = [];
        for (var _i = 0, params_1 = params; _i < params_1.length; _i++) {
            var param = params_1[_i];
            switch (param) {
                case "sv":
                    this.tryAppendQueryParameter(queries, param, this.version);
                    break;
                case "ss":
                    this.tryAppendQueryParameter(queries, param, this.services);
                    break;
                case "srt":
                    this.tryAppendQueryParameter(queries, param, this.resourceTypes);
                    break;
                case "spr":
                    this.tryAppendQueryParameter(queries, param, this.protocol);
                    break;
                case "st":
                    this.tryAppendQueryParameter(queries, param, this.startsOn ? truncatedISO8061Date(this.startsOn, false) : undefined);
                    break;
                case "se":
                    this.tryAppendQueryParameter(queries, param, this.expiresOn ? truncatedISO8061Date(this.expiresOn, false) : undefined);
                    break;
                case "sip":
                    this.tryAppendQueryParameter(queries, param, this.ipRange ? ipRangeToString(this.ipRange) : undefined);
                    break;
                case "si":
                    this.tryAppendQueryParameter(queries, param, this.identifier);
                    break;
                case "skoid": // Signed object ID
                    this.tryAppendQueryParameter(queries, param, this.signedOid);
                    break;
                case "sktid": // Signed tenant ID
                    this.tryAppendQueryParameter(queries, param, this.signedTenentId);
                    break;
                case "skt": // Signed key start time
                    this.tryAppendQueryParameter(queries, param, this.signedStartsOn ? truncatedISO8061Date(this.signedStartsOn, false) : undefined);
                    break;
                case "ske": // Signed key expiry time
                    this.tryAppendQueryParameter(queries, param, this.signedExpiresOn ? truncatedISO8061Date(this.signedExpiresOn, false) : undefined);
                    break;
                case "sks": // Signed key service
                    this.tryAppendQueryParameter(queries, param, this.signedService);
                    break;
                case "skv": // Signed key version
                    this.tryAppendQueryParameter(queries, param, this.signedVersion);
                    break;
                case "sr":
                    this.tryAppendQueryParameter(queries, param, this.resource);
                    break;
                case "sp":
                    this.tryAppendQueryParameter(queries, param, this.permissions);
                    break;
                case "sig":
                    this.tryAppendQueryParameter(queries, param, this.signature);
                    break;
                case "rscc":
                    this.tryAppendQueryParameter(queries, param, this.cacheControl);
                    break;
                case "rscd":
                    this.tryAppendQueryParameter(queries, param, this.contentDisposition);
                    break;
                case "rsce":
                    this.tryAppendQueryParameter(queries, param, this.contentEncoding);
                    break;
                case "rscl":
                    this.tryAppendQueryParameter(queries, param, this.contentLanguage);
                    break;
                case "rsct":
                    this.tryAppendQueryParameter(queries, param, this.contentType);
                    break;
            }
        }
        return queries.join("&");
    };
    /**
     * A private helper method used to filter and append query key/value pairs into an array.
     *
     * @private
     * @param {string[]} queries
     * @param {string} key
     * @param {string} [value]
     * @returns {void}
     * @memberof SASQueryParameters
     */
    SASQueryParameters.prototype.tryAppendQueryParameter = function (queries, key, value) {
        if (!value) {
            return;
        }
        key = encodeURIComponent(key);
        value = encodeURIComponent(value);
        if (key.length > 0 && value.length > 0) {
            queries.push(key + "=" + value);
        }
    };
    return SASQueryParameters;
}());

// Copyright (c) Microsoft Corporation. All rights reserved.
/**
 * ONLY AVAILABLE IN NODE.JS RUNTIME.
 *
 * Generates a {@link SASQueryParameters} object which contains all SAS query parameters needed to make an actual
 * REST request.
 *
 * @see https://docs.microsoft.com/en-us/rest/api/storageservices/constructing-an-account-sas
 *
 * @param {AccountSASSignatureValues} accountSASSignatureValues
 * @param {StorageSharedKeyCredential} sharedKeyCredential
 * @returns {SASQueryParameters}
 * @memberof AccountSASSignatureValues
 */
function generateAccountSASQueryParameters(accountSASSignatureValues, sharedKeyCredential) {
    var version = accountSASSignatureValues.version
        ? accountSASSignatureValues.version
        : SERVICE_VERSION;
    var parsedPermissions = AccountSASPermissions.parse(accountSASSignatureValues.permissions.toString());
    var parsedServices = AccountSASServices.parse(accountSASSignatureValues.services).toString();
    var parsedResourceTypes = AccountSASResourceTypes.parse(accountSASSignatureValues.resourceTypes).toString();
    var stringToSign = [
        sharedKeyCredential.accountName,
        parsedPermissions,
        parsedServices,
        parsedResourceTypes,
        accountSASSignatureValues.startsOn
            ? truncatedISO8061Date(accountSASSignatureValues.startsOn, false)
            : "",
        truncatedISO8061Date(accountSASSignatureValues.expiresOn, false),
        accountSASSignatureValues.ipRange ? ipRangeToString(accountSASSignatureValues.ipRange) : "",
        accountSASSignatureValues.protocol ? accountSASSignatureValues.protocol : "",
        version,
        "" // Account SAS requires an additional newline character
    ].join("\n");
    var signature = sharedKeyCredential.computeHMACSHA256(stringToSign);
    return new SASQueryParameters(version, signature, parsedPermissions.toString(), parsedServices, parsedResourceTypes, accountSASSignatureValues.protocol, accountSASSignatureValues.startsOn, accountSASSignatureValues.expiresOn, accountSASSignatureValues.ipRange);
}

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
/**
 * ONLY AVAILABLE IN NODE.JS RUNTIME.
 *
 * This is a helper class to construct a string representing the permissions granted by a ServiceSAS. Setting
 * a value to true means that any SAS which uses these permissions will grant permissions for that operation. Once all
 * the values are set, this should be serialized with toString and set as the permissions field on a
 * {@link DataLakeSASSignatureValues} object. It is possible to construct the permissions string without this class, but
 * the order of the permissions is particular and this class guarantees correctness.
 *
 * @export
 * @class DataLakeSASPermissions
 */
var DataLakeSASPermissions = /** @class */ (function () {
    function DataLakeSASPermissions() {
        /**
         * Specifies Read access granted.
         *
         * @type {boolean}
         * @memberof DataLakeSASPermissions
         */
        this.read = false;
        /**
         * Specifies Add access granted.
         *
         * @type {boolean}
         * @memberof DataLakeSASPermissions
         */
        this.add = false;
        /**
         * Specifies Create access granted.
         *
         * @type {boolean}
         * @memberof DataLakeSASPermissions
         */
        this.create = false;
        /**
         * Specifies Write access granted.
         *
         * @type {boolean}
         * @memberof DataLakeSASPermissions
         */
        this.write = false;
        /**
         * Specifies Delete access granted.
         *
         * @type {boolean}
         * @memberof DataLakeSASPermissions
         */
        this.delete = false;
    }
    /**
     * Creates a {@link DataLakeSASPermissions} from the specified permissions string. This method will throw an
     * Error if it encounters a character that does not correspond to a valid permission.
     *
     * @static
     * @param {string} permissions
     * @returns {DataLakeSASPermissions}
     * @memberof DataLakeSASPermissions
     */
    DataLakeSASPermissions.parse = function (permissions) {
        var blobSASPermissions = new DataLakeSASPermissions();
        for (var _i = 0, permissions_1 = permissions; _i < permissions_1.length; _i++) {
            var char = permissions_1[_i];
            switch (char) {
                case "r":
                    blobSASPermissions.read = true;
                    break;
                case "a":
                    blobSASPermissions.add = true;
                    break;
                case "c":
                    blobSASPermissions.create = true;
                    break;
                case "w":
                    blobSASPermissions.write = true;
                    break;
                case "d":
                    blobSASPermissions.delete = true;
                    break;
                default:
                    throw new RangeError("Invalid permission: " + char);
            }
        }
        return blobSASPermissions;
    };
    /**
     * Converts the given permissions to a string. Using this method will guarantee the permissions are in an
     * order accepted by the service.
     *
     * @returns {string} A string which represents the DataLakeSASPermissions
     * @memberof DataLakeSASPermissions
     */
    DataLakeSASPermissions.prototype.toString = function () {
        var permissions = [];
        if (this.read) {
            permissions.push("r");
        }
        if (this.add) {
            permissions.push("a");
        }
        if (this.create) {
            permissions.push("c");
        }
        if (this.write) {
            permissions.push("w");
        }
        if (this.delete) {
            permissions.push("d");
        }
        return permissions.join("");
    };
    return DataLakeSASPermissions;
}());

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
/**
 * This is a helper class to construct a string representing the permissions granted by a ServiceSAS to a container.
 * Setting a value to true means that any SAS which uses these permissions will grant permissions for that operation.
 * Once all the values are set, this should be serialized with toString and set as the permissions field on a
 * {@link DataLakeSASSignatureValues} object. It is possible to construct the permissions string without this class, but
 * the order of the permissions is particular and this class guarantees correctness.
 *
 * @export
 * @class FileSystemSASPermissions
 */
var FileSystemSASPermissions = /** @class */ (function () {
    function FileSystemSASPermissions() {
        /**
         * Specifies Read access granted.
         *
         * @type {boolean}
         * @memberof FileSystemSASPermissions
         */
        this.read = false;
        /**
         * Specifies Add access granted.
         *
         * @type {boolean}
         * @memberof FileSystemSASPermissions
         */
        this.add = false;
        /**
         * Specifies Create access granted.
         *
         * @type {boolean}
         * @memberof FileSystemSASPermissions
         */
        this.create = false;
        /**
         * Specifies Write access granted.
         *
         * @type {boolean}
         * @memberof FileSystemSASPermissions
         */
        this.write = false;
        /**
         * Specifies Delete access granted.
         *
         * @type {boolean}
         * @memberof FileSystemSASPermissions
         */
        this.delete = false;
        /**
         * Specifies List access granted.
         *
         * @type {boolean}
         * @memberof FileSystemSASPermissions
         */
        this.list = false;
    }
    /**
     * Creates an {@link FileSystemSASPermissions} from the specified permissions string. This method will throw an
     * Error if it encounters a character that does not correspond to a valid permission.
     *
     * @static
     * @param {string} permissions
     * @returns {FileSystemSASPermissions}
     * @memberof FileSystemSASPermissions
     */
    FileSystemSASPermissions.parse = function (permissions) {
        var containerSASPermissions = new FileSystemSASPermissions();
        for (var _i = 0, permissions_1 = permissions; _i < permissions_1.length; _i++) {
            var char = permissions_1[_i];
            switch (char) {
                case "r":
                    containerSASPermissions.read = true;
                    break;
                case "a":
                    containerSASPermissions.add = true;
                    break;
                case "c":
                    containerSASPermissions.create = true;
                    break;
                case "w":
                    containerSASPermissions.write = true;
                    break;
                case "d":
                    containerSASPermissions.delete = true;
                    break;
                case "l":
                    containerSASPermissions.list = true;
                    break;
                default:
                    throw new RangeError("Invalid permission " + char);
            }
        }
        return containerSASPermissions;
    };
    /**
     * Converts the given permissions to a string. Using this method will guarantee the permissions are in an
     * order accepted by the service.
     *
     * The order of the characters should be as specified here to ensure correctness.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/constructing-a-service-sas
     *
     * @returns {string}
     * @memberof FileSystemSASPermissions
     */
    FileSystemSASPermissions.prototype.toString = function () {
        var permissions = [];
        if (this.read) {
            permissions.push("r");
        }
        if (this.add) {
            permissions.push("a");
        }
        if (this.create) {
            permissions.push("c");
        }
        if (this.write) {
            permissions.push("w");
        }
        if (this.delete) {
            permissions.push("d");
        }
        if (this.list) {
            permissions.push("l");
        }
        return permissions.join("");
    };
    return FileSystemSASPermissions;
}());

/**
 * ONLY AVAILABLE IN NODE.JS RUNTIME.
 *
 * UserDelegationKeyCredential is only used for generation of user delegation SAS.
 * @see https://docs.microsoft.com/en-us/rest/api/storageservices/create-user-delegation-sas
 *
 * @export
 * @class UserDelegationKeyCredential
 */
var UserDelegationKeyCredential = /** @class */ (function () {
    /**
     * Creates an instance of UserDelegationKeyCredential.
     * @param {string} accountName
     * @param {UserDelegationKey} userDelegationKey
     * @memberof UserDelegationKeyCredential
     */
    function UserDelegationKeyCredential(accountName, userDelegationKey) {
        this.accountName = accountName;
        this.userDelegationKey = userDelegationKey;
        this.key = Buffer.from(userDelegationKey.value, "base64");
    }
    /**
     * Generates a hash signature for an HTTP request or for a SAS.
     *
     * @param {string} stringToSign
     * @returns {string}
     * @memberof UserDelegationKeyCredential
     */
    UserDelegationKeyCredential.prototype.computeHMACSHA256 = function (stringToSign) {
        // console.log(`stringToSign: ${JSON.stringify(stringToSign)}`);
        return crypto.createHmac("sha256", this.key)
            .update(stringToSign, "utf8")
            .digest("base64");
    };
    return UserDelegationKeyCredential;
}());

// Copyright (c) Microsoft Corporation. All rights reserved.
function generateDataLakeSASQueryParameters(dataLakeSASSignatureValues, sharedKeyCredentialOrUserDelegationKey, accountName) {
    var version = dataLakeSASSignatureValues.version
        ? dataLakeSASSignatureValues.version
        : SERVICE_VERSION;
    var sharedKeyCredential = sharedKeyCredentialOrUserDelegationKey instanceof StorageSharedKeyCredential
        ? sharedKeyCredentialOrUserDelegationKey
        : undefined;
    var userDelegationKeyCredential;
    if (sharedKeyCredential === undefined && accountName !== undefined) {
        userDelegationKeyCredential = new UserDelegationKeyCredential(accountName, sharedKeyCredentialOrUserDelegationKey);
    }
    if (sharedKeyCredential === undefined && userDelegationKeyCredential === undefined) {
        throw TypeError("Invalid sharedKeyCredential, userDelegationKey or accountName.");
    }
    // Version 2018-11-09 adds support for the signed resource and signed blob snapshot time fields.
    // https://docs.microsoft.com/en-us/rest/api/storageservices/constructing-a-service-sas#constructing-the-signature-string
    if (version >= "2018-11-09") {
        if (sharedKeyCredential !== undefined) {
            return generateBlobSASQueryParameters20181109(dataLakeSASSignatureValues, sharedKeyCredential);
        }
        else {
            return generateBlobSASQueryParametersUDK20181109(dataLakeSASSignatureValues, userDelegationKeyCredential);
        }
    }
    if (version >= "2015-04-05") {
        if (sharedKeyCredential !== undefined) {
            return generateBlobSASQueryParameters20150405(dataLakeSASSignatureValues, sharedKeyCredential);
        }
        else {
            throw new RangeError("'version' must be >= '2018-11-09' when generating user delegation SAS using user delegation key.");
        }
    }
    throw new RangeError("'version' must be >= '2015-04-05'.");
}
/**
 * ONLY AVAILABLE IN NODE.JS RUNTIME.
 * IMPLEMENTATION FOR API VERSION FROM 2015-04-05 AND BEFORE 2018-11-09.
 *
 * Creates an instance of SASQueryParameters.
 *
 * Only accepts required settings needed to create a SAS. For optional settings please
 * set corresponding properties directly, such as permissions, startsOn and identifier.
 *
 * WARNING: When identifier is not provided, permissions and expiresOn are required.
 * You MUST assign value to identifier or expiresOn & permissions manually if you initial with
 * this constructor.
 *
 * @param {DataLakeSASSignatureValues} dataLakeSASSignatureValues
 * @param {StorageSharedKeyCredential} sharedKeyCredential
 * @returns {SASQueryParameters}
 */
function generateBlobSASQueryParameters20150405(dataLakeSASSignatureValues, sharedKeyCredential) {
    if (!dataLakeSASSignatureValues.identifier &&
        (!dataLakeSASSignatureValues.permissions && !dataLakeSASSignatureValues.expiresOn)) {
        throw new RangeError("Must provide 'permissions' and 'expiresOn' for DataLake SAS generation when 'identifier' is not provided.");
    }
    var version = dataLakeSASSignatureValues.version
        ? dataLakeSASSignatureValues.version
        : SERVICE_VERSION;
    var resource = "c";
    var verifiedPermissions;
    if (dataLakeSASSignatureValues.snapshotTime) {
        throw RangeError("'version' must be >= '2018-11-09' when provided 'snapshotTime'.");
    }
    // Calling parse and toString guarantees the proper ordering and throws on invalid characters.
    if (dataLakeSASSignatureValues.permissions) {
        if (dataLakeSASSignatureValues.pathName) {
            verifiedPermissions = DataLakeSASPermissions.parse(dataLakeSASSignatureValues.permissions.toString()).toString();
            resource = "b";
        }
        else {
            verifiedPermissions = FileSystemSASPermissions.parse(dataLakeSASSignatureValues.permissions.toString()).toString();
        }
    }
    // Signature is generated on the un-url-encoded values.
    var stringToSign = [
        verifiedPermissions ? verifiedPermissions : "",
        dataLakeSASSignatureValues.startsOn
            ? truncatedISO8061Date(dataLakeSASSignatureValues.startsOn, false)
            : "",
        dataLakeSASSignatureValues.expiresOn
            ? truncatedISO8061Date(dataLakeSASSignatureValues.expiresOn, false)
            : "",
        getCanonicalName(sharedKeyCredential.accountName, dataLakeSASSignatureValues.fileSystemName, dataLakeSASSignatureValues.pathName),
        dataLakeSASSignatureValues.identifier,
        dataLakeSASSignatureValues.ipRange ? ipRangeToString(dataLakeSASSignatureValues.ipRange) : "",
        dataLakeSASSignatureValues.protocol ? dataLakeSASSignatureValues.protocol : "",
        version,
        dataLakeSASSignatureValues.cacheControl ? dataLakeSASSignatureValues.cacheControl : "",
        dataLakeSASSignatureValues.contentDisposition
            ? dataLakeSASSignatureValues.contentDisposition
            : "",
        dataLakeSASSignatureValues.contentEncoding ? dataLakeSASSignatureValues.contentEncoding : "",
        dataLakeSASSignatureValues.contentLanguage ? dataLakeSASSignatureValues.contentLanguage : "",
        dataLakeSASSignatureValues.contentType ? dataLakeSASSignatureValues.contentType : ""
    ].join("\n");
    var signature = sharedKeyCredential.computeHMACSHA256(stringToSign);
    return new SASQueryParameters(version, signature, verifiedPermissions, undefined, undefined, dataLakeSASSignatureValues.protocol, dataLakeSASSignatureValues.startsOn, dataLakeSASSignatureValues.expiresOn, dataLakeSASSignatureValues.ipRange, dataLakeSASSignatureValues.identifier, resource, dataLakeSASSignatureValues.cacheControl, dataLakeSASSignatureValues.contentDisposition, dataLakeSASSignatureValues.contentEncoding, dataLakeSASSignatureValues.contentLanguage, dataLakeSASSignatureValues.contentType);
}
/**
 * ONLY AVAILABLE IN NODE.JS RUNTIME.
 * IMPLEMENTATION FOR API VERSION FROM 2018-11-09.
 *
 * Creates an instance of SASQueryParameters.
 *
 * Only accepts required settings needed to create a SAS. For optional settings please
 * set corresponding properties directly, such as permissions, startsOn and identifier.
 *
 * WARNING: When identifier is not provided, permissions and expiresOn are required.
 * You MUST assign value to identifier or expiresOn & permissions manually if you initial with
 * this constructor.
 *
 * @param {DataLakeSASSignatureValues} dataLakeSASSignatureValues
 * @param {StorageSharedKeyCredential} sharedKeyCredential
 * @returns {SASQueryParameters}
 */
function generateBlobSASQueryParameters20181109(dataLakeSASSignatureValues, sharedKeyCredential) {
    if (!dataLakeSASSignatureValues.identifier &&
        (!dataLakeSASSignatureValues.permissions && !dataLakeSASSignatureValues.expiresOn)) {
        throw new RangeError("Must provide 'permissions' and 'expiresOn' for Blob SAS generation when 'identifier' is not provided.");
    }
    var version = dataLakeSASSignatureValues.version
        ? dataLakeSASSignatureValues.version
        : SERVICE_VERSION;
    var resource = "c";
    var verifiedPermissions;
    if (dataLakeSASSignatureValues.pathName === undefined &&
        dataLakeSASSignatureValues.snapshotTime) {
        throw RangeError("Must provide 'blobName' when provided 'snapshotTime'.");
    }
    // Calling parse and toString guarantees the proper ordering and throws on invalid characters.
    if (dataLakeSASSignatureValues.permissions) {
        if (dataLakeSASSignatureValues.pathName) {
            verifiedPermissions = DataLakeSASPermissions.parse(dataLakeSASSignatureValues.permissions.toString()).toString();
            resource = "b";
            if (dataLakeSASSignatureValues.snapshotTime) {
                resource = "bs";
            }
        }
        else {
            verifiedPermissions = FileSystemSASPermissions.parse(dataLakeSASSignatureValues.permissions.toString()).toString();
        }
    }
    // Signature is generated on the un-url-encoded values.
    var stringToSign = [
        verifiedPermissions ? verifiedPermissions : "",
        dataLakeSASSignatureValues.startsOn
            ? truncatedISO8061Date(dataLakeSASSignatureValues.startsOn, false)
            : "",
        dataLakeSASSignatureValues.expiresOn
            ? truncatedISO8061Date(dataLakeSASSignatureValues.expiresOn, false)
            : "",
        getCanonicalName(sharedKeyCredential.accountName, dataLakeSASSignatureValues.fileSystemName, dataLakeSASSignatureValues.pathName),
        dataLakeSASSignatureValues.identifier,
        dataLakeSASSignatureValues.ipRange ? ipRangeToString(dataLakeSASSignatureValues.ipRange) : "",
        dataLakeSASSignatureValues.protocol ? dataLakeSASSignatureValues.protocol : "",
        version,
        resource,
        dataLakeSASSignatureValues.snapshotTime,
        dataLakeSASSignatureValues.cacheControl ? dataLakeSASSignatureValues.cacheControl : "",
        dataLakeSASSignatureValues.contentDisposition
            ? dataLakeSASSignatureValues.contentDisposition
            : "",
        dataLakeSASSignatureValues.contentEncoding ? dataLakeSASSignatureValues.contentEncoding : "",
        dataLakeSASSignatureValues.contentLanguage ? dataLakeSASSignatureValues.contentLanguage : "",
        dataLakeSASSignatureValues.contentType ? dataLakeSASSignatureValues.contentType : ""
    ].join("\n");
    var signature = sharedKeyCredential.computeHMACSHA256(stringToSign);
    return new SASQueryParameters(version, signature, verifiedPermissions, undefined, undefined, dataLakeSASSignatureValues.protocol, dataLakeSASSignatureValues.startsOn, dataLakeSASSignatureValues.expiresOn, dataLakeSASSignatureValues.ipRange, dataLakeSASSignatureValues.identifier, resource, dataLakeSASSignatureValues.cacheControl, dataLakeSASSignatureValues.contentDisposition, dataLakeSASSignatureValues.contentEncoding, dataLakeSASSignatureValues.contentLanguage, dataLakeSASSignatureValues.contentType);
}
/**
 * ONLY AVAILABLE IN NODE.JS RUNTIME.
 * IMPLEMENTATION FOR API VERSION FROM 2018-11-09.
 *
 * Creates an instance of SASQueryParameters.
 *
 * Only accepts required settings needed to create a SAS. For optional settings please
 * set corresponding properties directly, such as permissions, startsOn and identifier.
 *
 * WARNING: identifier will be ignored, permissions and expiresOn are required.
 *
 * @param {DataLakeSASSignatureValues} dataLakeSASSignatureValues
 * @param {UserDelegationKeyCredential} userDelegationKeyCredential
 * @returns {SASQueryParameters}
 */
function generateBlobSASQueryParametersUDK20181109(dataLakeSASSignatureValues, userDelegationKeyCredential) {
    if (!dataLakeSASSignatureValues.permissions || !dataLakeSASSignatureValues.expiresOn) {
        throw new RangeError("Must provide 'permissions' and 'expiresOn' for Blob SAS generation when generating user delegation SAS.");
    }
    var version = dataLakeSASSignatureValues.version
        ? dataLakeSASSignatureValues.version
        : SERVICE_VERSION;
    var resource = "c";
    var verifiedPermissions;
    if (dataLakeSASSignatureValues.pathName === undefined &&
        dataLakeSASSignatureValues.snapshotTime) {
        throw RangeError("Must provide 'blobName' when provided 'snapshotTime'.");
    }
    // Calling parse and toString guarantees the proper ordering and throws on invalid characters.
    if (dataLakeSASSignatureValues.permissions) {
        if (dataLakeSASSignatureValues.pathName) {
            verifiedPermissions = DataLakeSASPermissions.parse(dataLakeSASSignatureValues.permissions.toString()).toString();
            resource = "b";
            if (dataLakeSASSignatureValues.snapshotTime) {
                resource = "bs";
            }
        }
        else {
            verifiedPermissions = FileSystemSASPermissions.parse(dataLakeSASSignatureValues.permissions.toString()).toString();
        }
    }
    // Signature is generated on the un-url-encoded values.
    var stringToSign = [
        verifiedPermissions ? verifiedPermissions : "",
        dataLakeSASSignatureValues.startsOn
            ? truncatedISO8061Date(dataLakeSASSignatureValues.startsOn, false)
            : "",
        dataLakeSASSignatureValues.expiresOn
            ? truncatedISO8061Date(dataLakeSASSignatureValues.expiresOn, false)
            : "",
        getCanonicalName(userDelegationKeyCredential.accountName, dataLakeSASSignatureValues.fileSystemName, dataLakeSASSignatureValues.pathName),
        userDelegationKeyCredential.userDelegationKey.signedObjectId,
        userDelegationKeyCredential.userDelegationKey.signedTenantId,
        userDelegationKeyCredential.userDelegationKey.signedStartsOn
            ? truncatedISO8061Date(userDelegationKeyCredential.userDelegationKey.signedStartsOn, false)
            : "",
        userDelegationKeyCredential.userDelegationKey.signedExpiresOn
            ? truncatedISO8061Date(userDelegationKeyCredential.userDelegationKey.signedExpiresOn, false)
            : "",
        userDelegationKeyCredential.userDelegationKey.signedService,
        userDelegationKeyCredential.userDelegationKey.signedVersion,
        dataLakeSASSignatureValues.ipRange ? ipRangeToString(dataLakeSASSignatureValues.ipRange) : "",
        dataLakeSASSignatureValues.protocol ? dataLakeSASSignatureValues.protocol : "",
        version,
        resource,
        dataLakeSASSignatureValues.snapshotTime,
        dataLakeSASSignatureValues.cacheControl,
        dataLakeSASSignatureValues.contentDisposition,
        dataLakeSASSignatureValues.contentEncoding,
        dataLakeSASSignatureValues.contentLanguage,
        dataLakeSASSignatureValues.contentType
    ].join("\n");
    var signature = userDelegationKeyCredential.computeHMACSHA256(stringToSign);
    return new SASQueryParameters(version, signature, verifiedPermissions, undefined, undefined, dataLakeSASSignatureValues.protocol, dataLakeSASSignatureValues.startsOn, dataLakeSASSignatureValues.expiresOn, dataLakeSASSignatureValues.ipRange, dataLakeSASSignatureValues.identifier, resource, dataLakeSASSignatureValues.cacheControl, dataLakeSASSignatureValues.contentDisposition, dataLakeSASSignatureValues.contentEncoding, dataLakeSASSignatureValues.contentLanguage, dataLakeSASSignatureValues.contentType, userDelegationKeyCredential.userDelegationKey);
}
function getCanonicalName(accountName, containerName, blobName) {
    // FileSystem: "/blob/account/fileSystemName"
    // File:       "/blob/account/fileSystemName/fileName"
    var elements = ["/blob/" + accountName + "/" + containerName];
    if (blobName) {
        elements.push("/" + blobName);
    }
    return elements.join("");
}

Object.defineProperty(exports, 'BaseRequestPolicy', {
    enumerable: true,
    get: function () {
        return coreHttp.BaseRequestPolicy;
    }
});
Object.defineProperty(exports, 'HttpHeaders', {
    enumerable: true,
    get: function () {
        return coreHttp.HttpHeaders;
    }
});
Object.defineProperty(exports, 'RequestPolicyOptions', {
    enumerable: true,
    get: function () {
        return coreHttp.RequestPolicyOptions;
    }
});
Object.defineProperty(exports, 'RestError', {
    enumerable: true,
    get: function () {
        return coreHttp.RestError;
    }
});
Object.defineProperty(exports, 'WebResource', {
    enumerable: true,
    get: function () {
        return coreHttp.WebResource;
    }
});
Object.defineProperty(exports, 'deserializationPolicy', {
    enumerable: true,
    get: function () {
        return coreHttp.deserializationPolicy;
    }
});
exports.AccountSASPermissions = AccountSASPermissions;
exports.AccountSASResourceTypes = AccountSASResourceTypes;
exports.AccountSASServices = AccountSASServices;
exports.AnonymousCredential = AnonymousCredential;
exports.AnonymousCredentialPolicy = AnonymousCredentialPolicy;
exports.Credential = Credential;
exports.CredentialPolicy = CredentialPolicy;
exports.DataLakeDirectoryClient = DataLakeDirectoryClient;
exports.DataLakeFileClient = DataLakeFileClient;
exports.DataLakeFileSystemClient = DataLakeFileSystemClient;
exports.DataLakeLeaseClient = DataLakeLeaseClient;
exports.DataLakePathClient = DataLakePathClient;
exports.DataLakeSASPermissions = DataLakeSASPermissions;
exports.DataLakeServiceClient = DataLakeServiceClient;
exports.FileSystemSASPermissions = FileSystemSASPermissions;
exports.Pipeline = Pipeline;
exports.SASQueryParameters = SASQueryParameters;
exports.StorageBrowserPolicy = StorageBrowserPolicy;
exports.StorageBrowserPolicyFactory = StorageBrowserPolicyFactory;
exports.StorageOAuthScopes = StorageOAuthScopes;
exports.StorageRetryPolicy = StorageRetryPolicy;
exports.StorageRetryPolicyFactory = StorageRetryPolicyFactory;
exports.StorageSharedKeyCredential = StorageSharedKeyCredential;
exports.StorageSharedKeyCredentialPolicy = StorageSharedKeyCredentialPolicy;
exports.ToBlobEndpointHostMappings = ToBlobEndpointHostMappings;
exports.ToDfsEndpointHostMappings = ToDfsEndpointHostMappings;
exports.generateAccountSASQueryParameters = generateAccountSASQueryParameters;
exports.generateDataLakeSASQueryParameters = generateDataLakeSASQueryParameters;
exports.logger = logger;
exports.newPipeline = newPipeline;
//# sourceMappingURL=index.js.map
