// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
import { DataLakeSASPermissions } from "./DataLakeSASPermissions";
import { FileSystemSASPermissions } from "./FileSystemSASPermissions";
import { StorageSharedKeyCredential } from "./credentials/StorageSharedKeyCredential";
import { ipRangeToString } from "./SasIPRange";
import { SASQueryParameters } from "./SASQueryParameters";
import { UserDelegationKeyCredential } from "./credentials/UserDelegationKeyCredential";
import { SERVICE_VERSION } from "./utils/constants";
import { truncatedISO8061Date } from "./utils/utils.common";
export function generateDataLakeSASQueryParameters(dataLakeSASSignatureValues, sharedKeyCredentialOrUserDelegationKey, accountName) {
    var version = dataLakeSASSignatureValues.version
        ? dataLakeSASSignatureValues.version
        : SERVICE_VERSION;
    var sharedKeyCredential = sharedKeyCredentialOrUserDelegationKey instanceof StorageSharedKeyCredential
        ? sharedKeyCredentialOrUserDelegationKey
        : undefined;
    var userDelegationKeyCredential;
    if (sharedKeyCredential === undefined && accountName !== undefined) {
        userDelegationKeyCredential = new UserDelegationKeyCredential(accountName, sharedKeyCredentialOrUserDelegationKey);
    }
    if (sharedKeyCredential === undefined && userDelegationKeyCredential === undefined) {
        throw TypeError("Invalid sharedKeyCredential, userDelegationKey or accountName.");
    }
    // Version 2018-11-09 adds support for the signed resource and signed blob snapshot time fields.
    // https://docs.microsoft.com/en-us/rest/api/storageservices/constructing-a-service-sas#constructing-the-signature-string
    if (version >= "2018-11-09") {
        if (sharedKeyCredential !== undefined) {
            return generateBlobSASQueryParameters20181109(dataLakeSASSignatureValues, sharedKeyCredential);
        }
        else {
            return generateBlobSASQueryParametersUDK20181109(dataLakeSASSignatureValues, userDelegationKeyCredential);
        }
    }
    if (version >= "2015-04-05") {
        if (sharedKeyCredential !== undefined) {
            return generateBlobSASQueryParameters20150405(dataLakeSASSignatureValues, sharedKeyCredential);
        }
        else {
            throw new RangeError("'version' must be >= '2018-11-09' when generating user delegation SAS using user delegation key.");
        }
    }
    throw new RangeError("'version' must be >= '2015-04-05'.");
}
/**
 * ONLY AVAILABLE IN NODE.JS RUNTIME.
 * IMPLEMENTATION FOR API VERSION FROM 2015-04-05 AND BEFORE 2018-11-09.
 *
 * Creates an instance of SASQueryParameters.
 *
 * Only accepts required settings needed to create a SAS. For optional settings please
 * set corresponding properties directly, such as permissions, startsOn and identifier.
 *
 * WARNING: When identifier is not provided, permissions and expiresOn are required.
 * You MUST assign value to identifier or expiresOn & permissions manually if you initial with
 * this constructor.
 *
 * @param {DataLakeSASSignatureValues} dataLakeSASSignatureValues
 * @param {StorageSharedKeyCredential} sharedKeyCredential
 * @returns {SASQueryParameters}
 */
function generateBlobSASQueryParameters20150405(dataLakeSASSignatureValues, sharedKeyCredential) {
    if (!dataLakeSASSignatureValues.identifier &&
        (!dataLakeSASSignatureValues.permissions && !dataLakeSASSignatureValues.expiresOn)) {
        throw new RangeError("Must provide 'permissions' and 'expiresOn' for DataLake SAS generation when 'identifier' is not provided.");
    }
    var version = dataLakeSASSignatureValues.version
        ? dataLakeSASSignatureValues.version
        : SERVICE_VERSION;
    var resource = "c";
    var verifiedPermissions;
    if (dataLakeSASSignatureValues.snapshotTime) {
        throw RangeError("'version' must be >= '2018-11-09' when provided 'snapshotTime'.");
    }
    // Calling parse and toString guarantees the proper ordering and throws on invalid characters.
    if (dataLakeSASSignatureValues.permissions) {
        if (dataLakeSASSignatureValues.pathName) {
            verifiedPermissions = DataLakeSASPermissions.parse(dataLakeSASSignatureValues.permissions.toString()).toString();
            resource = "b";
        }
        else {
            verifiedPermissions = FileSystemSASPermissions.parse(dataLakeSASSignatureValues.permissions.toString()).toString();
        }
    }
    // Signature is generated on the un-url-encoded values.
    var stringToSign = [
        verifiedPermissions ? verifiedPermissions : "",
        dataLakeSASSignatureValues.startsOn
            ? truncatedISO8061Date(dataLakeSASSignatureValues.startsOn, false)
            : "",
        dataLakeSASSignatureValues.expiresOn
            ? truncatedISO8061Date(dataLakeSASSignatureValues.expiresOn, false)
            : "",
        getCanonicalName(sharedKeyCredential.accountName, dataLakeSASSignatureValues.fileSystemName, dataLakeSASSignatureValues.pathName),
        dataLakeSASSignatureValues.identifier,
        dataLakeSASSignatureValues.ipRange ? ipRangeToString(dataLakeSASSignatureValues.ipRange) : "",
        dataLakeSASSignatureValues.protocol ? dataLakeSASSignatureValues.protocol : "",
        version,
        dataLakeSASSignatureValues.cacheControl ? dataLakeSASSignatureValues.cacheControl : "",
        dataLakeSASSignatureValues.contentDisposition
            ? dataLakeSASSignatureValues.contentDisposition
            : "",
        dataLakeSASSignatureValues.contentEncoding ? dataLakeSASSignatureValues.contentEncoding : "",
        dataLakeSASSignatureValues.contentLanguage ? dataLakeSASSignatureValues.contentLanguage : "",
        dataLakeSASSignatureValues.contentType ? dataLakeSASSignatureValues.contentType : ""
    ].join("\n");
    var signature = sharedKeyCredential.computeHMACSHA256(stringToSign);
    return new SASQueryParameters(version, signature, verifiedPermissions, undefined, undefined, dataLakeSASSignatureValues.protocol, dataLakeSASSignatureValues.startsOn, dataLakeSASSignatureValues.expiresOn, dataLakeSASSignatureValues.ipRange, dataLakeSASSignatureValues.identifier, resource, dataLakeSASSignatureValues.cacheControl, dataLakeSASSignatureValues.contentDisposition, dataLakeSASSignatureValues.contentEncoding, dataLakeSASSignatureValues.contentLanguage, dataLakeSASSignatureValues.contentType);
}
/**
 * ONLY AVAILABLE IN NODE.JS RUNTIME.
 * IMPLEMENTATION FOR API VERSION FROM 2018-11-09.
 *
 * Creates an instance of SASQueryParameters.
 *
 * Only accepts required settings needed to create a SAS. For optional settings please
 * set corresponding properties directly, such as permissions, startsOn and identifier.
 *
 * WARNING: When identifier is not provided, permissions and expiresOn are required.
 * You MUST assign value to identifier or expiresOn & permissions manually if you initial with
 * this constructor.
 *
 * @param {DataLakeSASSignatureValues} dataLakeSASSignatureValues
 * @param {StorageSharedKeyCredential} sharedKeyCredential
 * @returns {SASQueryParameters}
 */
function generateBlobSASQueryParameters20181109(dataLakeSASSignatureValues, sharedKeyCredential) {
    if (!dataLakeSASSignatureValues.identifier &&
        (!dataLakeSASSignatureValues.permissions && !dataLakeSASSignatureValues.expiresOn)) {
        throw new RangeError("Must provide 'permissions' and 'expiresOn' for Blob SAS generation when 'identifier' is not provided.");
    }
    var version = dataLakeSASSignatureValues.version
        ? dataLakeSASSignatureValues.version
        : SERVICE_VERSION;
    var resource = "c";
    var verifiedPermissions;
    if (dataLakeSASSignatureValues.pathName === undefined &&
        dataLakeSASSignatureValues.snapshotTime) {
        throw RangeError("Must provide 'blobName' when provided 'snapshotTime'.");
    }
    // Calling parse and toString guarantees the proper ordering and throws on invalid characters.
    if (dataLakeSASSignatureValues.permissions) {
        if (dataLakeSASSignatureValues.pathName) {
            verifiedPermissions = DataLakeSASPermissions.parse(dataLakeSASSignatureValues.permissions.toString()).toString();
            resource = "b";
            if (dataLakeSASSignatureValues.snapshotTime) {
                resource = "bs";
            }
        }
        else {
            verifiedPermissions = FileSystemSASPermissions.parse(dataLakeSASSignatureValues.permissions.toString()).toString();
        }
    }
    // Signature is generated on the un-url-encoded values.
    var stringToSign = [
        verifiedPermissions ? verifiedPermissions : "",
        dataLakeSASSignatureValues.startsOn
            ? truncatedISO8061Date(dataLakeSASSignatureValues.startsOn, false)
            : "",
        dataLakeSASSignatureValues.expiresOn
            ? truncatedISO8061Date(dataLakeSASSignatureValues.expiresOn, false)
            : "",
        getCanonicalName(sharedKeyCredential.accountName, dataLakeSASSignatureValues.fileSystemName, dataLakeSASSignatureValues.pathName),
        dataLakeSASSignatureValues.identifier,
        dataLakeSASSignatureValues.ipRange ? ipRangeToString(dataLakeSASSignatureValues.ipRange) : "",
        dataLakeSASSignatureValues.protocol ? dataLakeSASSignatureValues.protocol : "",
        version,
        resource,
        dataLakeSASSignatureValues.snapshotTime,
        dataLakeSASSignatureValues.cacheControl ? dataLakeSASSignatureValues.cacheControl : "",
        dataLakeSASSignatureValues.contentDisposition
            ? dataLakeSASSignatureValues.contentDisposition
            : "",
        dataLakeSASSignatureValues.contentEncoding ? dataLakeSASSignatureValues.contentEncoding : "",
        dataLakeSASSignatureValues.contentLanguage ? dataLakeSASSignatureValues.contentLanguage : "",
        dataLakeSASSignatureValues.contentType ? dataLakeSASSignatureValues.contentType : ""
    ].join("\n");
    var signature = sharedKeyCredential.computeHMACSHA256(stringToSign);
    return new SASQueryParameters(version, signature, verifiedPermissions, undefined, undefined, dataLakeSASSignatureValues.protocol, dataLakeSASSignatureValues.startsOn, dataLakeSASSignatureValues.expiresOn, dataLakeSASSignatureValues.ipRange, dataLakeSASSignatureValues.identifier, resource, dataLakeSASSignatureValues.cacheControl, dataLakeSASSignatureValues.contentDisposition, dataLakeSASSignatureValues.contentEncoding, dataLakeSASSignatureValues.contentLanguage, dataLakeSASSignatureValues.contentType);
}
/**
 * ONLY AVAILABLE IN NODE.JS RUNTIME.
 * IMPLEMENTATION FOR API VERSION FROM 2018-11-09.
 *
 * Creates an instance of SASQueryParameters.
 *
 * Only accepts required settings needed to create a SAS. For optional settings please
 * set corresponding properties directly, such as permissions, startsOn and identifier.
 *
 * WARNING: identifier will be ignored, permissions and expiresOn are required.
 *
 * @param {DataLakeSASSignatureValues} dataLakeSASSignatureValues
 * @param {UserDelegationKeyCredential} userDelegationKeyCredential
 * @returns {SASQueryParameters}
 */
function generateBlobSASQueryParametersUDK20181109(dataLakeSASSignatureValues, userDelegationKeyCredential) {
    if (!dataLakeSASSignatureValues.permissions || !dataLakeSASSignatureValues.expiresOn) {
        throw new RangeError("Must provide 'permissions' and 'expiresOn' for Blob SAS generation when generating user delegation SAS.");
    }
    var version = dataLakeSASSignatureValues.version
        ? dataLakeSASSignatureValues.version
        : SERVICE_VERSION;
    var resource = "c";
    var verifiedPermissions;
    if (dataLakeSASSignatureValues.pathName === undefined &&
        dataLakeSASSignatureValues.snapshotTime) {
        throw RangeError("Must provide 'blobName' when provided 'snapshotTime'.");
    }
    // Calling parse and toString guarantees the proper ordering and throws on invalid characters.
    if (dataLakeSASSignatureValues.permissions) {
        if (dataLakeSASSignatureValues.pathName) {
            verifiedPermissions = DataLakeSASPermissions.parse(dataLakeSASSignatureValues.permissions.toString()).toString();
            resource = "b";
            if (dataLakeSASSignatureValues.snapshotTime) {
                resource = "bs";
            }
        }
        else {
            verifiedPermissions = FileSystemSASPermissions.parse(dataLakeSASSignatureValues.permissions.toString()).toString();
        }
    }
    // Signature is generated on the un-url-encoded values.
    var stringToSign = [
        verifiedPermissions ? verifiedPermissions : "",
        dataLakeSASSignatureValues.startsOn
            ? truncatedISO8061Date(dataLakeSASSignatureValues.startsOn, false)
            : "",
        dataLakeSASSignatureValues.expiresOn
            ? truncatedISO8061Date(dataLakeSASSignatureValues.expiresOn, false)
            : "",
        getCanonicalName(userDelegationKeyCredential.accountName, dataLakeSASSignatureValues.fileSystemName, dataLakeSASSignatureValues.pathName),
        userDelegationKeyCredential.userDelegationKey.signedObjectId,
        userDelegationKeyCredential.userDelegationKey.signedTenantId,
        userDelegationKeyCredential.userDelegationKey.signedStartsOn
            ? truncatedISO8061Date(userDelegationKeyCredential.userDelegationKey.signedStartsOn, false)
            : "",
        userDelegationKeyCredential.userDelegationKey.signedExpiresOn
            ? truncatedISO8061Date(userDelegationKeyCredential.userDelegationKey.signedExpiresOn, false)
            : "",
        userDelegationKeyCredential.userDelegationKey.signedService,
        userDelegationKeyCredential.userDelegationKey.signedVersion,
        dataLakeSASSignatureValues.ipRange ? ipRangeToString(dataLakeSASSignatureValues.ipRange) : "",
        dataLakeSASSignatureValues.protocol ? dataLakeSASSignatureValues.protocol : "",
        version,
        resource,
        dataLakeSASSignatureValues.snapshotTime,
        dataLakeSASSignatureValues.cacheControl,
        dataLakeSASSignatureValues.contentDisposition,
        dataLakeSASSignatureValues.contentEncoding,
        dataLakeSASSignatureValues.contentLanguage,
        dataLakeSASSignatureValues.contentType
    ].join("\n");
    var signature = userDelegationKeyCredential.computeHMACSHA256(stringToSign);
    return new SASQueryParameters(version, signature, verifiedPermissions, undefined, undefined, dataLakeSASSignatureValues.protocol, dataLakeSASSignatureValues.startsOn, dataLakeSASSignatureValues.expiresOn, dataLakeSASSignatureValues.ipRange, dataLakeSASSignatureValues.identifier, resource, dataLakeSASSignatureValues.cacheControl, dataLakeSASSignatureValues.contentDisposition, dataLakeSASSignatureValues.contentEncoding, dataLakeSASSignatureValues.contentLanguage, dataLakeSASSignatureValues.contentType, userDelegationKeyCredential.userDelegationKey);
}
function getCanonicalName(accountName, containerName, blobName) {
    // FileSystem: "/blob/account/fileSystemName"
    // File:       "/blob/account/fileSystemName/fileName"
    var elements = ["/blob/" + accountName + "/" + containerName];
    if (blobName) {
        elements.push("/" + blobName);
    }
    return elements.join("");
}
//# sourceMappingURL=DataLakeSASSignatureValues.js.map