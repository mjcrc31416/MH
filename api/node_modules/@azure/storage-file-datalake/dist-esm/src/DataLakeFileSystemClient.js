import { __assign, __asyncDelegator, __asyncGenerator, __asyncValues, __await, __awaiter, __extends, __generator, __values } from "tslib";
import { ContainerClient } from "@azure/storage-blob";
import { CanonicalCode } from "@opentelemetry/types";
import { AnonymousCredential } from "./credentials/AnonymousCredential";
import { DataLakeLeaseClient } from "./DataLakeLeaseClient";
import { FileSystemOperations } from "./generated/src/operations";
import { newPipeline, Pipeline } from "./Pipeline";
import { StorageClient } from "./StorageClient";
import { toContainerPublicAccessType, toPublicAccessType, toPermissions } from "./transforms";
import { createSpan } from "./utils/tracing";
import { appendToURLPath } from "./utils/utils.common";
import { DataLakeFileClient, DataLakeDirectoryClient } from "./clients";
import { getCachedDefaultHttpClient } from "./utils/cache";
/**
 * A DataLakeFileSystemClient represents a URL to the Azure Storage file system
 * allowing you to manipulate its directories and files.
 *
 * @export
 * @class DataLakeFileSystemClient
 * @extends {StorageClient}
 */
var DataLakeFileSystemClient = /** @class */ (function (_super) {
    __extends(DataLakeFileSystemClient, _super);
    function DataLakeFileSystemClient(url, credentialOrPipeline, options) {
        var _this = this;
        // when options.httpClient is not specified, passing in a DefaultHttpClient instance to
        // avoid each client creating its own http client.
        var newOptions = __assign({ httpClient: getCachedDefaultHttpClient() }, options);
        if (credentialOrPipeline instanceof Pipeline) {
            _this = _super.call(this, url, credentialOrPipeline) || this;
        }
        else {
            var credential = void 0;
            if (credentialOrPipeline === undefined) {
                credential = new AnonymousCredential();
            }
            else {
                credential = credentialOrPipeline;
            }
            var pipeline = newPipeline(credential, newOptions);
            _this = _super.call(this, url, pipeline) || this;
        }
        _this.fileSystemContext = new FileSystemOperations(_this.storageClientContext);
        _this.blobContainerClient = new ContainerClient(_this.blobEndpointUrl, _this.pipeline);
        return _this;
    }
    Object.defineProperty(DataLakeFileSystemClient.prototype, "name", {
        /**
         * Name of current file system.
         *
         * @readonly
         * @type {string}
         * @memberof DataLakeFileSystemClient
         */
        get: function () {
            return this.blobContainerClient.containerName;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Creates a {@link DataLakeDirectoryClient} object under current file system.
     *
     * @param {string} directoryName
     * @returns {DataLakeDirectoryClient}
     * @memberof DataLakeFileSystemClient
     */
    DataLakeFileSystemClient.prototype.getDirectoryClient = function (directoryName) {
        return new DataLakeDirectoryClient(appendToURLPath(this.url, encodeURIComponent(directoryName)), this.pipeline);
    };
    /**
     * Creates a {@link DataLakeFileClient} object under current file system.
     *
     * @param {string} fileName
     * @returns {DataLakeFileClient}
     * @memberof DataLakeFileSystemClient
     */
    DataLakeFileSystemClient.prototype.getFileClient = function (fileName) {
        return new DataLakeFileClient(appendToURLPath(this.url, encodeURIComponent(fileName)), this.pipeline);
    };
    /**
     * Get a {@link DataLakeLeaseClient} that manages leases on the file system.
     *
     * @param {string} [proposeLeaseId] Optional. Initial proposed lease Id.
     * @returns {DataLakeLeaseClient}
     * @memberof DataLakeFileSystemClient
     */
    DataLakeFileSystemClient.prototype.getDataLakeLeaseClient = function (proposeLeaseId) {
        return new DataLakeLeaseClient(this.blobContainerClient.getBlobLeaseClient(proposeLeaseId));
    };
    /**
     * Creates a new file system under the specified account. If the file system with
     * the same name already exists, the operation fails.
     *
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/create-container
     *
     * @param {FileSystemCreateOptions} [options={}] Optional. Options when creating file system.
     * @returns {Promise<FileSystemCreateResponse>}
     * @memberof DataLakeFileSystemClient
     */
    DataLakeFileSystemClient.prototype.create = function (options) {
        if (options === void 0) { options = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var _a, span, spanOptions, e_1;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = createSpan("DataLakeFileSystemClient-create", options.tracingOptions), span = _a.span, spanOptions = _a.spanOptions;
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 3, 4, 5]);
                        return [4 /*yield*/, this.blobContainerClient.create(__assign(__assign({}, options), { access: toContainerPublicAccessType(options.access), tracingOptions: __assign(__assign({}, options.tracingOptions), { spanOptions: spanOptions }) }))];
                    case 2: return [2 /*return*/, _b.sent()];
                    case 3:
                        e_1 = _b.sent();
                        span.setStatus({
                            code: CanonicalCode.UNKNOWN,
                            message: e_1.message
                        });
                        throw e_1;
                    case 4:
                        span.end();
                        return [7 /*endfinally*/];
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Delete current file system.
     *
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/delete-container
     *
     * @param {FileSystemDeleteOptions} [options={}] Optional. Options when deleting file system.
     * @returns {Promise<FileSystemDeleteResponse>}
     * @memberof DataLakeFileSystemClient
     */
    DataLakeFileSystemClient.prototype.delete = function (options) {
        if (options === void 0) { options = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var _a, span, spanOptions, e_2;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = createSpan("DataLakeFileSystemClient-delete", options.tracingOptions), span = _a.span, spanOptions = _a.spanOptions;
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 3, 4, 5]);
                        return [4 /*yield*/, this.blobContainerClient.delete(__assign(__assign({}, options), { tracingOptions: __assign(__assign({}, options.tracingOptions), { spanOptions: spanOptions }) }))];
                    case 2: return [2 /*return*/, _b.sent()];
                    case 3:
                        e_2 = _b.sent();
                        span.setStatus({
                            code: CanonicalCode.UNKNOWN,
                            message: e_2.message
                        });
                        throw e_2;
                    case 4:
                        span.end();
                        return [7 /*endfinally*/];
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Returns all user-defined metadata and system properties for the specified
     * file system.
     *
     * WARNING: The `metadata` object returned in the response will have its keys in lowercase, even if
     * they originally contained uppercase characters. This differs from the metadata keys returned by
     * the `listFileSystems` method of {@link DataLakeServiceClient} using the `includeMetadata` option, which
     * will retain their original casing.
     *
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/get-container-properties
     *
     * @param {FileSystemGetPropertiesOptions} [options={}] Optional. Options when getting file system properties.
     * @returns {Promise<FileSystemGetPropertiesResponse>}
     * @memberof DataLakeFileSystemClient
     */
    DataLakeFileSystemClient.prototype.getProperties = function (options) {
        if (options === void 0) { options = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var _a, span, spanOptions, rawResponse, response, e_3;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = createSpan("DataLakeFileSystemClient-getProperties", options.tracingOptions), span = _a.span, spanOptions = _a.spanOptions;
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 3, 4, 5]);
                        return [4 /*yield*/, this.blobContainerClient.getProperties(__assign(__assign({}, options), { tracingOptions: __assign(__assign({}, options.tracingOptions), { spanOptions: spanOptions }) }))];
                    case 2:
                        rawResponse = _b.sent();
                        response = rawResponse;
                        response.publicAccess = toPublicAccessType(rawResponse.blobPublicAccess);
                        response._response.parsedHeaders.publicAccess = response.publicAccess;
                        delete rawResponse.blobPublicAccess;
                        delete rawResponse._response.parsedHeaders.blobPublicAccess;
                        return [2 /*return*/, response];
                    case 3:
                        e_3 = _b.sent();
                        span.setStatus({
                            code: CanonicalCode.UNKNOWN,
                            message: e_3.message
                        });
                        throw e_3;
                    case 4:
                        span.end();
                        return [7 /*endfinally*/];
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Sets one or more user-defined name-value pairs for the specified file system.
     *
     * If no option provided, or no metadata defined in the parameter, the file system
     * metadata will be removed.
     *
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/set-container-metadata
     *
     * @param {Metadata} [metadata] Replace existing metadata with this value.
     *                              If no value provided the existing metadata will be removed.
     * @param {FileSystemSetMetadataOptions} [options={}] Optional. Options when setting file system metadata.
     * @returns {Promise<FileSystemSetMetadataResponse>}
     * @memberof DataLakeFileSystemClient
     */
    DataLakeFileSystemClient.prototype.setMetadata = function (metadata, options) {
        if (options === void 0) { options = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var _a, span, spanOptions, e_4;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = createSpan("DataLakeFileSystemClient-setMetadata", options.tracingOptions), span = _a.span, spanOptions = _a.spanOptions;
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 3, 4, 5]);
                        return [4 /*yield*/, this.blobContainerClient.setMetadata(metadata, __assign(__assign({}, options), { tracingOptions: __assign(__assign({}, options.tracingOptions), { spanOptions: spanOptions }) }))];
                    case 2: return [2 /*return*/, _b.sent()];
                    case 3:
                        e_4 = _b.sent();
                        span.setStatus({
                            code: CanonicalCode.UNKNOWN,
                            message: e_4.message
                        });
                        throw e_4;
                    case 4:
                        span.end();
                        return [7 /*endfinally*/];
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Gets the permissions for the specified file system. The permissions indicate
     * whether file system data may be accessed publicly.
     *
     * WARNING: JavaScript Date will potentially lose precision when parsing startsOn and expiresOn strings.
     * For example, new Date("2018-12-31T03:44:23.8827891Z").toISOString() will get "2018-12-31T03:44:23.882Z".
     *
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/get-container-acl
     *
     * @param {FileSystemGetAccessPolicyOptions} [options={}] Optional. Options when getting file system access policy.
     * @returns {Promise<FileSystemGetAccessPolicyResponse>}
     * @memberof DataLakeFileSystemClient
     */
    DataLakeFileSystemClient.prototype.getAccessPolicy = function (options) {
        if (options === void 0) { options = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var _a, span, spanOptions, rawResponse, response, e_5;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = createSpan("DataLakeFileSystemClient-getAccessPolicy", options.tracingOptions), span = _a.span, spanOptions = _a.spanOptions;
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 3, 4, 5]);
                        return [4 /*yield*/, this.blobContainerClient.getAccessPolicy(__assign(__assign({}, options), { tracingOptions: __assign(__assign({}, options.tracingOptions), { spanOptions: spanOptions }) }))];
                    case 2:
                        rawResponse = _b.sent();
                        response = rawResponse;
                        response.publicAccess = toPublicAccessType(rawResponse.blobPublicAccess);
                        response._response.parsedHeaders.publicAccess = response.publicAccess;
                        delete rawResponse.blobPublicAccess;
                        delete rawResponse._response.parsedHeaders.blobPublicAccess;
                        return [2 /*return*/, response];
                    case 3:
                        e_5 = _b.sent();
                        span.setStatus({
                            code: CanonicalCode.UNKNOWN,
                            message: e_5.message
                        });
                        throw e_5;
                    case 4:
                        span.end();
                        return [7 /*endfinally*/];
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Sets the permissions for the specified file system. The permissions indicate
     * whether directories or files in a file system may be accessed publicly.
     *
     * When you set permissions for a file system, the existing permissions are replaced.
     * If no access or containerAcl provided, the existing file system ACL will be
     * removed.
     *
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/set-container-acl
     *
     * @param {PublicAccessType} [access] Optional. The level of public access to data in the file system.
     * @param {SignedIdentifier<AccessPolicy>[]} [fileSystemAcl] Optional. Array of elements each having a unique Id and details of the access policy.
     * @param {FileSystemSetAccessPolicyOptions} [options={}] Optional. Options when setting file system access policy.
     * @returns {Promise<FileSystemSetAccessPolicyResponse>}
     * @memberof DataLakeFileSystemClient
     */
    DataLakeFileSystemClient.prototype.setAccessPolicy = function (access, fileSystemAcl, options) {
        if (options === void 0) { options = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var _a, span, spanOptions, e_6;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = createSpan("DataLakeFileSystemClient-setAccessPolicy", options.tracingOptions), span = _a.span, spanOptions = _a.spanOptions;
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 3, 4, 5]);
                        return [4 /*yield*/, this.blobContainerClient.setAccessPolicy(toContainerPublicAccessType(access), fileSystemAcl, __assign(__assign({}, options), { tracingOptions: __assign(__assign({}, options.tracingOptions), { spanOptions: spanOptions }) }))];
                    case 2: return [2 /*return*/, _b.sent()];
                    case 3:
                        e_6 = _b.sent();
                        span.setStatus({
                            code: CanonicalCode.UNKNOWN,
                            message: e_6.message
                        });
                        throw e_6;
                    case 4:
                        span.end();
                        return [7 /*endfinally*/];
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Returns an async iterable iterator to list all the paths (directories and files)
     * under the specified file system.
     *
     * .byPage() returns an async iterable iterator to list the paths in pages.
     *
     * Example using `for await` syntax:
     *
     * ```js
     * // Get the fileSystemClient before you run these snippets,
     * // Can be obtained from `serviceClient.getFileSystemClient("<your-filesystem-name>");`
     * let i = 1;
     * for await (const path of fileSystemClient.listPaths()) {
     *   console.log(`Path ${i++}: ${path.name}, isDirectory?: ${path.isDirectory}`);
     * }
     * ```
     *
     * Example using `iter.next()`:
     *
     * ```js
     * let i = 1;
     * let iter = fileSystemClient.listPaths();
     * let pathItem = await iter.next();
     * while (!pathItem.done) {
     *   console.log(`Path ${i++}: ${pathItem.value.name}, isDirectory?: ${pathItem.value.isDirectory}`);
     *   pathItem = await iter.next();
     * }
     * ```
     *
     * Example using `byPage()`:
     *
     * ```js
     * // passing optional maxPageSize in the page settings
     * let i = 1;
     * for await (const response of fileSystemClient.listPaths().byPage({ maxPageSize: 20 })) {
     *   for (const path of response.pathItems) {
     *     console.log(`Path ${i++}: ${path.name}, isDirectory?: ${path.isDirectory}`);
     *   }
     * }
     * ```
     *
     * Example using paging with a marker:
     *
     * ```js
     * let i = 1;
     * let iterator = fileSystemClient.listPaths().byPage({ maxPageSize: 2 });
     * let response = (await iterator.next()).value;
     *
     * // Prints 2 path names
     * for (const path of response.pathItems) {
     *   console.log(`Path ${i++}: ${path.name}, isDirectory?: ${path.isDirectory}`);
     * }
     *
     * // Gets next marker
     * let marker = response.continuationToken;
     *
     * // Passing next marker as continuationToken
     *
     * iterator = fileSystemClient.listPaths().byPage({ continuationToken: marker, maxPageSize: 10 });
     * response = (await iterator.next()).value;
     *
     * // Prints 10 path names
     * for (const path of response.pathItems) {
     *   console.log(`Path ${i++}: ${path.name}, isDirectory?: ${path.isDirectory}`);
     * }
     * ```
     *
     * @see https://docs.microsoft.com/rest/api/storageservices/list-blobs
     *
     * @param {ListPathsOptions} [options={}] Optional. Options when listing paths.
     * @returns {PagedAsyncIterableIterator<Path, FileSystemListPathsResponse>}
     * @memberof DataLakeFileSystemClient
     */
    DataLakeFileSystemClient.prototype.listPaths = function (options) {
        var _a;
        var _this = this;
        if (options === void 0) { options = {}; }
        options.path = options.path === "" ? undefined : options.path;
        var iter = this.listItems(options);
        return _a = {
                next: function () {
                    return iter.next();
                }
            },
            _a[Symbol.asyncIterator] = function () {
                return this;
            },
            _a.byPage = function (settings) {
                if (settings === void 0) { settings = {}; }
                return _this.listSegments(settings.continuationToken, __assign({ maxResults: settings.maxPageSize }, options));
            },
            _a;
    };
    DataLakeFileSystemClient.prototype.listItems = function (options) {
        if (options === void 0) { options = {}; }
        return __asyncGenerator(this, arguments, function listItems_1() {
            var _a, _b, response, e_7_1;
            var e_7, _c;
            return __generator(this, function (_d) {
                switch (_d.label) {
                    case 0:
                        _d.trys.push([0, 7, 8, 13]);
                        _a = __asyncValues(this.listSegments(undefined, options));
                        _d.label = 1;
                    case 1: return [4 /*yield*/, __await(_a.next())];
                    case 2:
                        if (!(_b = _d.sent(), !_b.done)) return [3 /*break*/, 6];
                        response = _b.value;
                        return [5 /*yield**/, __values(__asyncDelegator(__asyncValues(response.pathItems || [])))];
                    case 3: return [4 /*yield*/, __await.apply(void 0, [_d.sent()])];
                    case 4:
                        _d.sent();
                        _d.label = 5;
                    case 5: return [3 /*break*/, 1];
                    case 6: return [3 /*break*/, 13];
                    case 7:
                        e_7_1 = _d.sent();
                        e_7 = { error: e_7_1 };
                        return [3 /*break*/, 13];
                    case 8:
                        _d.trys.push([8, , 11, 12]);
                        if (!(_b && !_b.done && (_c = _a.return))) return [3 /*break*/, 10];
                        return [4 /*yield*/, __await(_c.call(_a))];
                    case 9:
                        _d.sent();
                        _d.label = 10;
                    case 10: return [3 /*break*/, 12];
                    case 11:
                        if (e_7) throw e_7.error;
                        return [7 /*endfinally*/];
                    case 12: return [7 /*endfinally*/];
                    case 13: return [2 /*return*/];
                }
            });
        });
    };
    DataLakeFileSystemClient.prototype.listSegments = function (continuation, options) {
        if (options === void 0) { options = {}; }
        return __asyncGenerator(this, arguments, function listSegments_1() {
            var response;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!(!!continuation || continuation === undefined)) return [3 /*break*/, 6];
                        _a.label = 1;
                    case 1: return [4 /*yield*/, __await(this.listPathsSegment(continuation, options))];
                    case 2:
                        response = _a.sent();
                        continuation = response.continuation;
                        return [4 /*yield*/, __await(response)];
                    case 3: return [4 /*yield*/, _a.sent()];
                    case 4:
                        _a.sent();
                        _a.label = 5;
                    case 5:
                        if (continuation) return [3 /*break*/, 1];
                        _a.label = 6;
                    case 6: return [2 /*return*/];
                }
            });
        });
    };
    DataLakeFileSystemClient.prototype.listPathsSegment = function (continuation, options) {
        if (options === void 0) { options = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var _a, span, spanOptions, rawResponse, response, _i, _b, path, e_8;
            return __generator(this, function (_c) {
                switch (_c.label) {
                    case 0:
                        _a = createSpan("DataLakeFileSystemClient-listPathsSegment", options.tracingOptions), span = _a.span, spanOptions = _a.spanOptions;
                        _c.label = 1;
                    case 1:
                        _c.trys.push([1, 3, 4, 5]);
                        return [4 /*yield*/, this.fileSystemContext.listPaths(options.recursive || false, __assign(__assign({ continuation: continuation }, options), { upn: options.userPrincipalName, spanOptions: spanOptions }))];
                    case 2:
                        rawResponse = _c.sent();
                        response = rawResponse;
                        response.pathItems = [];
                        for (_i = 0, _b = rawResponse.paths || []; _i < _b.length; _i++) {
                            path = _b[_i];
                            response.pathItems.push(__assign(__assign({}, path), { permissions: toPermissions(path.permissions) }));
                        }
                        delete rawResponse.paths;
                        return [2 /*return*/, response];
                    case 3:
                        e_8 = _c.sent();
                        span.setStatus({
                            code: CanonicalCode.UNKNOWN,
                            message: e_8.message
                        });
                        throw e_8;
                    case 4:
                        span.end();
                        return [7 /*endfinally*/];
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    return DataLakeFileSystemClient;
}(StorageClient));
export { DataLakeFileSystemClient };
//# sourceMappingURL=DataLakeFileSystemClient.js.map