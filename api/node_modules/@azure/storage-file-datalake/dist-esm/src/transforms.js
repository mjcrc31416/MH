import { __assign, __awaiter, __generator } from "tslib";
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
import { URLBuilder } from "@azure/core-http";
import { ToBlobEndpointHostMappings, ToDfsEndpointHostMappings } from "./utils/constants";
import { base64encode } from "./utils/utils.common";
/**
 * Get a blob endpoint URL from incoming blob or dfs endpoint URLs.
 * Only handle known host name pair patterns, add more patterns into ToBlobEndpointHostMappings in constants.ts.
 *
 * Expected input and outputs:
 * http://account.blob.core.windows.net     => http://account.blob.core.windows.net
 * http://account.dfs.core.windows.net      => http://account.blob.core.windows.net
 * http://127.0.0.1:10000                   => http://127.0.0.1:10000
 * http://account.blob.core.windows.net/abc => http://account.blob.core.windows.net/abc
 * http://account.dfs.core.windows.net/abc  => http://account.blob.core.windows.net/abc
 * http://127.0.0.1:10000/abc               => http://127.0.0.1:10000/abc
 *
 * @export
 * @param {string} url
 * @returns {string}
 */
export function toBlobEndpointUrl(url) {
    var urlParsed = URLBuilder.parse(url);
    var host = urlParsed.getHost();
    if (host === undefined) {
        throw RangeError("toBlobEndpointUrl() parameter url " + url + " doesn't include valid host.");
    }
    for (var _i = 0, ToBlobEndpointHostMappings_1 = ToBlobEndpointHostMappings; _i < ToBlobEndpointHostMappings_1.length; _i++) {
        var mapping = ToBlobEndpointHostMappings_1[_i];
        if (host.includes(mapping[0])) {
            host = host.replace(mapping[0], mapping[1]);
            break;
        }
    }
    urlParsed.setHost(host);
    return urlParsed.toString();
}
/**
 * Get a dfs endpoint URL from incoming blob or dfs endpoint URLs.
 * Only handle known host name pair patterns, add more patterns into ToDfsEndpointHostMappings in constants.ts.
 *
 * Expected input and outputs:
 * http://account.blob.core.windows.net     => http://account.dfs.core.windows.net
 * http://account.dfs.core.windows.net      => http://account.dfs.core.windows.net
 * http://127.0.0.1:10000                   => http://127.0.0.1:10000
 * http://account.blob.core.windows.net/abc => http://account.dfs.core.windows.net/abc
 * http://account.dfs.core.windows.net/abc  => http://account.dfs.core.windows.net/abc
 * http://127.0.0.1:10000/abc               => http://127.0.0.1:10000/abc
 *
 * @export
 * @param {string} url
 * @returns {string}
 */
export function toDfsEndpointUrl(url) {
    var urlParsed = URLBuilder.parse(url);
    var host = urlParsed.getHost();
    if (host === undefined) {
        throw RangeError("toDfsEndpointUrl() parameter url " + url + " doesn't include valid host.");
    }
    for (var _i = 0, ToDfsEndpointHostMappings_1 = ToDfsEndpointHostMappings; _i < ToDfsEndpointHostMappings_1.length; _i++) {
        var mapping = ToDfsEndpointHostMappings_1[_i];
        if (host.includes(mapping[0])) {
            host = host.replace(mapping[0], mapping[1]);
            break;
        }
    }
    urlParsed.setHost(host);
    return urlParsed.toString();
}
function toFileSystemAsyncIterableIterator(iter) {
    var _a;
    return _a = {
            next: function () {
                return __awaiter(this, void 0, void 0, function () {
                    var rawResult;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, iter.next()];
                            case 1:
                                rawResult = _a.sent();
                                if (rawResult.value) {
                                    rawResult.value.fileSystemItems = rawResult.value.containerItems.map(function (val) {
                                        return __assign(__assign({}, val), { properties: __assign(__assign({}, val.properties), { publicAccess: toPublicAccessType(val.properties.publicAccess) }) });
                                    });
                                }
                                return [2 /*return*/, rawResult];
                        }
                    });
                });
            }
        },
        _a[Symbol.asyncIterator] = function () {
            return this;
        },
        _a;
}
export function toFileSystemPagedAsyncIterableIterator(iter) {
    var _a;
    return _a = {
            next: function () {
                return __awaiter(this, void 0, void 0, function () {
                    var rawResult, result;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, iter.next()];
                            case 1:
                                rawResult = _a.sent();
                                result = rawResult;
                                if (result.value) {
                                    result.value.properties.publicAccess = toPublicAccessType(rawResult.value.properties.publicAccess);
                                }
                                return [2 /*return*/, result];
                        }
                    });
                });
            }
        },
        _a[Symbol.asyncIterator] = function () {
            return this;
        },
        _a.byPage = function (settings) {
            if (settings === void 0) { settings = {}; }
            return toFileSystemAsyncIterableIterator(iter.byPage(settings));
        },
        _a;
}
export function toContainerPublicAccessType(publicAccessType) {
    if (!publicAccessType) {
        return undefined;
    }
    switch (publicAccessType) {
        case "filesystem":
            return "container";
        case "file":
            return "blob";
        default:
            throw TypeError("toContainerPublicAccessType() parameter " + publicAccessType + " is not recognized.");
    }
}
export function toPublicAccessType(containerPublicAccessType) {
    if (!containerPublicAccessType) {
        return undefined;
    }
    switch (containerPublicAccessType) {
        case "container":
            return "filesystem";
        case "blob":
            return "file";
        default:
            throw TypeError("toPublicAccessType() parameter " + containerPublicAccessType + " is not recognized.");
    }
}
export function toProperties(metadata) {
    if (metadata === undefined) {
        return undefined;
    }
    var properties = [];
    for (var key in metadata) {
        if (metadata.hasOwnProperty(key)) {
            var value = metadata[key];
            properties.push(key + "=" + base64encode(value));
        }
    }
    return properties.join(",");
}
export function toPathGetAccessControlResponse(response) {
    return __assign(__assign({}, response), { _response: response._response, permissions: toPermissions(response.permissions), acl: toAcl(response.acl) });
}
export function toRolePermissions(permissionsString, allowStickyBit) {
    if (allowStickyBit === void 0) { allowStickyBit = false; }
    var error = new RangeError("toRolePermissions() Invalid role permissions string " + permissionsString);
    if (permissionsString.length !== 3) {
        throw error;
    }
    permissionsString = permissionsString.toLowerCase();
    var read = false;
    if (permissionsString[0] === "r") {
        read = true;
    }
    else if (permissionsString[0] !== "-") {
        throw error;
    }
    var write = false;
    if (permissionsString[1] === "w") {
        write = true;
    }
    else if (permissionsString[1] !== "-") {
        throw error;
    }
    var execute = false;
    if (permissionsString[2] === "x") {
        execute = true;
    }
    else if (allowStickyBit) {
        if (permissionsString[2] === "t") {
            execute = true;
        }
        else if (permissionsString[2] !== "-") {
            throw error;
        }
    }
    else if (permissionsString[2] !== "-") {
        throw error;
    }
    return { read: read, write: write, execute: execute };
}
export function toPermissions(permissionsString) {
    if (permissionsString === undefined || permissionsString === "" || permissionsString === null) {
        return undefined;
    }
    if (permissionsString.length !== 9 && permissionsString.length !== 10) {
        throw RangeError("toPermissions() Invalid permissions string " + permissionsString);
    }
    // Case insensitive
    permissionsString = permissionsString.toLowerCase();
    var stickyBit = false;
    if (permissionsString[8] === "t") {
        stickyBit = true;
    }
    var extendedAcls = false;
    if (permissionsString.length === 10) {
        if (permissionsString[9] === "+") {
            extendedAcls = true;
        }
        else {
            throw RangeError("toPermissions() Invalid extendedAcls bit " + permissionsString[9] + " in permissions string " + permissionsString);
        }
    }
    var owner = toRolePermissions(permissionsString.substr(0, 3), false);
    var group = toRolePermissions(permissionsString.substr(3, 3), false);
    var other = toRolePermissions(permissionsString.substr(6, 3), true);
    return {
        owner: owner,
        group: group,
        other: other,
        stickyBit: stickyBit,
        extendedAcls: extendedAcls
    };
}
export function toAccessControlItem(aclItemString) {
    var error = new RangeError("toAccessControlItem() Parameter access control item string " + aclItemString + " is not valid.");
    if (aclItemString === "") {
        throw error;
    }
    aclItemString = aclItemString.toLowerCase();
    var parts = aclItemString.split(":");
    if (parts.length < 3 || parts.length > 4) {
        throw error;
    }
    var defaultScope = false;
    var index = 0;
    if (parts.length === 4) {
        if (parts[index] !== "default") {
            throw error;
        }
        defaultScope = true;
        index++;
    }
    var accessControlType = parts[index++];
    if (accessControlType !== "user" &&
        accessControlType !== "group" &&
        accessControlType !== "mask" &&
        accessControlType !== "other") {
        throw error;
    }
    var entityId = parts[index++];
    var permissions = toRolePermissions(parts[index++]);
    return {
        defaultScope: defaultScope,
        accessControlType: accessControlType,
        entityId: entityId,
        permissions: permissions
    };
}
export function toAcl(aclString) {
    if (aclString === undefined || aclString === "" || aclString === null) {
        return [];
    }
    var acls = [];
    var aclParts = aclString.split(",");
    for (var _i = 0, aclParts_1 = aclParts; _i < aclParts_1.length; _i++) {
        var aclPart = aclParts_1[_i];
        acls.push(toAccessControlItem(aclPart));
    }
    return acls;
}
export function toAccessControlItemString(item) {
    return "" + (item.defaultScope ? "default:" : "") + item.accessControlType + ":" + item.entityId + ":" + toRolePermissionsString(item.permissions);
}
export function toAclString(acl) {
    return acl.map(toAccessControlItemString).join(",");
}
export function toRolePermissionsString(p, stickyBit) {
    if (stickyBit === void 0) { stickyBit = false; }
    return "" + (p.read ? "r" : "-") + (p.write ? "w" : "-") + (stickyBit ? "t" : p.execute ? "x" : "-");
}
export function toPermissionsString(permissions) {
    return "" + toRolePermissionsString(permissions.owner) + toRolePermissionsString(permissions.group) + toRolePermissionsString(permissions.other, permissions.stickyBit) + (permissions.extendedAcls ? "+" : "");
}
//# sourceMappingURL=transforms.js.map