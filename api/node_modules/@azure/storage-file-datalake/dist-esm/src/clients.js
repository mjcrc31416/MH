import { __assign, __awaiter, __extends, __generator } from "tslib";
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
import { isNode } from "@azure/core-http";
import { BlobClient } from "@azure/storage-blob";
import { CanonicalCode } from "@opentelemetry/types";
import { AnonymousCredential } from "./credentials/AnonymousCredential";
import { DataLakeLeaseClient } from "./DataLakeLeaseClient";
import { PathOperations } from "./generated/src/operations";
import { PathGetPropertiesAction, PathRenameMode, PathResourceType } from "./models";
import { newPipeline, Pipeline } from "./Pipeline";
import { StorageClient } from "./StorageClient";
import { toAclString, toPathGetAccessControlResponse, toPermissionsString, toProperties } from "./transforms";
import { createSpan } from "./utils/tracing";
import { appendToURLPath, setURLPath } from "./utils/utils.common";
import { getCachedDefaultHttpClient } from "./utils/cache";
/**
 * A DataLakePathClient represents a URL to the Azure Storage path (directory or file).
 *
 * @export
 * @class DataLakePathClient
 * @extends {StorageClient}
 */
var DataLakePathClient = /** @class */ (function (_super) {
    __extends(DataLakePathClient, _super);
    function DataLakePathClient(url, credentialOrPipeline, options) {
        var _this = this;
        // when options.httpClient is not specified, passing in a DefaultHttpClient instance to
        // avoid each client creating its own http client.
        var newOptions = __assign({ httpClient: getCachedDefaultHttpClient() }, options);
        if (credentialOrPipeline instanceof Pipeline) {
            _this = _super.call(this, url, credentialOrPipeline) || this;
        }
        else {
            var credential = void 0;
            if (credentialOrPipeline === undefined) {
                credential = new AnonymousCredential();
            }
            else {
                credential = credentialOrPipeline;
            }
            var pipeline = newPipeline(credential, newOptions);
            _this = _super.call(this, url, pipeline) || this;
        }
        _this.pathContext = new PathOperations(_this.storageClientContext);
        _this.blobClient = new BlobClient(_this.blobEndpointUrl, _this.pipeline);
        return _this;
    }
    Object.defineProperty(DataLakePathClient.prototype, "fileSystemName", {
        /**
         * Name of current file system.
         *
         * @readonly
         * @type {string}
         * @memberof DataLakePathClient
         */
        get: function () {
            return this.blobClient.containerName;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DataLakePathClient.prototype, "name", {
        /**
         * Name of current path (directory or file).
         *
         * @readonly
         * @type {string}
         * @memberof DataLakePathClient
         */
        get: function () {
            return this.blobClient.name;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Convert current DataLakePathClient to DataLakeDirectoryClient if current path is a directory.
     *
     * @returns {DataLakeDirectoryClient}
     * @memberof DataLakePathClient
     */
    DataLakePathClient.prototype.toDirectoryClient = function () {
        return new DataLakeDirectoryClient(this.dfsEndpointUrl, this.pipeline);
    };
    /**
     * Convert current DataLakePathClient to DataLakeFileClient if current path is a file.
     *
     * @returns {DataLakeFileClient}
     * @memberof DataLakePathClient
     */
    DataLakePathClient.prototype.toFileClient = function () {
        return new DataLakeFileClient(this.dfsEndpointUrl, this.pipeline);
    };
    /**
     * Get a {@link DataLakeLeaseClient} that manages leases on the path (directory or file).
     *
     * @param {string} [proposeLeaseId] Optional. Initial proposed lease Id.
     * @returns {DataLakeLeaseClient}
     * @memberof DataLakePathClient
     */
    DataLakePathClient.prototype.getDataLakeLeaseClient = function (proposeLeaseId) {
        return new DataLakeLeaseClient(this.blobClient.getBlobLeaseClient(proposeLeaseId));
    };
    /**
     * Create a directory or path.
     *
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/datalakestoragegen2/path/create
     *
     * @param {PathResourceType} resourceType Resource type, "directory" or "file".
     * @param {PathCreateOptions} [options={}] Optional. Options when creating path.
     * @returns {Promise<PathCreateResponse>}
     * @memberof DataLakePathClient
     */
    DataLakePathClient.prototype.create = function (resourceType, options) {
        if (options === void 0) { options = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var _a, span, spanOptions, e_1;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        options.conditions = options.conditions || {};
                        _a = createSpan("DataLakePathClient-create", options.tracingOptions), span = _a.span, spanOptions = _a.spanOptions;
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 3, 4, 5]);
                        return [4 /*yield*/, this.pathContext.create(__assign(__assign({}, options), { resource: resourceType, leaseAccessConditions: options.conditions, modifiedAccessConditions: options.conditions, properties: toProperties(options.metadata), spanOptions: spanOptions }))];
                    case 2: return [2 /*return*/, _b.sent()];
                    case 3:
                        e_1 = _b.sent();
                        span.setStatus({
                            code: CanonicalCode.UNKNOWN,
                            message: e_1.message
                        });
                        throw e_1;
                    case 4:
                        span.end();
                        return [7 /*endfinally*/];
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Delete current path (directory or file).
     *
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/datalakestoragegen2/path/delete
     *
     * @param {boolean} [recursive] Required and valid only when the resource is a directory. If "true", all paths beneath the directory will be deleted.
     * @param {PathDeleteOptions} [options={}] Optional. Options when deleting path.
     * @returns {Promise<PathDeleteResponse>}
     * @memberof DataLakePathClient
     */
    DataLakePathClient.prototype.delete = function (recursive, options) {
        if (options === void 0) { options = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var _a, span, spanOptions, continuation, response, e_2;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        options.conditions = options.conditions || {};
                        _a = createSpan("DataLakePathClient-delete", options.tracingOptions), span = _a.span, spanOptions = _a.spanOptions;
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 6, 7, 8]);
                        continuation = void 0;
                        response = void 0;
                        _b.label = 2;
                    case 2: return [4 /*yield*/, this.pathContext.deleteMethod({
                            continuation: continuation,
                            recursive: recursive,
                            leaseAccessConditions: options.conditions,
                            modifiedAccessConditions: options.conditions,
                            spanOptions: spanOptions
                        })];
                    case 3:
                        response = _b.sent();
                        continuation = response.continuation;
                        _b.label = 4;
                    case 4:
                        if (continuation !== undefined && continuation !== "") return [3 /*break*/, 2];
                        _b.label = 5;
                    case 5: return [2 /*return*/, response];
                    case 6:
                        e_2 = _b.sent();
                        span.setStatus({
                            code: CanonicalCode.UNKNOWN,
                            message: e_2.message
                        });
                        throw e_2;
                    case 7:
                        span.end();
                        return [7 /*endfinally*/];
                    case 8: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Returns the access control data for a path (directory of file).
     *
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/datalakestoragegen2/path/getproperties
     *
     * @param {PathGetAccessControlOptions} [options={}] Optional. Options when getting file access control.
     * @returns {Promise<PathGetAccessControlResponse>}
     * @memberof DataLakePathClient
     */
    DataLakePathClient.prototype.getAccessControl = function (options) {
        if (options === void 0) { options = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var _a, span, spanOptions, response, e_3;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        options.conditions = options.conditions || {};
                        _a = createSpan("DataLakePathClient-getAccessControl", options.tracingOptions), span = _a.span, spanOptions = _a.spanOptions;
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 3, 4, 5]);
                        return [4 /*yield*/, this.pathContext.getProperties({
                                action: PathGetPropertiesAction.GetAccessControl,
                                upn: options.userPrincipalName,
                                leaseAccessConditions: options.conditions,
                                modifiedAccessConditions: options.conditions,
                                spanOptions: spanOptions
                            })];
                    case 2:
                        response = _b.sent();
                        return [2 /*return*/, toPathGetAccessControlResponse(response)];
                    case 3:
                        e_3 = _b.sent();
                        span.setStatus({
                            code: CanonicalCode.UNKNOWN,
                            message: e_3.message
                        });
                        throw e_3;
                    case 4:
                        span.end();
                        return [7 /*endfinally*/];
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Set the access control data for a path (directory of file).
     *
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/datalakestoragegen2/path/update
     *
     * @param {PathAccessControlItem[]} acl The POSIX access control list for the file or directory.
     * @param {PathSetAccessControlOptions} [options={}] Optional. Options when setting path access control.
     * @returns {Promise<PathSetAccessControlResponse>}
     * @memberof DataLakePathClient
     */
    DataLakePathClient.prototype.setAccessControl = function (acl, options) {
        if (options === void 0) { options = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var _a, span, spanOptions, e_4;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        options.conditions = options.conditions || {};
                        _a = createSpan("DataLakePathClient-setAccessControl", options.tracingOptions), span = _a.span, spanOptions = _a.spanOptions;
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 3, 4, 5]);
                        return [4 /*yield*/, this.pathContext.setAccessControl(__assign(__assign({}, options), { acl: toAclString(acl), leaseAccessConditions: options.conditions, modifiedAccessConditions: options.conditions, spanOptions: spanOptions }))];
                    case 2: return [2 /*return*/, _b.sent()];
                    case 3:
                        e_4 = _b.sent();
                        span.setStatus({
                            code: CanonicalCode.UNKNOWN,
                            message: e_4.message
                        });
                        throw e_4;
                    case 4:
                        span.end();
                        return [7 /*endfinally*/];
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Sets the file permissions on a path.
     *
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/datalakestoragegen2/path/update
     *
     * @param {PathPermissions} permissions The POSIX access permissions for the file owner, the file owning group, and others.
     * @param {PathSetPermissionsOptions} [options={}] Optional. Options when setting path permissions.
     * @returns {Promise<PathSetPermissionsResponse>}
     * @memberof DataLakePathClient
     */
    DataLakePathClient.prototype.setPermissions = function (permissions, options) {
        if (options === void 0) { options = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var _a, span, spanOptions, e_5;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        options.conditions = options.conditions || {};
                        _a = createSpan("DataLakePathClient-setPermissions", options.tracingOptions), span = _a.span, spanOptions = _a.spanOptions;
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 3, 4, 5]);
                        return [4 /*yield*/, this.pathContext.setAccessControl(__assign(__assign({}, options), { permissions: toPermissionsString(permissions), leaseAccessConditions: options.conditions, modifiedAccessConditions: options.conditions, spanOptions: spanOptions }))];
                    case 2: return [2 /*return*/, _b.sent()];
                    case 3:
                        e_5 = _b.sent();
                        span.setStatus({
                            code: CanonicalCode.UNKNOWN,
                            message: e_5.message
                        });
                        throw e_5;
                    case 4:
                        span.end();
                        return [7 /*endfinally*/];
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Returns all user-defined metadata, standard HTTP properties, and system properties
     * for the path (directory or file).
     *
     * WARNING: The `metadata` object returned in the response will have its keys in lowercase, even if
     * they originally contained uppercase characters. This differs from the metadata keys returned by
     * the methods of {@link DataLakeFileSystemClient} that list paths using the `includeMetadata` option, which
     * will retain their original casing.
     *
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/get-blob-properties
     *
     * @param {PathGetPropertiesOptions} [options={}] Optional. Options when getting path properties.
     * @returns {Promise<PathGetPropertiesResponse>}
     * @memberof DataLakePathClient
     */
    DataLakePathClient.prototype.getProperties = function (options) {
        if (options === void 0) { options = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var _a, span, spanOptions, e_6;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = createSpan("DataLakePathClient-getProperties", options.tracingOptions), span = _a.span, spanOptions = _a.spanOptions;
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 3, 4, 5]);
                        return [4 /*yield*/, this.blobClient.getProperties(__assign(__assign({}, options), { customerProvidedKey: undefined, tracingOptions: __assign(__assign({}, options.tracingOptions), { spanOptions: spanOptions }) }))];
                    case 2: return [2 /*return*/, _b.sent()];
                    case 3:
                        e_6 = _b.sent();
                        span.setStatus({
                            code: CanonicalCode.UNKNOWN,
                            message: e_6.message
                        });
                        throw e_6;
                    case 4:
                        span.end();
                        return [7 /*endfinally*/];
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Sets system properties on the path (directory or file).
     *
     * If no value provided, or no value provided for the specified blob HTTP headers,
     * these blob HTTP headers without a value will be cleared.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/set-blob-properties
     *
     * @param {PathHttpHeaders} httpHeaders
     * @param {PathSetHttpHeadersOptions} [options={}]
     * @returns {Promise<PathSetHttpHeadersResponse>}
     * @memberof DataLakePathClient
     */
    DataLakePathClient.prototype.setHttpHeaders = function (httpHeaders, options) {
        if (options === void 0) { options = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var _a, span, spanOptions, e_7;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = createSpan("DataLakePathClient-setHttpHeaders", options.tracingOptions), span = _a.span, spanOptions = _a.spanOptions;
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 3, 4, 5]);
                        return [4 /*yield*/, this.blobClient.setHTTPHeaders({
                                blobCacheControl: httpHeaders.cacheControl,
                                blobContentType: httpHeaders.contentType,
                                blobContentMD5: httpHeaders.contentMD5,
                                blobContentEncoding: httpHeaders.contentEncoding,
                                blobContentLanguage: httpHeaders.contentLanguage,
                                blobContentDisposition: httpHeaders.contentDisposition
                            }, __assign(__assign({}, options), { tracingOptions: __assign(__assign({}, options.tracingOptions), { spanOptions: spanOptions }) }))];
                    case 2: return [2 /*return*/, _b.sent()];
                    case 3:
                        e_7 = _b.sent();
                        span.setStatus({
                            code: CanonicalCode.UNKNOWN,
                            message: e_7.message
                        });
                        throw e_7;
                    case 4:
                        span.end();
                        return [7 /*endfinally*/];
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Sets user-defined metadata for the specified path (directory of file) as one or more name-value pairs.
     *
     * If no option provided, or no metadata defined in the parameter, the path
     * metadata will be removed.
     *
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/set-blob-metadata
     *
     * @param {Metadata} [metadata] Optional. Replace existing metadata with this value.
     *                              If no value provided the existing metadata will be removed.
     * @param {PathSetMetadataOptions} [options={}] Optional. Options when setting path metadata.
     * @returns {Promise<PathSetMetadataResponse>}
     * @memberof DataLakePathClient
     */
    DataLakePathClient.prototype.setMetadata = function (metadata, options) {
        if (options === void 0) { options = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var _a, span, spanOptions, e_8;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = createSpan("DataLakePathClient-setMetadata", options.tracingOptions), span = _a.span, spanOptions = _a.spanOptions;
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 3, 4, 5]);
                        return [4 /*yield*/, this.blobClient.setMetadata(metadata, __assign(__assign({}, options), { customerProvidedKey: undefined, tracingOptions: __assign(__assign({}, options.tracingOptions), { spanOptions: spanOptions }) }))];
                    case 2: return [2 /*return*/, _b.sent()];
                    case 3:
                        e_8 = _b.sent();
                        span.setStatus({
                            code: CanonicalCode.UNKNOWN,
                            message: e_8.message
                        });
                        throw e_8;
                    case 4:
                        span.end();
                        return [7 /*endfinally*/];
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    DataLakePathClient.prototype.move = function (destinationPathOrFileSystem, destinationPathOrOptions, options) {
        return __awaiter(this, void 0, void 0, function () {
            var destinationFileSystem, destinationPath, _a, span, spanOptions, renameSource, renameDestination, destinationUrl, destPathClient, e_9;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        destinationFileSystem = this.fileSystemName;
                        destinationPath = destinationPathOrFileSystem;
                        if (typeof destinationPathOrOptions === "string") {
                            destinationFileSystem = destinationPathOrFileSystem;
                            destinationPath = destinationPathOrOptions;
                            options = options || {};
                        }
                        else {
                            options = destinationPathOrOptions || {};
                        }
                        options.conditions = options.conditions || {};
                        options.destinationConditions = options.destinationConditions || {};
                        _a = createSpan("DataLakePathClient-move", options.tracingOptions), span = _a.span, spanOptions = _a.spanOptions;
                        renameSource = "/" + this.fileSystemName + "/" + this.name;
                        renameDestination = "/" + destinationFileSystem + "/" + destinationPath;
                        destinationUrl = setURLPath(this.dfsEndpointUrl, renameDestination);
                        destPathClient = new DataLakePathClient(destinationUrl, this.pipeline);
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 3, 4, 5]);
                        return [4 /*yield*/, destPathClient.pathContext.create({
                                mode: PathRenameMode.Legacy,
                                renameSource: renameSource,
                                sourceLeaseId: options.conditions.leaseId,
                                leaseAccessConditions: options.destinationConditions,
                                sourceModifiedAccessConditions: {
                                    sourceIfMatch: options.conditions.ifMatch,
                                    sourceIfNoneMatch: options.conditions.ifNoneMatch,
                                    sourceIfModifiedSince: options.conditions.ifModifiedSince,
                                    sourceIfUnmodifiedSince: options.conditions.ifUnmodifiedSince
                                },
                                modifiedAccessConditions: options.destinationConditions,
                                spanOptions: spanOptions
                            })];
                    case 2: return [2 /*return*/, _b.sent()];
                    case 3:
                        e_9 = _b.sent();
                        span.setStatus({
                            code: CanonicalCode.UNKNOWN,
                            message: e_9.message
                        });
                        throw e_9;
                    case 4:
                        span.end();
                        return [7 /*endfinally*/];
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    return DataLakePathClient;
}(StorageClient));
export { DataLakePathClient };
/**
 * A DataLakeDirectoryClient represents a URL to the Azure Storage directory.
 *
 * @export
 * @class DataLakeDirectoryClient
 * @extends {DataLakePathClient}
 */
var DataLakeDirectoryClient = /** @class */ (function (_super) {
    __extends(DataLakeDirectoryClient, _super);
    function DataLakeDirectoryClient() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    DataLakeDirectoryClient.prototype.create = function (resourceTypeOrOptions, options) {
        if (options === void 0) { options = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var _a, span, spanOptions, e_10;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        if (resourceTypeOrOptions === PathResourceType.Directory) {
                            return [2 /*return*/, _super.prototype.create.call(this, resourceTypeOrOptions, options)];
                        }
                        if (resourceTypeOrOptions === PathResourceType.File) {
                            throw TypeError("DataLakeDirectoryClient:create() resourceType cannot be " + PathResourceType.File + ". Refer to DataLakeFileClient for file creation.");
                        }
                        options = resourceTypeOrOptions || {};
                        options.conditions = options.conditions || {};
                        _a = createSpan("DataLakeDirectoryClient-create", options.tracingOptions), span = _a.span, spanOptions = _a.spanOptions;
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 3, 4, 5]);
                        return [4 /*yield*/, _super.prototype.create.call(this, PathResourceType.Directory, __assign(__assign({}, options), { tracingOptions: __assign(__assign({}, options.tracingOptions), { spanOptions: spanOptions }) }))];
                    case 2: return [2 /*return*/, _b.sent()];
                    case 3:
                        e_10 = _b.sent();
                        span.setStatus({
                            code: CanonicalCode.UNKNOWN,
                            message: e_10.message
                        });
                        throw e_10;
                    case 4:
                        span.end();
                        return [7 /*endfinally*/];
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Creates a {@link DataLakeDirectoryClient} object under current directory.
     *
     * @param {string} subdirectoryName Subdirectory name.
     * @returns {DataLakeDirectoryClient}
     * @memberof DataLakeDirectoryClient
     */
    DataLakeDirectoryClient.prototype.getSubdirectoryClient = function (subdirectoryName) {
        return new DataLakeDirectoryClient(appendToURLPath(this.url, encodeURIComponent(subdirectoryName)), this.pipeline);
    };
    /**
     * Creates a {@link DataLakeFileClient} object under current directory.
     *
     * @param {string} fileName
     * @returns {DataLakeFileClient}
     * @memberof DataLakeDirectoryClient
     */
    DataLakeDirectoryClient.prototype.getFileClient = function (fileName) {
        return new DataLakeFileClient(appendToURLPath(this.url, encodeURIComponent(fileName)), this.pipeline);
    };
    return DataLakeDirectoryClient;
}(DataLakePathClient));
export { DataLakeDirectoryClient };
/**
 * A DataLakeFileClient represents a URL to the Azure Storage file.
 *
 * @export
 * @class DataLakeFileClient
 * @extends {DataLakePathClient}
 */
var DataLakeFileClient = /** @class */ (function (_super) {
    __extends(DataLakeFileClient, _super);
    function DataLakeFileClient(url, credentialOrPipeline, options) {
        var _this = this;
        if (credentialOrPipeline instanceof Pipeline) {
            _this = _super.call(this, url, credentialOrPipeline) || this;
        }
        else {
            var credential = void 0;
            if (credentialOrPipeline === undefined) {
                credential = new AnonymousCredential();
            }
            else {
                credential = credentialOrPipeline;
            }
            var pipeline = newPipeline(credential, options);
            _this = _super.call(this, url, pipeline) || this;
        }
        _this.pathContextInternal = new PathOperations(_this.storageClientContext);
        _this.blobClientInternal = new BlobClient(_this.blobEndpointUrl, _this.pipeline);
        return _this;
    }
    DataLakeFileClient.prototype.create = function (resourceTypeOrOptions, options) {
        if (options === void 0) { options = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var _a, span, spanOptions, e_11;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        if (resourceTypeOrOptions === PathResourceType.File) {
                            return [2 /*return*/, _super.prototype.create.call(this, resourceTypeOrOptions, options)];
                        }
                        if (resourceTypeOrOptions === PathResourceType.Directory) {
                            throw TypeError("DataLakeFileClient:create() resourceType cannot be " + PathResourceType.Directory + ". Refer to DataLakeDirectoryClient for directory creation.");
                        }
                        options = resourceTypeOrOptions || {};
                        options.conditions = options.conditions || {};
                        _a = createSpan("DataLakeFileClient-create", options.tracingOptions), span = _a.span, spanOptions = _a.spanOptions;
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 3, 4, 5]);
                        return [4 /*yield*/, _super.prototype.create.call(this, PathResourceType.File, __assign(__assign({}, options), { tracingOptions: __assign(__assign({}, options.tracingOptions), { spanOptions: spanOptions }) }))];
                    case 2: return [2 /*return*/, _b.sent()];
                    case 3:
                        e_11 = _b.sent();
                        span.setStatus({
                            code: CanonicalCode.UNKNOWN,
                            message: e_11.message
                        });
                        throw e_11;
                    case 4:
                        span.end();
                        return [7 /*endfinally*/];
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Downloads a file from the service, including its metadata and properties.
     *
     * * In Node.js, data returns in a Readable stream readableStreamBody
     * * In browsers, data returns in a promise contentAsBlob
     *
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/get-blob
     *
     * * Example usage (Node.js):
     *
     * ```js
     * // Download and convert a file to a string
     * const downloadResponse = await fileClient.read();
     * const downloaded = await streamToString(downloadResponse.readableStreamBody);
     * console.log("Downloaded file content:", downloaded);
     *
     * async function streamToString(readableStream) {
     *   return new Promise((resolve, reject) => {
     *     const chunks = [];
     *     readableStream.on("data", (data) => {
     *       chunks.push(data.toString());
     *     });
     *     readableStream.on("end", () => {
     *       resolve(chunks.join(""));
     *     });
     *     readableStream.on("error", reject);
     *   });
     * }
     * ```
     *
     * Example usage (browser):
     *
     * ```js
     * // Download and convert a file to a string
     * const downloadResponse = await fileClient.read();
     * const downloaded = await blobToString(await downloadResponse.contentAsBlob);
     * console.log("Downloaded file content", downloaded);
     *
     * async function blobToString(blob: Blob): Promise<string> {
     *   const fileReader = new FileReader();
     *   return new Promise<string>((resolve, reject) => {
     *     fileReader.onloadend = (ev: any) => {
     *       resolve(ev.target!.result);
     *     };
     *     fileReader.onerror = reject;
     *     fileReader.readAsText(blob);
     *   });
     * }
     * ```
     *
     * @param {number} [offset=0] Optional. Offset to read file, default value is 0.
     * @param {number} [count] Optional. How many bytes to read, default will read from offset to the end.
     * @param {FileReadOptions} [options={}] Optional. Options when reading file.
     * @returns {Promise<FileReadResponse>}
     * @memberof DataLakeFileClient
     */
    DataLakeFileClient.prototype.read = function (offset, count, options) {
        if (offset === void 0) { offset = 0; }
        if (options === void 0) { options = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var _a, span, spanOptions, rawResponse, response, e_12;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = createSpan("DataLakeFileClient-read", options.tracingOptions), span = _a.span, spanOptions = _a.spanOptions;
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 3, 4, 5]);
                        return [4 /*yield*/, this.blobClientInternal.download(offset, count, __assign(__assign({}, options), { tracingOptions: __assign(__assign({}, options.tracingOptions), { spanOptions: spanOptions }) }))];
                    case 2:
                        rawResponse = _b.sent();
                        response = rawResponse;
                        if (!isNode && !response.contentAsBlob) {
                            response.contentAsBlob = rawResponse.blobBody;
                        }
                        response.fileContentMD5 = rawResponse.blobContentMD5;
                        response._response.parsedHeaders.fileContentMD5 =
                            rawResponse._response.parsedHeaders.blobContentMD5;
                        delete rawResponse.blobContentMD5;
                        delete rawResponse._response.parsedHeaders.blobContentMD5;
                        return [2 /*return*/, response];
                    case 3:
                        e_12 = _b.sent();
                        span.setStatus({
                            code: CanonicalCode.UNKNOWN,
                            message: e_12.message
                        });
                        throw e_12;
                    case 4:
                        span.end();
                        return [7 /*endfinally*/];
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Uploads data to be appended to a file. Data can only be appended to a file.
     * To apply perviously uploaded data to a file, call flush.
     *
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/datalakestoragegen2/path/update
     *
     * @param {HttpRequestBody} body Content to be uploaded.
     * @param {number} offset Append offset in bytes.
     * @param {number} length Length of content to append.
     * @param {FileAppendOptions} [options={}] Optional. Options when appending data.
     * @returns {Promise<FileAppendResponse>}
     * @memberof DataLakeFileClient
     */
    DataLakeFileClient.prototype.append = function (body, offset, length, options) {
        if (options === void 0) { options = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var _a, span, spanOptions, e_13;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        options.conditions = options.conditions || {};
                        _a = createSpan("DataLakeFileClient-append", options.tracingOptions), span = _a.span, spanOptions = _a.spanOptions;
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 3, 4, 5]);
                        return [4 /*yield*/, this.pathContextInternal.appendData(body, {
                                pathHttpHeaders: {
                                    contentMD5: options.transactionalContentMD5
                                },
                                position: offset,
                                contentLength: length,
                                leaseAccessConditions: options.conditions,
                                onUploadProgress: options.onProgress,
                                spanOptions: spanOptions
                            })];
                    case 2: return [2 /*return*/, _b.sent()];
                    case 3:
                        e_13 = _b.sent();
                        span.setStatus({
                            code: CanonicalCode.UNKNOWN,
                            message: e_13.message
                        });
                        throw e_13;
                    case 4:
                        span.end();
                        return [7 /*endfinally*/];
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Flushes (writes) previously appended data to a file.
     *
     * @param {number} position File position to flush.
     *                          This parameter allows the caller to upload data in parallel and control the order in which it is appended to the file.
     *                          It is required when uploading data to be appended to the file and when flushing previously uploaded data to the file.
     *                          The value must be the position where the data is to be appended. Uploaded data is not immediately flushed, or written,
     *                          to the file. To flush, the previously uploaded data must be contiguous, the position parameter must be specified and
     *                          equal to the length of the file after all data has been written, and there must not be a request entity body included
     *                          with the request.
     * @param {FileFlushOptions} [options={}] Optional. Options when flushing data.
     * @returns {Promise<FileFlushResponse>}
     * @memberof DataLakeFileClient
     */
    DataLakeFileClient.prototype.flush = function (position, options) {
        if (options === void 0) { options = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var _a, span, spanOptions, e_14;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        options.conditions = options.conditions || {};
                        _a = createSpan("DataLakeFileClient-flush", options.tracingOptions), span = _a.span, spanOptions = _a.spanOptions;
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 3, 4, 5]);
                        return [4 /*yield*/, this.pathContextInternal.flushData(__assign(__assign({}, options), { position: position, contentLength: 0, leaseAccessConditions: options.conditions, modifiedAccessConditions: options.conditions, spanOptions: spanOptions }))];
                    case 2: return [2 /*return*/, _b.sent()];
                    case 3:
                        e_14 = _b.sent();
                        span.setStatus({
                            code: CanonicalCode.UNKNOWN,
                            message: e_14.message
                        });
                        throw e_14;
                    case 4:
                        span.end();
                        return [7 /*endfinally*/];
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    return DataLakeFileClient;
}(DataLakePathClient));
export { DataLakeFileClient };
//# sourceMappingURL=clients.js.map