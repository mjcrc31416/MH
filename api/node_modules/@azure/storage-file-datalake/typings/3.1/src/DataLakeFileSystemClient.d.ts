import { TokenCredential } from "@azure/core-http";
import { PagedAsyncIterableIterator } from "@azure/core-paging";
import { AnonymousCredential } from "./credentials/AnonymousCredential";
import { StorageSharedKeyCredential } from "./credentials/StorageSharedKeyCredential";
import { DataLakeLeaseClient } from "./DataLakeLeaseClient";
import { AccessPolicy, FileSystemCreateOptions, FileSystemCreateResponse, FileSystemDeleteOptions, FileSystemDeleteResponse, FileSystemGetAccessPolicyOptions, FileSystemGetAccessPolicyResponse, FileSystemGetPropertiesOptions, FileSystemGetPropertiesResponse, FileSystemSetAccessPolicyOptions, FileSystemSetAccessPolicyResponse, FileSystemSetMetadataOptions, FileSystemSetMetadataResponse, ListPathsOptions, Metadata, Path, PublicAccessType, SignedIdentifier, FileSystemListPathsResponse } from "./models";
import { Pipeline, StoragePipelineOptions } from "./Pipeline";
import { StorageClient } from "./StorageClient";
import { DataLakeFileClient, DataLakeDirectoryClient } from "./clients";
/**
 * A DataLakeFileSystemClient represents a URL to the Azure Storage file system
 * allowing you to manipulate its directories and files.
 *
 * @export
 * @class DataLakeFileSystemClient
 * @extends {StorageClient}
 */
export declare class DataLakeFileSystemClient extends StorageClient {
    /**
     * fileSystemContext provided by protocol layer.
     *
     * @private
     * @type {FileSystemOperations}
     * @memberof DataLakeFileSystemClient
     */
    private fileSystemContext;
    /**
     * blobContainerClient provided by @azure/storage-blob package.
     *
     * @private
     * @type {ContainerClient}
     * @memberof DataLakeFileSystemClient
     */
    private blobContainerClient;
    /**
     * Creates an instance of DataLakeFileSystemClient from url and credential.
     *
     * @param {string} url A Client string pointing to Azure Storage data lake file system, such as
     *                     "https://myaccount.dfs.core.windows.net/filesystem". You can append a SAS
     *                     if using AnonymousCredential, such as "https://myaccount.dfs.core.windows.net/filesystem?sasString".
     * @param {(StorageSharedKeyCredential | AnonymousCredential | TokenCredential)} [credential] Such as AnonymousCredential, StorageSharedKeyCredential or any credential from the @azure/identity package to authenticate requests to the service. You can also provide an object that implements the TokenCredential interface. If not specified, AnonymousCredential is used.
     * @param {StoragePipelineOptions} [options] Optional. Options to configure the HTTP pipeline.
     * @memberof DataLakeFileSystemClient
     */
    constructor(url: string, credential?: StorageSharedKeyCredential | AnonymousCredential | TokenCredential, options?: StoragePipelineOptions);
    /**
     * Creates an instance of DataLakeFileSystemClient from url and pipeline.
     *
     * @param {string} url A Client string pointing to Azure Storage data lake file system, such as
     *                     "https://myaccount.dfs.core.windows.net/filesystem". You can append a SAS
     *                     if using AnonymousCredential, such as "https://myaccount.dfs.core.windows.net/filesystem?sasString".
     * @param {Pipeline} pipeline Call newPipeline() to create a default
     *                            pipeline, or provide a customized pipeline.
     * @memberof DataLakeFileSystemClient
     */
    constructor(url: string, pipeline: Pipeline);
    readonly name: string;
    /**
     * Creates a {@link DataLakeDirectoryClient} object under current file system.
     *
     * @param {string} directoryName
     * @returns {DataLakeDirectoryClient}
     * @memberof DataLakeFileSystemClient
     */
    getDirectoryClient(directoryName: string): DataLakeDirectoryClient;
    /**
     * Creates a {@link DataLakeFileClient} object under current file system.
     *
     * @param {string} fileName
     * @returns {DataLakeFileClient}
     * @memberof DataLakeFileSystemClient
     */
    getFileClient(fileName: string): DataLakeFileClient;
    /**
     * Get a {@link DataLakeLeaseClient} that manages leases on the file system.
     *
     * @param {string} [proposeLeaseId] Optional. Initial proposed lease Id.
     * @returns {DataLakeLeaseClient}
     * @memberof DataLakeFileSystemClient
     */
    getDataLakeLeaseClient(proposeLeaseId?: string): DataLakeLeaseClient;
    /**
     * Creates a new file system under the specified account. If the file system with
     * the same name already exists, the operation fails.
     *
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/create-container
     *
     * @param {FileSystemCreateOptions} [options={}] Optional. Options when creating file system.
     * @returns {Promise<FileSystemCreateResponse>}
     * @memberof DataLakeFileSystemClient
     */
    create(options?: FileSystemCreateOptions): Promise<FileSystemCreateResponse>;
    /**
     * Delete current file system.
     *
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/delete-container
     *
     * @param {FileSystemDeleteOptions} [options={}] Optional. Options when deleting file system.
     * @returns {Promise<FileSystemDeleteResponse>}
     * @memberof DataLakeFileSystemClient
     */
    delete(options?: FileSystemDeleteOptions): Promise<FileSystemDeleteResponse>;
    /**
     * Returns all user-defined metadata and system properties for the specified
     * file system.
     *
     * WARNING: The `metadata` object returned in the response will have its keys in lowercase, even if
     * they originally contained uppercase characters. This differs from the metadata keys returned by
     * the `listFileSystems` method of {@link DataLakeServiceClient} using the `includeMetadata` option, which
     * will retain their original casing.
     *
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/get-container-properties
     *
     * @param {FileSystemGetPropertiesOptions} [options={}] Optional. Options when getting file system properties.
     * @returns {Promise<FileSystemGetPropertiesResponse>}
     * @memberof DataLakeFileSystemClient
     */
    getProperties(options?: FileSystemGetPropertiesOptions): Promise<FileSystemGetPropertiesResponse>;
    /**
     * Sets one or more user-defined name-value pairs for the specified file system.
     *
     * If no option provided, or no metadata defined in the parameter, the file system
     * metadata will be removed.
     *
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/set-container-metadata
     *
     * @param {Metadata} [metadata] Replace existing metadata with this value.
     *                              If no value provided the existing metadata will be removed.
     * @param {FileSystemSetMetadataOptions} [options={}] Optional. Options when setting file system metadata.
     * @returns {Promise<FileSystemSetMetadataResponse>}
     * @memberof DataLakeFileSystemClient
     */
    setMetadata(metadata?: Metadata, options?: FileSystemSetMetadataOptions): Promise<FileSystemSetMetadataResponse>;
    /**
     * Gets the permissions for the specified file system. The permissions indicate
     * whether file system data may be accessed publicly.
     *
     * WARNING: JavaScript Date will potentially lose precision when parsing startsOn and expiresOn strings.
     * For example, new Date("2018-12-31T03:44:23.8827891Z").toISOString() will get "2018-12-31T03:44:23.882Z".
     *
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/get-container-acl
     *
     * @param {FileSystemGetAccessPolicyOptions} [options={}] Optional. Options when getting file system access policy.
     * @returns {Promise<FileSystemGetAccessPolicyResponse>}
     * @memberof DataLakeFileSystemClient
     */
    getAccessPolicy(options?: FileSystemGetAccessPolicyOptions): Promise<FileSystemGetAccessPolicyResponse>;
    /**
     * Sets the permissions for the specified file system. The permissions indicate
     * whether directories or files in a file system may be accessed publicly.
     *
     * When you set permissions for a file system, the existing permissions are replaced.
     * If no access or containerAcl provided, the existing file system ACL will be
     * removed.
     *
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/set-container-acl
     *
     * @param {PublicAccessType} [access] Optional. The level of public access to data in the file system.
     * @param {SignedIdentifier<AccessPolicy>[]} [fileSystemAcl] Optional. Array of elements each having a unique Id and details of the access policy.
     * @param {FileSystemSetAccessPolicyOptions} [options={}] Optional. Options when setting file system access policy.
     * @returns {Promise<FileSystemSetAccessPolicyResponse>}
     * @memberof DataLakeFileSystemClient
     */
    setAccessPolicy(access?: PublicAccessType, fileSystemAcl?: SignedIdentifier<AccessPolicy>[], options?: FileSystemSetAccessPolicyOptions): Promise<FileSystemSetAccessPolicyResponse>;
    /**
     * Returns an async iterable iterator to list all the paths (directories and files)
     * under the specified file system.
     *
     * .byPage() returns an async iterable iterator to list the paths in pages.
     *
     * Example using `for await` syntax:
     *
     * ```js
     * // Get the fileSystemClient before you run these snippets,
     * // Can be obtained from `serviceClient.getFileSystemClient("<your-filesystem-name>");`
     * let i = 1;
     * for await (const path of fileSystemClient.listPaths()) {
     *   console.log(`Path ${i++}: ${path.name}, isDirectory?: ${path.isDirectory}`);
     * }
     * ```
     *
     * Example using `iter.next()`:
     *
     * ```js
     * let i = 1;
     * let iter = fileSystemClient.listPaths();
     * let pathItem = await iter.next();
     * while (!pathItem.done) {
     *   console.log(`Path ${i++}: ${pathItem.value.name}, isDirectory?: ${pathItem.value.isDirectory}`);
     *   pathItem = await iter.next();
     * }
     * ```
     *
     * Example using `byPage()`:
     *
     * ```js
     * // passing optional maxPageSize in the page settings
     * let i = 1;
     * for await (const response of fileSystemClient.listPaths().byPage({ maxPageSize: 20 })) {
     *   for (const path of response.pathItems) {
     *     console.log(`Path ${i++}: ${path.name}, isDirectory?: ${path.isDirectory}`);
     *   }
     * }
     * ```
     *
     * Example using paging with a marker:
     *
     * ```js
     * let i = 1;
     * let iterator = fileSystemClient.listPaths().byPage({ maxPageSize: 2 });
     * let response = (await iterator.next()).value;
     *
     * // Prints 2 path names
     * for (const path of response.pathItems) {
     *   console.log(`Path ${i++}: ${path.name}, isDirectory?: ${path.isDirectory}`);
     * }
     *
     * // Gets next marker
     * let marker = response.continuationToken;
     *
     * // Passing next marker as continuationToken
     *
     * iterator = fileSystemClient.listPaths().byPage({ continuationToken: marker, maxPageSize: 10 });
     * response = (await iterator.next()).value;
     *
     * // Prints 10 path names
     * for (const path of response.pathItems) {
     *   console.log(`Path ${i++}: ${path.name}, isDirectory?: ${path.isDirectory}`);
     * }
     * ```
     *
     * @see https://docs.microsoft.com/rest/api/storageservices/list-blobs
     *
     * @param {ListPathsOptions} [options={}] Optional. Options when listing paths.
     * @returns {PagedAsyncIterableIterator<Path, FileSystemListPathsResponse>}
     * @memberof DataLakeFileSystemClient
     */
    listPaths(options?: ListPathsOptions): PagedAsyncIterableIterator<Path, FileSystemListPathsResponse>;
    private listItems;
    private listSegments;
    private listPathsSegment;
}
//# sourceMappingURL=DataLakeFileSystemClient.d.ts.map
